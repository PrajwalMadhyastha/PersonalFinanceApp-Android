Project Context for Personal Finance App
Generated on: Tue Jun 24 17:55:25 IST 2025
========================================

================== FILE: ./build.gradle.kts (Project) ==================
plugins {
    id("com.android.application") version "8.4.1" apply false
    // Set the Kotlin version for the entire project.
    id("org.jetbrains.kotlin.android") version "2.0.0" apply false
    // Set the KSP version for the entire project.
    id("com.google.devtools.ksp") version "2.0.0-1.0.21" apply false
    // --- ADDED: Declare the Compose Compiler plugin for the project ---
    id("org.jetbrains.kotlin.plugin.compose") version "2.0.0" apply false

    id("org.jetbrains.kotlin.plugin.serialization") version "2.0.0" apply false
}


================== FILE: ./app/build.gradle.kts (App) ==================
// It's good practice to define versions in one place.
val room_version = "2.6.1"
val lifecycle_version = "2.8.2"
val activity_compose_version = "1.9.0"
val core_ktx_version = "1.13.1"
val navigation_version = "2.7.7"
// --- REVISED: Unified and updated test library versions ---
val androidx_test_version = "1.6.1"
val test_ext_junit_version = "1.2.1"
val espresso_version = "3.6.1"
val tracing_version = "1.2.0" // Added for tracing fix
val work_version = "2.9.0"


plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("com.google.devtools.ksp")
    id("org.jetbrains.kotlin.plugin.compose")
    id("org.jetbrains.kotlin.plugin.serialization")
}

android {
    namespace = "com.example.personalfinanceapp"
    compileSdk = 35

    defaultConfig {
        applicationId = "com.example.personalfinanceapp"
        minSdk = 24
        targetSdk = 35
        versionCode = 1
        versionName = "1.0"
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
        ksp {
            arg("room.schemaLocation", "$projectDir/schemas")
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
    kotlinOptions {
        jvmTarget = "1.8"
    }
    buildFeatures {
        compose = true
    }
    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }
}

configurations.all {
    resolutionStrategy {
        force("androidx.core:core-ktx:$core_ktx_version")
        force("androidx.core:core:$core_ktx_version")
    }
}

dependencies {
    implementation("androidx.core:core-ktx:$core_ktx_version")
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version")
    implementation("androidx.activity:activity-compose:$activity_compose_version")

    implementation(platform("androidx.compose:compose-bom:2024.06.00"))
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-graphics")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")
    implementation("androidx.compose.material:material-icons-extended")

    implementation("androidx.room:room-runtime:$room_version")
    implementation("androidx.room:room-ktx:$room_version")
    implementation("androidx.appcompat:appcompat:1.7.1")
    ksp("androidx.room:room-compiler:$room_version")

    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:$lifecycle_version")
    implementation("androidx.navigation:navigation-compose:$navigation_version")

    implementation("com.google.android.material:material:1.12.0")

    implementation("com.github.PhilJay:MPAndroidChart:v3.1.0")

    // Local unit tests
    testImplementation("junit:junit:4.13.2")

    // --- REVISED: Instrumented UI tests ---
    // THE FIX: Explicitly add tracing-ktx to resolve the NoSuchMethodError
    androidTestImplementation("androidx.tracing:tracing-ktx:$tracing_version")
    androidTestImplementation("androidx.test:runner:$androidx_test_version")
    androidTestImplementation("androidx.test:core-ktx:$androidx_test_version")
    androidTestImplementation("androidx.test.ext:junit-ktx:$test_ext_junit_version")
    androidTestImplementation("androidx.test:rules:$androidx_test_version")
    androidTestImplementation("androidx.test.espresso:espresso-core:$espresso_version")
    androidTestImplementation(platform("androidx.compose:compose-bom:2024.06.00"))
    androidTestImplementation("androidx.compose.ui:ui-test-junit4")

    // Debug dependencies
    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")

    implementation("androidx.biometric:biometric:1.2.0-alpha05")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3")
    implementation("androidx.work:work-runtime-ktx:$work_version")
}



================== FILE: ./app/src/main/AndroidManifest.xml ==================
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.READ_SMS" />
    <uses-permission android:name="android.permission.RECEIVE_SMS" />
    <uses-permission android:name="android.permission.USE_BIOMETRIC" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>

    <application
        android:name=".MainApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.PersonalFinanceApp"
        tools:targetApi="31">

        <meta-data
            android:name="com.google.firebase.messaging.default_notification_icon"
            android:resource="@drawable/ic_launcher_foreground" />

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:label="@string/app_name"
            android:theme="@style/Theme.PersonalFinanceApp">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />
                <data
                    android:host="personalfinanceapp.example.com"
                    android:scheme="app" />
            </intent-filter>
        </activity>

        <receiver
            android:name=".SmsReceiver"
            android:exported="true"
            android:permission="android.permission.BROADCAST_SMS">
            <intent-filter android:priority="999">
                <action android:name="android.provider.Telephony.SMS_RECEIVED" />
            </intent-filter>
        </receiver>

    </application>

</manifest>



================== FILE: ./app/src/androidTest/java/com/example/personalfinanceapp/AppNavigationTest.kt ==================
package com.example.personalfinanceapp

import android.Manifest
import android.content.Context
import androidx.compose.ui.semantics.SemanticsProperties
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.rule.GrantPermissionRule
import org.junit.Rule
import org.junit.Test
import org.junit.rules.RuleChain
import org.junit.rules.TestRule
import org.junit.runner.Description
import org.junit.runner.RunWith
import org.junit.runners.model.Statement

/**
 * A custom JUnit Rule to disable the app lock feature before a test runs.
 * This ensures the lock screen does not interfere with UI tests.
 */
class DisableAppLockRule : TestRule {
    override fun apply(base: Statement, description: Description): Statement {
        return object : Statement() {
            override fun evaluate() {
                try {
                    val context = InstrumentationRegistry.getInstrumentation().targetContext
                    val prefs = context.getSharedPreferences("app_settings", Context.MODE_PRIVATE)
                    prefs.edit().putBoolean("app_lock_enabled", false).commit()
                    base.evaluate()
                } finally {
                    // Cleanup if needed
                }
            }
        }
    }
}

/**
 * Instrumented UI test for the main app navigation.
 */
@RunWith(AndroidJUnit4::class)
class AppNavigationTest {

    private val composeTestRule = createAndroidComposeRule<MainActivity>()

    /**
     * The RuleChain ensures our custom rules run in the correct order:
     * 1. DisableAppLockRule runs first to turn off the app's biometric lock.
     * 2. GrantPermissionRule runs next to handle system-level OS permissions.
     * 3. The composeTestRule finally launches the activity into a clean, predictable state.
     */
    @get:Rule
    val ruleChain: RuleChain = RuleChain
        .outerRule(DisableAppLockRule())
        .around(GrantPermissionRule.grant(
            Manifest.permission.READ_SMS,
            Manifest.permission.RECEIVE_SMS,
            Manifest.permission.POST_NOTIFICATIONS
        ))
        .around(composeTestRule)

    /**
     * Tests the navigation from the Dashboard screen to the Settings screen.
     */
    @Test
    fun testAppNavigation_fromDashboardToSettings() {
        // 1. Wait for the Dashboard screen to appear. This is the most robust way
        // to handle any initial app setup or race conditions.
        val isHeading = SemanticsMatcher.keyIsDefined(SemanticsProperties.Heading)
        composeTestRule.waitUntil(timeoutMillis = 10000) {
            composeTestRule.onAllNodesWithText("Dashboard").fetchSemanticsNodes().isNotEmpty()
        }

        // Now that the UI has settled, we can safely perform our assertions.
        composeTestRule.onNode(
            hasText("Dashboard") and isHeading
        ).assertIsDisplayed()

        // 2. Find and click the Settings icon button.
        composeTestRule.onNodeWithContentDescription("Settings").performClick()

        // 3. Verify that we have navigated to the Settings screen by waiting for
        // the "GENERAL" text to appear (it's uppercased in the UI).
        composeTestRule.waitUntil(timeoutMillis = 5000) {
            composeTestRule.onAllNodesWithText("GENERAL").fetchSemanticsNodes().isNotEmpty()
        }

        // Assert that the "Settings" title is now displayed.
        composeTestRule.onNode(
            hasText("Settings") and isHeading
        ).assertIsDisplayed()

        // Confirm the "GENERAL" header is visible as a final check.
        composeTestRule.onNodeWithText("GENERAL").assertIsDisplayed()
    }
}
-e 


================== FILE: ./app/src/androidTest/java/com/example/personalfinanceapp/ExampleInstrumentedTest.kt ==================
package com.example.personalfinanceapp

import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.ext.junit.runners.AndroidJUnit4

import org.junit.Test
import org.junit.runner.RunWith

import org.junit.Assert.*

/**
 * Instrumented test, which will execute on an Android device.
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {
    @Test
    fun useAppContext() {
        // Context of the app under test.
        val appContext = InstrumentationRegistry.getInstrumentation().targetContext
        assertEquals("com.example.personalfinanceapp", appContext.packageName)
    }
}-e 


================== FILE: ./app/src/test/java/com/example/personalfinanceapp/ExampleUnitTest.kt ==================
package com.example.personalfinanceapp

import org.junit.Test

import org.junit.Assert.*

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}-e 


================== FILE: ./app/src/test/java/com/example/personalfinanceapp/SmsParserTest.kt ==================
package com.example.personalfinanceapp

import org.junit.Assert.*
import org.junit.Test

/**
 * Unit tests for the SmsParser utility.
 * These tests run on the local JVM and do not require an Android device or emulator.
 */
class SmsParserTest {

    // A mock map of user-defined mappings, empty for these tests.
    private val emptyMappings = emptyMap<String, String>()

    @Test
    fun `test parses debit message successfully`() {
        val smsBody = "Your account with HDFC Bank has been debited for Rs. 750.50 at Amazon on 22-Jun-2025."
        val mockSms = SmsMessage(id = 1L, sender = "AM-HDFCBK", body = smsBody, date = System.currentTimeMillis())

        val result = SmsParser.parse(mockSms, emptyMappings)

        assertNotNull("Parser should return a result for a debit message", result)
        assertEquals(750.50, result?.amount)
        assertEquals("expense", result?.transactionType)
        assertEquals("Amazon", result?.merchantName)
    }

    @Test
    fun `test parses credit message successfully`() {
        val smsBody = "You have received a credit of INR 5,000.00 from Freelance Client."
        val mockSms = SmsMessage(id = 2L, sender = "DM-SOMEBK", body = smsBody, date = System.currentTimeMillis())

        val result = SmsParser.parse(mockSms, emptyMappings)

        assertNotNull("Parser should return a result for a credit message", result)
        assertEquals(5000.00, result?.amount)
        assertEquals("income", result?.transactionType)
        assertEquals("Freelance Client", result?.merchantName)
    }

    @Test
    fun `test returns null for non-financial message`() {
        val smsBody = "Hello, just checking in. Are we still on for dinner tomorrow evening?"
        val mockSms = SmsMessage(id = 3L, sender = "+1234567890", body = smsBody, date = System.currentTimeMillis())

        val result = SmsParser.parse(mockSms, emptyMappings)

        assertNull("Parser should return null for a non-financial message", result)
    }

    @Test
    fun `test parses HDFC debit message with complex merchant name`() {
        val smsBody = "Spent Rs.388.19 On HDFC Bank Card 9922 At ..MC DONALDS_ on 2025-06-22."
        val mockSms = SmsMessage(id = 4L, sender = "JD-HDFCBK", body = smsBody, date = System.currentTimeMillis())

        val result = SmsParser.parse(mockSms, emptyMappings)

        assertNotNull(result)
        assertEquals(388.19, result?.amount)
        assertEquals("expense", result?.transactionType)
        assertEquals("MC DONALDS", result?.merchantName) // Note: underscore is cleaned up
    }
}
-e 


================== FILE: ./app/src/main/java/DataExportService.kt ==================
package com.example.personalfinanceapp

import android.content.Context
import android.net.Uri
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.withContext
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json

object DataExportService {

    private val json = Json { prettyPrint = true; isLenient = true; ignoreUnknownKeys = true }

    suspend fun exportToJsonString(context: Context): String? {
        return withContext(Dispatchers.IO) {
            try {
                val db = AppDatabase.getInstance(context)

                val backupData = AppDataBackup(
                    transactions = db.transactionDao().getAllTransactionsSimple().first(),
                    accounts = db.accountDao().getAllAccounts().first(),
                    categories = db.categoryDao().getAllCategories().first(),
                    budgets = db.budgetDao().getAllBudgets().first(),
                    merchantMappings = db.merchantMappingDao().getAllMappings().first()
                )

                json.encodeToString(backupData)
            } catch (e: Exception) {
                e.printStackTrace()
                null
            }
        }
    }

    /**
     * NEW: Wipes the entire database and restores it from a JSON backup.
     * @param context The application context.
     * @param uri The URI of the JSON file selected by the user.
     * @return True if successful, false otherwise.
     */
    suspend fun importDataFromJson(context: Context, uri: Uri): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                // Step 1: Read the JSON content from the file URI
                val jsonString = context.contentResolver.openInputStream(uri)?.bufferedReader().use { it?.readText() }
                if (jsonString == null) {
                    return@withContext false
                }

                // Step 2: Parse the JSON into our backup data class
                val backupData = json.decodeFromString<AppDataBackup>(jsonString)

                // Step 3: Get database instance and DAOs
                val db = AppDatabase.getInstance(context)
                val transactionDao = db.transactionDao()
                val accountDao = db.accountDao()
                val categoryDao = db.categoryDao()
                val budgetDao = db.budgetDao()
                val merchantMappingDao = db.merchantMappingDao()

                // Step 4: WIPE ALL EXISTING DATA
                transactionDao.deleteAll()
                accountDao.deleteAll()
                categoryDao.deleteAll()
                budgetDao.deleteAll()
                merchantMappingDao.deleteAll()

                // Step 5: Insert all the data from the backup
                accountDao.insertAll(backupData.accounts)
                categoryDao.insertAll(backupData.categories)
                budgetDao.insertAll(backupData.budgets)
                merchantMappingDao.insertAll(backupData.merchantMappings)
                transactionDao.insertAll(backupData.transactions)

                true // Return success
            } catch (e: Exception) {
                e.printStackTrace()
                false // Return failure
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/AccountRepository.kt ==================
package com.example.personalfinanceapp

import kotlinx.coroutines.flow.Flow

class AccountRepository(private val accountDao: AccountDao) {

    // Expose the new query result to the ViewModel
    val accountsWithBalance: Flow<List<AccountWithBalance>> = accountDao.getAccountsWithBalance()

    val allAccounts: Flow<List<Account>> = accountDao.getAllAccounts()

    fun getAccountById(accountId: Int): Flow<Account?> {
        return accountDao.getAccountById(accountId)
    }

    suspend fun insert(account: Account) {
        accountDao.insert(account)
    }

    suspend fun update(account: Account) {
        accountDao.update(account)
    }

    suspend fun delete(account: Account) {
        accountDao.delete(account)
    }
}
-e 


================== FILE: ./app/src/main/java/BudgetRepository.kt ==================
package com.example.personalfinanceapp

import kotlinx.coroutines.flow.Flow

class BudgetRepository(private val budgetDao: BudgetDao) {

    fun getBudgetsForMonth(month: Int, year: Int): Flow<List<Budget>> {
        return budgetDao.getBudgetsForMonth(month, year)
    }

    // Expose the more efficient query to the ViewModel
    fun getActualSpendingForCategory(categoryName: String, month: Int, year: Int): Flow<Double?> {
        return budgetDao.getActualSpendingForCategory(categoryName, month, year)
    }

    suspend fun insert(budget: Budget) {
        budgetDao.insert(budget)
    }
}
-e 


================== FILE: ./app/src/main/java/TransactionViewModel.kt ==================
package com.example.personalfinanceapp

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

class TransactionViewModel(application: Application) : AndroidViewModel(application) {

    private val transactionRepository: TransactionRepository
    private val accountRepository: AccountRepository
    private val categoryRepository: CategoryRepository

    val allTransactions: Flow<List<TransactionDetails>>
    val allAccounts: Flow<List<Account>>
    val allCategories: Flow<List<Category>>

    private val _validationError = MutableStateFlow<String?>(null)
    val validationError = _validationError.asStateFlow()

    init {
        val db = AppDatabase.getInstance(application)
        transactionRepository = TransactionRepository(db.transactionDao())
        accountRepository = AccountRepository(db.accountDao())
        categoryRepository = CategoryRepository(db.categoryDao())

        allTransactions = transactionRepository.allTransactions
        allAccounts = accountRepository.allAccounts
        allCategories = categoryRepository.allCategories
    }

    fun getTransactionById(id: Int): Flow<Transaction?> {
        return transactionRepository.getTransactionById(id)
    }

    // --- UPDATED: Now accepts sourceSmsId ---
    fun addTransaction(
        description: String,
        categoryId: Int?,
        amountStr: String,
        accountId: Int,
        notes: String?,
        date: Long,
        transactionType: String,
        sourceSmsId: Long? // New parameter
    ): Boolean {
        if (description.isBlank()) {
            _validationError.value = "Description cannot be empty."
            return false
        }
        val amount = amountStr.toDoubleOrNull()
        if (amount == null || amount <= 0.0) {
            _validationError.value = "Please enter a valid, positive amount."
            return false
        }

        val newTransaction = Transaction(
            description = description,
            categoryId = categoryId,
            amount = amount,
            date = date,
            accountId = accountId,
            notes = notes,
            transactionType = transactionType,
            sourceSmsId = sourceSmsId // Pass the ID to the constructor
        )
        viewModelScope.launch {
            transactionRepository.insert(newTransaction)
        }
        _validationError.value = null
        return true
    }

    // --- UPDATED: Validation logic simplified ---
    fun updateTransaction(transaction: Transaction): Boolean {
        if (transaction.description.isBlank()) {
            _validationError.value = "Description cannot be empty."
            return false
        }
        if (transaction.amount <= 0.0) { // Amount must be positive
            _validationError.value = "Amount must be a valid, positive number."
            return false
        }

        viewModelScope.launch {
            transactionRepository.update(transaction)
        }
        _validationError.value = null // Clear error on success
        return true
    }

    fun deleteTransaction(transaction: Transaction) = viewModelScope.launch {
        transactionRepository.delete(transaction)
    }

    fun clearError() {
        _validationError.value = null
    }
}
-e 


================== FILE: ./app/src/main/java/TransactionDetails.kt ==================
package com.example.personalfinanceapp

import androidx.room.Embedded

/**
 * A data class to hold the combined result of a database query.
 * It includes the full Transaction object, plus the names of the
 * linked Account and Category for easy display in the UI.
 */
data class TransactionDetails(
    @Embedded
    val transaction: Transaction,
    val accountName: String?,
    val categoryName: String?
)
-e 


================== FILE: ./app/src/main/java/SearchViewModel.kt ==================
package com.example.personalfinanceapp

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch

data class SearchUiState(
    val keyword: String = "",
    val selectedAccount: Account? = null,
    val selectedCategory: Category? = null,
    val transactionType: String = "All", // "All", "Income", "Expense"
    val startDate: Long? = null,
    val endDate: Long? = null,
    val accounts: List<Account> = emptyList(),
    val categories: List<Category> = emptyList(),
    val hasSearched: Boolean = false
)

class SearchViewModel(
    private val transactionDao: TransactionDao,
    private val accountDao: AccountDao,
    private val categoryDao: CategoryDao
) : ViewModel() {

    private val _uiState = MutableStateFlow(SearchUiState())
    val uiState: StateFlow<SearchUiState> = _uiState.asStateFlow()

    private val _searchResults = MutableStateFlow<List<TransactionDetails>>(emptyList())
    val searchResults: StateFlow<List<TransactionDetails>> = _searchResults.asStateFlow()

    init {
        viewModelScope.launch {
            accountDao.getAllAccounts().collect { accounts ->
                _uiState.update { it.copy(accounts = accounts) }
            }
        }
        viewModelScope.launch {
            categoryDao.getAllCategories().collect { categories ->
                _uiState.update { it.copy(categories = categories) }
            }
        }
    }

    fun onKeywordChange(newKeyword: String) {
        _uiState.update { it.copy(keyword = newKeyword) }
    }

    fun onAccountChange(account: Account?) {
        _uiState.update { it.copy(selectedAccount = account) }
    }

    fun onCategoryChange(category: Category?) {
        _uiState.update { it.copy(selectedCategory = category) }
    }

    // CORRECTED: The 'type' parameter is now nullable to handle when the user clears the filter.
    fun onTypeChange(type: String?) {
        // If the type is null (cleared), default back to "All".
        _uiState.update { it.copy(transactionType = type ?: "All") }
    }

    fun onDateChange(start: Long? = _uiState.value.startDate, end: Long? = _uiState.value.endDate) {
        _uiState.update { it.copy(startDate = start, endDate = end) }
    }

    fun clearFilters() {
        _uiState.value = SearchUiState(
            accounts = _uiState.value.accounts,
            categories = _uiState.value.categories
        )
        _searchResults.value = emptyList()
    }

    fun executeSearch() {
        viewModelScope.launch {
            val state = _uiState.value
            _searchResults.value = transactionDao.searchTransactions(
                keyword = state.keyword,
                accountId = state.selectedAccount?.id,
                categoryId = state.selectedCategory?.id,
                transactionType = if (state.transactionType.equals("All", ignoreCase = true)) null else state.transactionType.lowercase(),
                startDate = state.startDate,
                endDate = state.endDate
            )
            _uiState.update { it.copy(hasSearched = true) }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/ReviewReminderWorker.kt ==================
package com.example.personalfinanceapp

import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.pm.PackageManager
import android.util.Log
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.core.net.toUri
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.withContext

class ReviewReminderWorker(
    private val context: Context,
    workerParams: WorkerParameters
) : CoroutineWorker(context, workerParams) {

    override suspend fun doWork(): Result {
        Log.d("ReviewReminderWorker", "Worker starting...")
        return withContext(Dispatchers.IO) {
            try {
                // 1. Get database instance and DAOs
                val db = AppDatabase.getInstance(context)
                val transactionDao = db.transactionDao()
                val merchantMappingDao = db.merchantMappingDao()

                // 2. Fetch all SMS messages from the device
                val smsRepository = SmsRepository(context)
                val allSms = smsRepository.fetchAllSms()
                Log.d("ReviewReminderWorker", "Fetched ${allSms.size} SMS messages.")

                // 3. Get existing merchant mappings and already-imported SMS IDs for de-duplication
                val existingMappings = merchantMappingDao.getAllMappings().first()
                    .associateBy({ it.smsSender }, { it.merchantName })

                // CORRECTED: Called the correct DAO method: getAllTransactions()
                val existingSmsIds = transactionDao.getAllTransactions().first()
                    .mapNotNull { it.transaction.sourceSmsId }
                    .toSet()
                Log.d("ReviewReminderWorker", "Found ${existingSmsIds.size} already imported SMS IDs.")

                // 4. Parse all SMS messages and filter out the ones already imported
                val newPotentialTransactions = allSms.mapNotNull { sms ->
                    SmsParser.parse(sms, existingMappings)
                }.filter { potentialTransaction ->
                    potentialTransaction.sourceSmsId?.let { !existingSmsIds.contains(it) } ?: true
                }

                // 5. If there are transactions to review, send a notification
                val reviewCount = newPotentialTransactions.size
                Log.d("ReviewReminderWorker", "Found $reviewCount new transactions to review.")
                if (reviewCount > 0) {
                    sendNotification(reviewCount)
                }

                Log.d("ReviewReminderWorker", "Worker finished successfully.")
                Result.success()
            } catch (e: Exception) {
                Log.e("ReviewReminderWorker", "Worker failed", e)
                Result.retry()
            }
        }
    }

    private fun sendNotification(reviewCount: Int) {
        if (ActivityCompat.checkSelfPermission(context, android.Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
            Log.w("ReviewReminderWorker", "Notification permission not granted. Cannot send reminder.")
            return
        }

        val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        val channelId = MainApplication.REMINDER_CHANNEL_ID

        val intent = android.content.Intent(
            android.content.Intent.ACTION_VIEW,
            "app://personalfinanceapp.example.com/review_sms".toUri(),
            context,
            MainActivity::class.java
        )

        val pendingIntent = PendingIntent.getActivity(context, 0, intent, PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT)

        val notification = NotificationCompat.Builder(context, channelId)
            .setSmallIcon(R.drawable.ic_launcher_foreground)
            .setContentTitle("Pending Transactions")
            .setContentText("You have $reviewCount new transactions to review.")
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .build()

        notificationManager.notify(1, notification)
        Log.d("ReviewReminderWorker", "Reminder notification sent.")
    }
}
-e 


================== FILE: ./app/src/main/java/RecurringTransactionDao.kt ==================
package com.example.personalfinanceapp

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import kotlinx.coroutines.flow.Flow

@Dao
interface RecurringTransactionDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(recurringTransaction: RecurringTransaction)

    @Update
    suspend fun update(recurringTransaction: RecurringTransaction)

    @Delete
    suspend fun delete(recurringTransaction: RecurringTransaction)

    @Query("SELECT * FROM recurring_transactions ORDER BY startDate DESC")
    fun getAll(): Flow<List<RecurringTransaction>>

    @Query("SELECT * FROM recurring_transactions WHERE id = :id")
    fun getById(id: Int): Flow<RecurringTransaction?>
}
-e 


================== FILE: ./app/src/main/java/MerchantMapping.kt ==================
package com.example.personalfinanceapp

import androidx.room.Entity
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

@Serializable
@Entity(tableName = "merchant_mappings")
data class MerchantMapping(
    @PrimaryKey
    val smsSender: String, // e.g., "AM-HDFCBK"
    val merchantName: String // e.g., "McDonald's"
)
-e 


================== FILE: ./app/src/main/java/AccountWithBalance.kt ==================
package com.example.personalfinanceapp

import androidx.room.Embedded

/**
 * A data class to hold an Account and its dynamically calculated balance.
 * This is used for display purposes in the UI and is not a database entity.
 */
data class AccountWithBalance(
    @Embedded
    val account: Account,
    val balance: Double
)
-e 


================== FILE: ./app/src/main/java/Account.kt ==================
package com.example.personalfinanceapp

import androidx.room.Entity
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

@Serializable
@Entity(tableName = "accounts")
data class Account(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val name: String,
    val type: String
    // The balance field is intentionally removed from the database entity.
    // It will be calculated on-the-fly.
)
-e 


================== FILE: ./app/src/main/java/SmsMessage.kt ==================
package com.example.personalfinanceapp

/**
 * A simple data class to hold the relevant information from an SMS message.
 */
data class SmsMessage(
    val id: Long,
    val sender: String,
    val body: String,
    val date: Long
)

-e 


================== FILE: ./app/src/main/java/MonthlyTrend.kt ==================
package com.example.personalfinanceapp

data class MonthlyTrend(
    val monthYear: String, // Format: "YYYY-MM"
    val totalIncome: Double,
    val totalExpenses: Double
)
-e 


================== FILE: ./app/src/main/java/RecurringTransaction.kt ==================
package com.example.personalfinanceapp

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

@Serializable
@Entity(
    tableName = "recurring_transactions",
    indices = [
        Index(value = ["accountId"]),
        Index(value = ["categoryId"])
    ],
    foreignKeys = [
        ForeignKey(
            entity = Account::class,
            parentColumns = ["id"],
            childColumns = ["accountId"],
            onDelete = ForeignKey.CASCADE
        ),
        ForeignKey(
            entity = Category::class,
            parentColumns = ["id"],
            childColumns = ["categoryId"],
            onDelete = ForeignKey.SET_NULL
        )
    ]
)
data class RecurringTransaction(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val description: String,
    val amount: Double,
    val transactionType: String, // "income" or "expense"
    val recurrenceInterval: String, // e.g., "Monthly", "Weekly", "Yearly"
    val startDate: Long, // Timestamp for the first occurrence
    val accountId: Int,
    val categoryId: Int?
)
-e 


================== FILE: ./app/src/main/java/CategoryViewModel.kt ==================
package com.example.personalfinanceapp

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.firstOrNull
import kotlinx.coroutines.flow.receiveAsFlow
import kotlinx.coroutines.launch

/**
 * ViewModel to handle the business logic for Categories.
 */
class CategoryViewModel(application: Application) : AndroidViewModel(application) {

    private val categoryRepository: CategoryRepository
    // --- NEW: Add dependency on TransactionRepository for validation ---
    private val transactionRepository: TransactionRepository

    val allCategories: Flow<List<Category>>

    // --- NEW: Channel for sending one-time events (like Toasts/Snackbars) to the UI ---
    private val _uiEvent = Channel<String>()
    val uiEvent = _uiEvent.receiveAsFlow()

    init {
        val db = AppDatabase.getInstance(application)
        categoryRepository = CategoryRepository(db.categoryDao())
        // Initialize the new repository
        transactionRepository = TransactionRepository(db.transactionDao())
        allCategories = categoryRepository.allCategories
    }

    // A helper to get a single category by ID, not as a flow.
    suspend fun getCategoryById(id: Int): Category? {
        // We take the first emission from the flow, which is the current state.
        return allCategories.firstOrNull()?.find { it.id == id }
    }

    fun addCategory(name: String) = viewModelScope.launch {
        categoryRepository.insert(Category(name = name))
    }

    fun updateCategory(category: Category) = viewModelScope.launch {
        categoryRepository.update(category)
    }

    // --- UPDATED: Delete function now includes validation logic ---
    fun deleteCategory(category: Category) = viewModelScope.launch {
        // Check if the category is in use before deleting.
        val transactionCount = transactionRepository.countTransactionsForCategory(category.id)
        if (transactionCount == 0) {
            categoryRepository.delete(category)
            _uiEvent.send("Category '${category.name}' deleted.")
        } else {
            // Send an event to the UI explaining why deletion failed.
            _uiEvent.send("Cannot delete '${category.name}'. It's used by $transactionCount transaction(s).")
        }
    }
}
-e 


================== FILE: ./app/src/main/java/CategorySpending.kt ==================
package com.example.personalfinanceapp

/**
 * A simple data class to hold the results of a GROUP BY query,
 * containing the name of a category and the total amount spent in it.
 */
data class CategorySpending(
    val categoryName: String,
    val totalAmount: Double
)
-e 


================== FILE: ./app/src/main/java/Category.kt ==================
package com.example.personalfinanceapp

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.Index
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

@Serializable
@Entity(
    tableName = "categories",
    // Ensure that no two categories can have the same name.
    indices = [Index(value = ["name"], unique = true)]
)
data class Category(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,

    @ColumnInfo(name = "name")
    val name: String
)-e 


================== FILE: ./app/src/main/java/ReminderManager.kt ==================
package com.example.personalfinanceapp

import android.content.Context
import androidx.work.*
import java.util.concurrent.TimeUnit

object ReminderManager {

    private const val REMINDER_WORK_TAG = "daily_review_reminder_work"

    fun scheduleDailyReminder(context: Context) {
        val constraints = Constraints.Builder()
            .setRequiresDeviceIdle(true) // More battery friendly
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .build()

        val reminderRequest = PeriodicWorkRequestBuilder<ReviewReminderWorker>(1, TimeUnit.DAYS)
            .setConstraints(constraints)
            .build()

        WorkManager.getInstance(context).enqueueUniquePeriodicWork(
            REMINDER_WORK_TAG,
            ExistingPeriodicWorkPolicy.KEEP, // Keep the existing work if it's already scheduled
            reminderRequest
        )
    }

    fun cancelDailyReminder(context: Context) {
        WorkManager.getInstance(context).cancelUniqueWork(REMINDER_WORK_TAG)
    }
}
-e 


================== FILE: ./app/src/main/java/RecurringTransactionRepository.kt ==================
package com.example.personalfinanceapp

import kotlinx.coroutines.flow.Flow

class RecurringTransactionRepository(private val recurringTransactionDao: RecurringTransactionDao) {

    fun getAll(): Flow<List<RecurringTransaction>> {
        return recurringTransactionDao.getAll()
    }

    suspend fun insert(recurringTransaction: RecurringTransaction) {
        recurringTransactionDao.insert(recurringTransaction)
    }
}
-e 


================== FILE: ./app/src/main/java/MonthlySummary.kt ==================
package com.example.personalfinanceapp

/**
 * A data class to hold the results of a GROUP BY query for monthly summaries.
 */
data class MonthlySummary(
    val year: Int,
    val month: Int,
    val totalAmount: Double
)
-e 


================== FILE: ./app/src/main/java/CategoryRepository.kt ==================
package com.example.personalfinanceapp

import kotlinx.coroutines.flow.Flow

/**
 * Repository that abstracts access to the category data source.
 */
class CategoryRepository(private val categoryDao: CategoryDao) {

    /**
     * Retrieves all categories from the category table, ordered by name.
     */
    val allCategories: Flow<List<Category>> = categoryDao.getAllCategories()

    /**
     * Inserts a category in a non-blocking way.
     */
    suspend fun insert(category: Category) {
        categoryDao.insert(category)
    }

    /**
     * Updates a category in a non-blocking way.
     */
    suspend fun update(category: Category) {
        categoryDao.update(category)
    }

    /**
     * Deletes a category in a non-blocking way.
     */
    suspend fun delete(category: Category) {
        categoryDao.delete(category)
    }
}
-e 


================== FILE: ./app/src/main/java/MerchantMappingDao.kt ==================
package com.example.personalfinanceapp

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import kotlinx.coroutines.flow.Flow

@Dao
interface MerchantMappingDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(mapping: MerchantMapping)

    // --- NEW: Function to insert a list of mappings during import ---
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(mappings: List<MerchantMapping>)

    // --- NEW: Function to clear the table during import ---
    @Query("DELETE FROM merchant_mappings")
    suspend fun deleteAll()

    @Query("SELECT * FROM merchant_mappings")
    fun getAllMappings(): Flow<List<MerchantMapping>>

    @Query("SELECT * FROM merchant_mappings WHERE smsSender = :sender")
    suspend fun getMappingForSender(sender: String): MerchantMapping?
}
-e 


================== FILE: ./app/src/main/java/MerchantMappingRepository.kt ==================
package com.example.personalfinanceapp

import kotlinx.coroutines.flow.Flow

/**
 * Repository that abstracts access to the MerchantMapping data source.
 */
class MerchantMappingRepository(private val merchantMappingDao: MerchantMappingDao) {

    /**
     * Retrieves all user-defined merchant mappings from the database.
     */
    val allMappings: Flow<List<MerchantMapping>> = merchantMappingDao.getAllMappings()

    /**
     * Inserts a new or updated mapping into the database.
     */
    suspend fun insert(mapping: MerchantMapping) {
        merchantMappingDao.insert(mapping)
    }

    /**
     * Gets a specific mapping for a given SMS sender address.
     */
    suspend fun getMappingForSender(sender: String): MerchantMapping? {
        return merchantMappingDao.getMappingForSender(sender)
    }
}
-e 


================== FILE: ./app/src/main/java/LoginRequest.kt ==================
package com.example.personalfinanceapp

data class LoginRequest(
    val email: String,
    val password: String
)-e 


================== FILE: ./app/src/main/java/SmsRepository.kt ==================
package com.example.personalfinanceapp

import android.content.Context
import android.provider.Telephony
import android.util.Log

/**
 * A repository class dedicated to handling data operations related to SMS messages.
 * This abstracts the logic of querying the Android ContentResolver away from ViewModels or Workers.
 */
class SmsRepository(private val context: Context) {

    /**
     * Fetches all SMS messages from the device's inbox.
     * @return A list of SmsMessage objects.
     */
    fun fetchAllSms(): List<SmsMessage> {
        val smsList = mutableListOf<SmsMessage>()
        // Define the columns we want to retrieve
        val projection = arrayOf(
            Telephony.Sms._ID,
            Telephony.Sms.ADDRESS,
            Telephony.Sms.BODY,
            Telephony.Sms.DATE
        )

        // Query the SMS inbox, sorting by date in descending order
        val cursor = context.contentResolver.query(
            Telephony.Sms.Inbox.CONTENT_URI,
            projection,
            null,
            null,
            "date DESC"
        )

        cursor?.use {
            // Get column indices once for efficiency
            val idIndex = it.getColumnIndexOrThrow(Telephony.Sms._ID)
            val addressIndex = it.getColumnIndexOrThrow(Telephony.Sms.ADDRESS)
            val bodyIndex = it.getColumnIndexOrThrow(Telephony.Sms.BODY)
            val dateIndex = it.getColumnIndexOrThrow(Telephony.Sms.DATE)

            while (it.moveToNext()) {
                smsList.add(
                    SmsMessage(
                        id = it.getLong(idIndex),
                        sender = it.getString(addressIndex) ?: "Unknown",
                        body = it.getString(bodyIndex) ?: "",
                        date = it.getLong(dateIndex)
                    )
                )
            }
        }
        return smsList
    }
}
-e 


================== FILE: ./app/src/main/java/BudgetViewModel.kt ==================
package com.example.personalfinanceapp

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Locale

class BudgetViewModel(application: Application) : AndroidViewModel(application) {

    private val budgetRepository: BudgetRepository
    private val calendar: Calendar = Calendar.getInstance()
    private val currentMonth: Int
    private val currentYear: Int

    val budgetsForCurrentMonth: Flow<List<Budget>>

    init {
        val db = AppDatabase.getInstance(application)
        val budgetDao = db.budgetDao()
        budgetRepository = BudgetRepository(budgetDao)

        currentMonth = calendar.get(Calendar.MONTH) + 1 // Month is 0-based, so add 1
        currentYear = calendar.get(Calendar.YEAR)

        budgetsForCurrentMonth = budgetRepository.getBudgetsForMonth(currentMonth, currentYear)
    }

    /**
     * Gets the actual spending for a given budget category for the current month.
     * This now uses the more efficient repository method.
     */
    fun getActualSpending(categoryName: String): Flow<Double> {
        return budgetRepository.getActualSpendingForCategory(categoryName, currentMonth, currentYear)
            .map { spending -> spending ?: 0.0 } // Ensure we don't return null
    }

    fun addBudget(categoryName: String, amountStr: String) {
        val amount = amountStr.toDoubleOrNull() ?: return
        if (amount <= 0 || categoryName.isBlank()) {
            return // Add error handling here in a real app
        }

        val newBudget = Budget(
            categoryName = categoryName,
            amount = amount,
            month = currentMonth,
            year = currentYear
        )
        viewModelScope.launch {
            budgetRepository.insert(newBudget)
        }
    }

    fun getCurrentMonthYearString(): String {
        return SimpleDateFormat("MMMM yyyy", Locale.getDefault()).format(calendar.time)
    }
}
-e 


================== FILE: ./app/src/main/java/AppDatabase.kt ==================
package com.example.personalfinanceapp

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import java.util.Calendar

@Database(
    entities = [
        Transaction::class,
        Account::class,
        Category::class,
        Budget::class,
        MerchantMapping::class,
        RecurringTransaction::class
    ],
    version = 5,
    exportSchema = true
)
abstract class AppDatabase : RoomDatabase() {

    abstract fun transactionDao(): TransactionDao
    abstract fun accountDao(): AccountDao
    abstract fun categoryDao(): CategoryDao
    abstract fun budgetDao(): BudgetDao
    abstract fun merchantMappingDao(): MerchantMappingDao
    abstract fun recurringTransactionDao(): RecurringTransactionDao

    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null

        // --- Migration from 1 to 2: Add transactionType column ---
        val MIGRATION_1_2 = object : Migration(1, 2) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE transactions ADD COLUMN transactionType TEXT NOT NULL DEFAULT 'expense'")
                db.execSQL("UPDATE transactions SET transactionType = 'income' WHERE amount > 0")
                db.execSQL("UPDATE transactions SET amount = ABS(amount)")
            }
        }

        // --- Migration from 2 to 3: Add merchant_mappings table ---
        val MIGRATION_2_3 = object : Migration(2, 3) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("""
                    CREATE TABLE IF NOT EXISTS `merchant_mappings` (
                        `smsSender` TEXT NOT NULL, 
                        `merchantName` TEXT NOT NULL, 
                        PRIMARY KEY(`smsSender`)
                    )
                """.trimIndent())
            }
        }

        // --- Migration from 3 to 4: Add sourceSmsId column ---
        val MIGRATION_3_4 = object : Migration(3, 4) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE transactions ADD COLUMN sourceSmsId INTEGER")
            }
        }

        // --- Migration from 4 to 5: Add recurring_transactions table ---
        val MIGRATION_4_5 = object : Migration(4, 5) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("""
                    CREATE TABLE IF NOT EXISTS `recurring_transactions` (
                        `id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, 
                        `description` TEXT NOT NULL, 
                        `amount` REAL NOT NULL, 
                        `transactionType` TEXT NOT NULL, 
                        `recurrenceInterval` TEXT NOT NULL, 
                        `startDate` INTEGER NOT NULL, 
                        `accountId` INTEGER NOT NULL, 
                        `categoryId` INTEGER, 
                        FOREIGN KEY(`accountId`) REFERENCES `accounts`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE, 
                        FOREIGN KEY(`categoryId`) REFERENCES `categories`(`id`) ON UPDATE NO ACTION ON DELETE SET NULL
                    )
                """.trimIndent())
                db.execSQL("CREATE INDEX IF NOT EXISTS `index_recurring_transactions_accountId` ON `recurring_transactions` (`accountId`)")
                db.execSQL("CREATE INDEX IF NOT EXISTS `index_recurring_transactions_categoryId` ON `recurring_transactions` (`categoryId`)")
            }
        }

        fun getInstance(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "finance_database"
                )
                    .addMigrations(MIGRATION_1_2, MIGRATION_2_3, MIGRATION_3_4, MIGRATION_4_5)
                    .addCallback(DatabaseCallback(context))
                    .build()
                INSTANCE = instance
                instance
            }
        }

        private class DatabaseCallback(private val context: Context) : RoomDatabase.Callback() {
            override fun onCreate(db: SupportSQLiteDatabase) {
                super.onCreate(db)
                CoroutineScope(Dispatchers.IO).launch {
                    populateDatabase(getInstance(context))
                }
            }

            suspend fun populateDatabase(db: AppDatabase) {
                val accountDao = db.accountDao()
                val categoryDao = db.categoryDao()
                val transactionDao = db.transactionDao()
                // --- NEW: Get Budget DAO ---
                val budgetDao = db.budgetDao()

                // Clear out any existing data
                transactionDao.deleteAll()
                budgetDao.deleteAll() // Assuming you add this
                categoryDao.deleteAll()
                accountDao.deleteAll()

                // --- 1. Populate Accounts ---
                accountDao.insertAll(listOf(
                    Account(id = 1, name = "SBI", type = "Savings"),
                    Account(id = 2, name = "HDFC", type = "Credit Card"),
                    Account(id = 3, name = "ICICI", type = "Savings")
                ))

                // --- 2. Populate Categories ---
                categoryDao.insertAll(listOf(
                    Category(id = 1, name = "Salary"),
                    Category(id = 2, name = "Groceries"),
                    Category(id = 3, name = "Rent"),
                    Category(id = 4, name = "Food"),
                    Category(id = 5, name = "Transportation"),
                    Category(id = 6, name = "Utilities")
                ))

                // --- 3. Populate Transactions (with corrected dates) ---
                val calendar = Calendar.getInstance()

                // Set to the start of the current month for an income transaction
                calendar.set(Calendar.DAY_OF_MONTH, 5)
                val incomeDate = calendar.timeInMillis

                // Set to a few days ago within the current month for expenses
                calendar.set(Calendar.DAY_OF_MONTH, 10)
                val expenseDate1 = calendar.timeInMillis

                calendar.set(Calendar.DAY_OF_MONTH, 15)
                val expenseDate2 = calendar.timeInMillis

                transactionDao.insertAll(listOf(
                    Transaction(description = "Monthly Salary", categoryId = 1, amount = 75000.0, date = incomeDate, accountId = 1, notes = "Paycheck", transactionType = "income"),
                    Transaction(description = "Grocery Shopping", categoryId = 2, amount = 4500.0, date = expenseDate1, accountId = 2, notes = "Weekly groceries", transactionType = "expense"),
                    Transaction(description = "Dinner with friends", categoryId = 4, amount = 1200.0, date = expenseDate2, accountId = 2, notes = null, transactionType = "expense"),
                    // A transaction from last month to test reports
                    Transaction(description = "Apartment Rent", categoryId = 3, amount = 25000.0, date = Calendar.getInstance().apply { add(Calendar.MONTH, -1) }.timeInMillis, accountId = 1, notes = "Monthly rent payment", transactionType = "expense"),
                    Transaction(description = "Bus", categoryId = 5, amount = 150.0, date = Calendar.getInstance().apply{ add(Calendar.DAY_OF_MONTH, -2)}.timeInMillis, accountId = 1, notes = "Travel", transactionType = "expense"),
                    Transaction(description = "Electricity Bill", categoryId = 6, amount = 850.0, date = Calendar.getInstance().apply{ add(Calendar.DAY_OF_MONTH, -1)}.timeInMillis, accountId = 3, notes = "Power bill", transactionType = "expense")
                ))

                // --- 4. Populate Budgets for the current month ---
                val month = calendar.get(Calendar.MONTH) + 1 // Calendar.MONTH is 0-based
                val year = calendar.get(Calendar.YEAR)

                budgetDao.insertAll(listOf(
                    Budget(categoryName = "Groceries", amount = 10000.0, month = month, year = year),
                    Budget(categoryName = "Food", amount = 5000.0, month = month, year = year),
                    Budget(categoryName = "Utilities", amount = 2000.0, month = month, year = year)
                ))
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/SmsParser.kt ==================
package com.example.personalfinanceapp

object SmsParser {

    private val AMOUNT_REGEX = "(?:rs|inr|rs\\.?)\\s*([\\d,]+\\.?\\d*)".toRegex(RegexOption.IGNORE_CASE)
    private val EXPENSE_KEYWORDS_REGEX = "\\b(spent|debited|paid|charged|payment of|purchase of)\\b".toRegex(RegexOption.IGNORE_CASE)
    private val INCOME_KEYWORDS_REGEX = "\\b(credited|received|deposited|refund of)\\b".toRegex(RegexOption.IGNORE_CASE)

    // --- UPDATED: More robust and better-prioritized list of patterns ---
    private val MERCHANT_REGEX_PATTERNS = listOf(
        // Priority 1: Look for income transactions from a sender.
        "(?:credited|received).*from\\s+([A-Za-z0-9\\s.&'-]+?)(?:\\.|$)".toRegex(RegexOption.IGNORE_CASE),
        // Priority 2: Specific HDFC pattern "at ..MERCHANT.. on" - made greedy to capture full name.
        "at\\s*\\.\\.\\s*([A-Za-z0-9_\\s]+)\\s*on".toRegex(RegexOption.IGNORE_CASE),
        // Priority 3: Specific pattern for "DAKSHIN CAFE credited"
        ";\\s*([A-Za-z0-9\\s.&'-]+?)\\s*credited".toRegex(RegexOption.IGNORE_CASE),
        // Priority 4: UPI transactions
        "UPI.*(?:to|\\bat\\b)\\s+([A-Za-z0-9\\s.&'()]+?)(?:\\s+on|\\s+Ref|$)".toRegex(RegexOption.IGNORE_CASE),
        // Priority 5: Virtual Payment Address (VPA)
        "to\\s+([a-zA-Z0-9.\\-_]+@[a-zA-Z0-9]+)".toRegex(RegexOption.IGNORE_CASE),
        // Priority 6: Generic "at" or "to" a merchant
        "(?:\\bat\\b|to\\s+)([A-Za-z0-9\\s.&'-]+?)(?:\\s+on\\s+|\\s+for\\s+|\\.|$|\\s+was\\s+)".toRegex(RegexOption.IGNORE_CASE),
        // Priority 7: Merchant name after "Info:"
        "Info:\\s*([A-Za-z0-9\\s.&'-]+)".toRegex(RegexOption.IGNORE_CASE)
    )

    fun parse(sms: SmsMessage, mappings: Map<String, String>): PotentialTransaction? {
        val messageBody = sms.body

        val amountMatch = AMOUNT_REGEX.find(messageBody)
        val amount = amountMatch?.groups?.get(1)?.value?.replace(",", "")?.toDoubleOrNull()
            ?: return null

        val transactionType = when {
            EXPENSE_KEYWORDS_REGEX.containsMatchIn(messageBody) -> "expense"
            INCOME_KEYWORDS_REGEX.containsMatchIn(messageBody) -> "income"
            else -> return null
        }

        var merchantName = mappings[sms.sender]

        if (merchantName == null) {
            for (pattern in MERCHANT_REGEX_PATTERNS) {
                val match = pattern.find(messageBody)
                if (match != null) {
                    // --- CORRECTED: Added a final .trim() to remove trailing spaces ---
                    val potentialName = match.groups[1]?.value?.replace("_", " ")?.replace(Regex("\\s+"), " ")?.trim()
                    if (!potentialName.isNullOrBlank() && !potentialName.contains("call", ignoreCase = true) && !potentialName.matches(Regex(".*\\d{6,}.*"))) {
                        merchantName = potentialName
                        break
                    }
                }
            }
        }

        return PotentialTransaction(
            sourceSmsId = sms.id,
            smsSender = sms.sender,
            amount = amount,
            transactionType = transactionType,
            merchantName = merchantName,
            originalMessage = messageBody
        )
    }
}
-e 


================== FILE: ./app/src/main/java/AppDataBackup.kt ==================
package com.example.personalfinanceapp

import kotlinx.serialization.Serializable

/**
 * A top-level container for all application data to be exported.
 * This class is designed to be easily converted to a single JSON object.
 */
@Serializable
data class AppDataBackup(
    val transactions: List<Transaction>,
    val accounts: List<Account>,
    val categories: List<Category>,
    val budgets: List<Budget>,
    val merchantMappings: List<MerchantMapping>
)
-e 


================== FILE: ./app/src/main/java/SettingsRepository.kt ==================
package com.example.personalfinanceapp

import android.content.Context
import android.content.SharedPreferences
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import java.util.Calendar

/**
 * A repository for managing simple key-value settings using SharedPreferences.
 * This is ideal for user preferences or data that doesn't need a full database table.
 *
 * @param context The application context, required to access SharedPreferences.
 */
class SettingsRepository(context: Context) {

    private val prefs: SharedPreferences =
        context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE)

    companion object {
        private const val PREF_NAME = "finance_app_settings"
        private const val KEY_BUDGET_PREFIX = "overall_budget_"
        private const val KEY_APP_LOCK_ENABLED = "app_lock_enabled"
        private const val KEY_WEEKLY_SUMMARY_ENABLED = "weekly_summary_enabled"
        private const val KEY_UNKNOWN_TRANSACTION_POPUP_ENABLED = "unknown_transaction_popup_enabled"
    }

    /**
     * Generates a unique key for the overall budget for a specific month and year.
     * Example: "overall_budget_2024_06" for June 2024.
     */
    private fun getBudgetKey(year: Int, month: Int): String {
        // Using String.format to ensure month is zero-padded (e.g., 01, 02, ... 12)
        return String.format("%s%d_%02d", KEY_BUDGET_PREFIX, year, month)
    }

    /**
     * Saves the overall budget amount for the current month.
     *
     * @param amount The budget amount to save.
     */
    fun saveOverallBudgetForCurrentMonth(amount: Float) {
        val calendar = Calendar.getInstance()
        val year = calendar.get(Calendar.YEAR)
        val month = calendar.get(Calendar.MONTH) + 1 // Month is 0-based
        val key = getBudgetKey(year, month)

        // Use the 'edit' KTX extension function for a concise transaction.
        prefs.edit().putFloat(key, amount).apply()
    }

    /**
     * Retrieves the overall budget for the current month as a Flow.
     * This Flow will automatically emit a new value whenever the budget is updated.
     *
     * @return A Flow that emits the budget amount (Float). Defaults to 0f if not set.
     */

    fun saveAppLockEnabled(isEnabled: Boolean) {
        prefs.edit().putBoolean(KEY_APP_LOCK_ENABLED, isEnabled).apply()
    }

    // --- NEW: Flow to read the app lock preference ---
    fun getAppLockEnabled(): Flow<Boolean> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sharedPreferences, changedKey ->
                if (changedKey == KEY_APP_LOCK_ENABLED) {
                    trySend(sharedPreferences.getBoolean(KEY_APP_LOCK_ENABLED, false))
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(prefs.getBoolean(KEY_APP_LOCK_ENABLED, false))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }
    fun isAppLockEnabledBlocking(): Boolean {
        return prefs.getBoolean(KEY_APP_LOCK_ENABLED, false)
    }

    fun getOverallBudgetForCurrentMonth(): Flow<Float> {
        val calendar = Calendar.getInstance()
        val year = calendar.get(Calendar.YEAR)
        val month = calendar.get(Calendar.MONTH) + 1
        val key = getBudgetKey(year, month)

        // callbackFlow is used to convert a callback-based API (like OnSharedPreferenceChangeListener)
        // into a modern Flow, so the UI can react to changes.
        return callbackFlow {
            // 1. Create a listener to watch for changes in SharedPreferences.
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sharedPreferences, changedKey ->
                if (changedKey == key) {
                    // If our specific budget key changed, emit the new value.
                    trySend(sharedPreferences.getFloat(key, 0f))
                }
            }

            // 2. Register the listener.
            prefs.registerOnSharedPreferenceChangeListener(listener)

            // 3. Emit the initial value when the Flow is first collected.
            trySend(prefs.getFloat(key, 0f))

            // 4. Unregister the listener when the Flow is cancelled to prevent memory leaks.
            awaitClose {
                prefs.unregisterOnSharedPreferenceChangeListener(listener)
            }
        }
    }
    fun saveWeeklySummaryEnabled(isEnabled: Boolean) {
        prefs.edit().putBoolean(KEY_WEEKLY_SUMMARY_ENABLED, isEnabled).apply()
    }
    fun getWeeklySummaryEnabled(): Flow<Boolean> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { _, key ->
                if (key == KEY_WEEKLY_SUMMARY_ENABLED) { trySend(prefs.getBoolean(key, true)) } // Default to true
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(prefs.getBoolean(KEY_WEEKLY_SUMMARY_ENABLED, true))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }

    // --- NEW: Functions for Unknown Transaction Popup ---
    fun saveUnknownTransactionPopupEnabled(isEnabled: Boolean) {
        prefs.edit().putBoolean(KEY_UNKNOWN_TRANSACTION_POPUP_ENABLED, isEnabled).apply()
    }
    fun getUnknownTransactionPopupEnabled(): Flow<Boolean> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { _, key ->
                if (key == KEY_UNKNOWN_TRANSACTION_POPUP_ENABLED) { trySend(prefs.getBoolean(key, true)) } // Default to true
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(prefs.getBoolean(KEY_UNKNOWN_TRANSACTION_POPUP_ENABLED, true))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }
}-e 


================== FILE: ./app/src/main/java/SearchViewModelFactory.kt ==================
package com.example.personalfinanceapp

import android.app.Application
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider

class SearchViewModelFactory(private val application: Application) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(SearchViewModel::class.java)) {
            val database = AppDatabase.getInstance(application)
            @Suppress("UNCHECKED_CAST")
            return SearchViewModel(
                transactionDao = database.transactionDao(),
                accountDao = database.accountDao(),
                categoryDao = database.categoryDao()
            ) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
-e 


================== FILE: ./app/src/main/java/ReportsViewModel.kt ==================
package com.example.personalfinanceapp

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import com.github.mikephil.charting.data.*
import com.github.mikephil.charting.utils.ColorTemplate
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Locale
import java.util.Date

class ReportsViewModel(application: Application) : AndroidViewModel(application) {

    private val transactionRepository: TransactionRepository

    // Data for Pie Chart
    val spendingByCategoryPieData: Flow<PieData>
    val monthYear: String

    // Data for Bar Chart, returns the data and the labels for the X-axis
    val monthlyTrendData: Flow<Pair<BarData, List<String>>>

    init {
        val db = AppDatabase.getInstance(application)
        transactionRepository = TransactionRepository(db.transactionDao())

        val calendar = Calendar.getInstance()
        monthYear = SimpleDateFormat("MMMM yyyy", Locale.getDefault()).format(calendar.time)

        // Date logic for current month's pie chart
        val monthStart = Calendar.getInstance().apply { set(Calendar.DAY_OF_MONTH, 1); set(Calendar.HOUR_OF_DAY, 0); set(Calendar.MINUTE, 0); set(Calendar.SECOND, 0) }.timeInMillis
        val monthEnd = Calendar.getInstance().apply { add(Calendar.MONTH, 1); set(Calendar.DAY_OF_MONTH, 1); add(Calendar.DAY_OF_MONTH, -1); set(Calendar.HOUR_OF_DAY, 23); set(Calendar.MINUTE, 59) }.timeInMillis

        spendingByCategoryPieData = transactionRepository.getSpendingByCategoryForMonth(monthStart, monthEnd)
            .map { spendingList ->
                // UPDATED: No longer need Math.abs() as amounts are positive.
                val entries = spendingList.map { PieEntry(it.totalAmount.toFloat(), it.categoryName) }
                val dataSet = PieDataSet(entries, "Spending by Category").apply {
                    colors = ColorTemplate.MATERIAL_COLORS.toList()
                    valueTextSize = 12f
                }
                PieData(dataSet)
            }

        // Date logic for last 6 months' bar chart
        val sixMonthsAgo = Calendar.getInstance().apply { add(Calendar.MONTH, -6) }.timeInMillis
        monthlyTrendData = transactionRepository.getMonthlyTrends(sixMonthsAgo)
            .map { trends ->
                val incomeEntries = ArrayList<BarEntry>()
                val expenseEntries = ArrayList<BarEntry>()
                val labels = ArrayList<String>()

                trends.forEachIndexed { index, trend ->
                    incomeEntries.add(BarEntry(index.toFloat(), trend.totalIncome.toFloat()))
                    // UPDATED: No longer need Math.abs() for expenses.
                    expenseEntries.add(BarEntry(index.toFloat(), trend.totalExpenses.toFloat()))
                    val date = SimpleDateFormat("yyyy-MM", Locale.getDefault()).parse(trend.monthYear)
                    labels.add(SimpleDateFormat("MMM", Locale.getDefault()).format(date ?: Date()))
                }

                val incomeDataSet = BarDataSet(incomeEntries, "Income").apply { color = ColorTemplate.rgb("#66BB6A") }
                val expenseDataSet = BarDataSet(expenseEntries, "Expense").apply { color = ColorTemplate.rgb("#EF5350") }

                val barData = BarData(incomeDataSet, expenseDataSet)
                Pair(barData, labels)
            }
    }
}
-e 


================== FILE: ./app/src/main/java/SettingsViewModel.kt ==================
package com.example.personalfinanceapp

import android.app.Application
import android.content.Context
import android.content.pm.PackageManager
import android.provider.Telephony
import androidx.core.content.ContextCompat
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

class SettingsViewModel(application: Application) : AndroidViewModel(application) {

    // Correctly initialize repositories based on your project structure
    private val settingsRepository = SettingsRepository(application)
    private val transactionRepository = TransactionRepository(AppDatabase.getInstance(application).transactionDao())
    private val merchantMappingRepository = MerchantMappingRepository(AppDatabase.getInstance(application).merchantMappingDao())

    // Using a direct value instead of a repository for SMS since it's a one-off read
    private val context = application

    // CORRECTED: Call the right method from your SettingsRepository
    val overallBudget: StateFlow<Float> = settingsRepository.getOverallBudgetForCurrentMonth().stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = 0f
    )

    // CORRECTED: Call the new method from your SettingsRepository
    val dailyReminderEnabled: StateFlow<Boolean> = settingsRepository.getDailyReminderEnabled().stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = false
    )

    private val _potentialTransactions = MutableStateFlow<List<PotentialTransaction>>(emptyList())
    val potentialTransactions: StateFlow<List<PotentialTransaction>> = _potentialTransactions.asStateFlow()

    private val _isScanning = MutableStateFlow(false)
    val isScanning: StateFlow<Boolean> = _isScanning.asStateFlow()

    private val _smsMessages = MutableStateFlow<List<SmsMessage>>(emptyList())
    val smsMessages: StateFlow<List<SmsMessage>> = _smsMessages.asStateFlow()

    // CORRECTED: Use the correct save method name
    fun saveOverallBudget(budget: String) {
        val budgetFloat = budget.toFloatOrNull() ?: 0f
        settingsRepository.saveOverallBudgetForCurrentMonth(budgetFloat)
    }

    // CORRECTED: This now correctly calls the repository and manager
    fun setDailyReminder(enabled: Boolean) {
        settingsRepository.saveDailyReminderEnabled(enabled)
        if (enabled) {
            ReminderManager.scheduleDailyReminder(context)
        } else {
            ReminderManager.cancelDailyReminder(context)
        }
    }

    fun rescanAllSmsMessages() {
        if (ContextCompat.checkSelfPermission(context, android.Manifest.permission.READ_SMS) != PackageManager.PERMISSION_GRANTED) {
            return
        }

        viewModelScope.launch {
            _isScanning.value = true
            val existingMappings = withContext(Dispatchers.IO) {
                merchantMappingRepository.allMappings.first().associateBy({ it.smsSender }, { it.merchantName })
            }
            val existingSmsIds = withContext(Dispatchers.IO) {
                transactionRepository.allTransactions.first().mapNotNull { it.transaction.sourceSmsId }.toSet()
            }

            val rawMessages = withContext(Dispatchers.IO) {
                val messageList = mutableListOf<SmsMessage>()
                val projection = arrayOf(Telephony.Sms._ID, Telephony.Sms.ADDRESS, Telephony.Sms.BODY, Telephony.Sms.DATE)
                val cursor = context.contentResolver.query(
                    Telephony.Sms.Inbox.CONTENT_URI, projection, null, null, null
                )
                cursor?.use { c ->
                    val idIndex = c.getColumnIndexOrThrow(Telephony.Sms._ID)
                    val addressIndex = c.getColumnIndexOrThrow(Telephony.Sms.ADDRESS)
                    val bodyIndex = c.getColumnIndexOrThrow(Telephony.Sms.BODY)
                    val dateIndex = c.getColumnIndexOrThrow(Telephony.Sms.DATE)
                    while (c.moveToNext()) {
                        messageList.add(SmsMessage(id = c.getLong(idIndex), sender = c.getString(addressIndex), body = c.getString(bodyIndex), date = c.getLong(dateIndex)))
                    }
                }
                messageList
            }
            _smsMessages.value = rawMessages

            val parsedList = withContext(Dispatchers.Default) {
                rawMessages.mapNotNull { SmsParser.parse(it, existingMappings) }
            }

            _potentialTransactions.value = parsedList.filter { potential ->
                !existingSmsIds.contains(potential.sourceSmsId)
            }
            _isScanning.value = false
        }
    }

    fun dismissPotentialTransaction(transaction: PotentialTransaction) {
        _potentialTransactions.value = _potentialTransactions.value.filter { it != transaction }
    }

    fun saveMerchantMapping(sender: String, merchantName: String) {
        viewModelScope.launch {
            merchantMappingRepository.insert(MerchantMapping(smsSender = sender, merchantName = merchantName))
        }
    }
}
-e 


================== FILE: ./app/src/main/java/AccountViewModel.kt ==================
package com.example.personalfinanceapp

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch

class AccountViewModel(application: Application) : AndroidViewModel(application) {

    private val repository: AccountRepository
    private val transactionRepository: TransactionRepository

    // This is the data your UI will observe. It now comes directly from the repository.
    val accountsWithBalance: Flow<List<AccountWithBalance>>

    init {
        val db = AppDatabase.getInstance(application)
        repository = AccountRepository(db.accountDao())
        transactionRepository = TransactionRepository(db.transactionDao())

        // --- CORRECTED: Directly use the powerful query from the DAO via the repository ---
        // This is much more efficient than using 'combine' and calculating in the ViewModel.
        accountsWithBalance = repository.accountsWithBalance
    }

    fun getAccountById(accountId: Int): Flow<Account?> = repository.getAccountById(accountId)

    // --- CORRECTED: The balance calculation now correctly uses the transactionType ---
    // Helper function to calculate a single account's balance for the detail view
    fun getAccountBalance(accountId: Int): Flow<Double> {
        // This leverages the existing getTransactionsForAccount and then sums the amounts correctly.
        return transactionRepository.getTransactionsForAccount(accountId).map { transactions ->
            transactions.sumOf { if (it.transactionType == "income") it.amount else -it.amount }
        }
    }

    // Pass through for the detail screen to get full transaction details
    fun getTransactionsForAccount(accountId: Int): Flow<List<TransactionDetails>> {
        // NOTE: You'll need to add getTransactionsForAccountDetails to your TransactionRepository
        // that calls the corresponding DAO method.
        return transactionRepository.getTransactionsForAccountDetails(accountId)
    }

    // --- CORRECTED: The Account object no longer has a 'balance' parameter in its constructor ---
    fun addAccount(name: String, type: String) = viewModelScope.launch {
        if (name.isNotBlank() && type.isNotBlank()) {
            // Create the Account object without a balance.
            repository.insert(Account(name = name, type = type))
        }
    }

    fun updateAccount(account: Account) = viewModelScope.launch {
        repository.update(account)
    }

    fun deleteAccount(account: Account) = viewModelScope.launch {
        repository.delete(account)
    }
}
-e 


================== FILE: ./app/src/main/java/PotentialTransaction.kt ==================
package com.example.personalfinanceapp

/**
 * A data class to hold the structured information extracted from an SMS message.
 * This is a temporary object, created before a full 'Transaction' is saved to the database.
 *
 * @param amount The monetary value of the transaction.
 * @param transactionType The type of transaction, either 'expense' or 'income'.
 * @param merchantName The name of the merchant, if it can be determined.
 * @param originalMessage The original SMS body, for reference and debugging.
 */
data class PotentialTransaction(
    val sourceSmsId: Long,
    val smsSender: String,
    val amount: Double,
    val transactionType: String,
    val merchantName: String?,
    val originalMessage: String
)
-e 


================== FILE: ./app/src/main/java/TransactionDao.kt ==================
package com.example.personalfinanceapp

import androidx.room.*
import kotlinx.coroutines.flow.Flow

@Dao
interface TransactionDao {

    // ... (all your existing DAO methods are here)

    @Query("""
        SELECT
            T.*,
            A.name as accountName,
            C.name as categoryName
        FROM
            transactions AS T
        LEFT JOIN
            accounts AS A ON T.accountId = A.id
        LEFT JOIN
            categories AS C ON T.categoryId = C.id
        ORDER BY
            T.date DESC
    """)
    fun getAllTransactions(): Flow<List<TransactionDetails>>

    @Query("""
        SELECT
            T.*,
            A.name as accountName,
            C.name as categoryName
        FROM
            transactions AS T
        LEFT JOIN
            accounts AS A ON T.accountId = A.id
        LEFT JOIN
            categories AS C ON T.categoryId = C.id
        WHERE T.date BETWEEN :startDate AND :endDate
        ORDER BY
            T.date DESC
    """)
    fun getTransactionDetailsForRange(startDate: Long, endDate: Long): Flow<List<TransactionDetails>>

    // --- NEW: This is the method required by AccountViewModel ---
    @Query("""
        SELECT T.*, A.name as accountName, C.name as categoryName
        FROM transactions AS T
        LEFT JOIN accounts AS A ON T.accountId = A.id
        LEFT JOIN categories AS C ON T.categoryId = C.id
        WHERE T.accountId = :accountId
        ORDER BY T.date DESC
    """)
    fun getTransactionsForAccountDetails(accountId: Int): Flow<List<TransactionDetails>>


    @Query("SELECT * FROM transactions")
    fun getAllTransactionsSimple(): Flow<List<Transaction>>

    @Query("SELECT * FROM transactions WHERE date BETWEEN :startDate AND :endDate ORDER BY date DESC")
    fun getAllTransactionsForRange(startDate: Long, endDate: Long): Flow<List<Transaction>>

    @Query("SELECT * FROM transactions WHERE id = :id")
    fun getTransactionById(id: Int): Flow<Transaction?>

    @Query("SELECT * FROM transactions WHERE accountId = :accountId ORDER BY date DESC")
    fun getTransactionsForAccount(accountId: Int): Flow<List<Transaction>>

    @Query("""
        SELECT SUM(T.amount) FROM transactions AS T
        INNER JOIN categories AS C ON T.categoryId = C.id
        WHERE C.name = :categoryName AND T.date BETWEEN :startDate AND :endDate AND T.transactionType = 'expense'
    """)
    fun getSpendingForCategory(categoryName: String, startDate: Long, endDate: Long): Flow<Double?>

    @Query("""
        SELECT C.name as categoryName, SUM(T.amount) as totalAmount
        FROM transactions AS T
        INNER JOIN categories AS C ON T.categoryId = C.id
        WHERE T.transactionType = 'expense' AND T.date BETWEEN :startDate AND :endDate
        GROUP BY C.name
        ORDER BY totalAmount ASC
    """)
    fun getSpendingByCategoryForMonth(startDate: Long, endDate: Long): Flow<List<CategorySpending>>

    @Query("""
        SELECT
            strftime('%Y-%m', date / 1000, 'unixepoch') as monthYear,
            SUM(CASE WHEN transactionType = 'income' THEN amount ELSE 0 END) as totalIncome,
            SUM(CASE WHEN transactionType = 'expense' THEN amount ELSE 0 END) as totalExpenses
        FROM transactions
        WHERE date >= :startDate
        GROUP BY monthYear
        ORDER BY monthYear ASC
    """)
    fun getMonthlyTrends(startDate: Long): Flow<List<MonthlyTrend>>

    @Query("""
        SELECT t.*, a.name as accountName, c.name as categoryName
        FROM transactions t
        LEFT JOIN accounts a ON t.accountId = a.id
        LEFT JOIN categories c ON t.categoryId = c.id
        WHERE
            (:keyword = '' OR t.description LIKE '%' || :keyword || '%' OR t.notes LIKE '%' || :keyword || '%') AND
            (:accountId IS NULL OR t.accountId = :accountId) AND
            (:categoryId IS NULL OR t.categoryId = :categoryId) AND
            (:transactionType IS NULL OR t.transactionType = :transactionType) AND
            (:startDate IS NULL OR t.date >= :startDate) AND
            (:endDate IS NULL OR t.date <= :endDate)
        ORDER BY t.date DESC
    """)
    suspend fun searchTransactions(
        keyword: String,
        accountId: Int?,
        categoryId: Int?,
        transactionType: String?,
        startDate: Long?,
        endDate: Long?
    ): List<TransactionDetails>


    @Query("SELECT COUNT(*) FROM transactions WHERE categoryId = :categoryId")
    suspend fun countTransactionsForCategory(categoryId: Int): Int

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(transactions: List<Transaction>)

    @Query("DELETE FROM transactions")
    suspend fun deleteAll()

    @Insert
    suspend fun insert(transaction: Transaction)

    @Update
    suspend fun update(transaction: Transaction)

    @Delete
    suspend fun delete(transaction: Transaction)
}
-e 


================== FILE: ./app/src/main/java/RecurringTransactionViewModel.kt ==================
package com.example.personalfinanceapp

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.launch

class RecurringTransactionViewModel(application: Application) : AndroidViewModel(application) {

    private val repository: RecurringTransactionRepository
    val allRecurringTransactions: Flow<List<RecurringTransaction>>

    init {
        val recurringDao = AppDatabase.getInstance(application).recurringTransactionDao()
        repository = RecurringTransactionRepository(recurringDao)
        allRecurringTransactions = repository.getAll()
    }

    fun addRecurringTransaction(
        description: String,
        amount: Double,
        transactionType: String,
        recurrenceInterval: String,
        startDate: Long,
        accountId: Int,
        categoryId: Int?
    ) = viewModelScope.launch {
        val newRule = RecurringTransaction(
            description = description,
            amount = amount,
            transactionType = transactionType,
            recurrenceInterval = recurrenceInterval,
            startDate = startDate,
            accountId = accountId,
            categoryId = categoryId
        )
        repository.insert(newRule)
    }
}
-e 


================== FILE: ./app/src/main/java/CategoryDao.kt ==================
package com.example.personalfinanceapp

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import kotlinx.coroutines.flow.Flow

@Dao
interface CategoryDao {

    @Query("SELECT * FROM categories ORDER BY name ASC")
    fun getAllCategories(): Flow<List<Category>>

    @Query("SELECT * FROM categories WHERE id = :categoryId")
    suspend fun getCategoryById(categoryId: Int): Category?

    // --- NEW: For data seeding ---
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(categories: List<Category>)

    // --- NEW: For data seeding ---
    @Query("DELETE FROM categories")
    suspend fun deleteAll()

    @Insert
    suspend fun insert(category: Category)

    @Update
    suspend fun update(category: Category)

    @Delete
    suspend fun delete(category: Category)
}
-e 


================== FILE: ./app/src/main/java/BudgetDao.kt ==================
package com.example.personalfinanceapp

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import kotlinx.coroutines.flow.Flow

@Dao
interface BudgetDao {

    @Query("SELECT * FROM budgets WHERE month = :month AND year = :year")
    fun getBudgetsForMonth(month: Int, year: Int): Flow<List<Budget>>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(budgets: List<Budget>)

    @Query("DELETE FROM budgets")
    suspend fun deleteAll()

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(budget: Budget)

    // This query is more efficient as it performs the calculation in the database.
    @Query("SELECT SUM(amount) FROM transactions WHERE categoryId = (SELECT id FROM categories WHERE name = :categoryName) AND strftime('%m', date / 1000, 'unixepoch') + 0 = :month AND strftime('%Y', date / 1000, 'unixepoch') + 0 = :year AND transactionType = 'expense'")
    fun getActualSpendingForCategory(categoryName: String, month: Int, year: Int): Flow<Double?>

    @Query("SELECT * FROM budgets")
    fun getAllBudgets(): Flow<List<Budget>>
}
-e 


================== FILE: ./app/src/main/java/AccountDao.kt ==================
package com.example.personalfinanceapp

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Transaction
import androidx.room.Update
import kotlinx.coroutines.flow.Flow

@Dao
interface AccountDao {

    // --- UPDATED: This query now calculates the balance for each account ---
    @Transaction
    @Query("""
        SELECT
            A.*,
            (SELECT IFNULL(SUM(CASE WHEN T.transactionType = 'income' THEN T.amount ELSE -T.amount END), 0.0)
             FROM transactions AS T
             WHERE T.accountId = A.id) as balance
        FROM
            accounts AS A
        ORDER BY
            A.name ASC
    """)
    fun getAccountsWithBalance(): Flow<List<AccountWithBalance>>

    @Query("SELECT * FROM accounts ORDER BY name ASC")
    fun getAllAccounts(): Flow<List<Account>>

    @Query("SELECT * FROM accounts WHERE id = :accountId")
    fun getAccountById(accountId: Int): Flow<Account?>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(accounts: List<Account>)

    @Query("DELETE FROM accounts")
    suspend fun deleteAll()

    @Insert
    suspend fun insert(account: Account)

    @Update
    suspend fun update(account: Account)

    @Delete
    suspend fun delete(account: Account)
}
-e 


================== FILE: ./app/src/main/java/LoginResponse.kt ==================
package com.example.personalfinanceapp

data class LoginResponse(
    val message: String
    // We can add a 'token' field later, e.g., val token: String
)-e 


================== FILE: ./app/src/main/java/BudgetWithSpending.kt ==================
package com.example.personalfinanceapp

import androidx.room.Embedded

data class BudgetWithSpending(
    @Embedded
    val budget: Budget,
    val spent: Double
)-e 


================== FILE: ./app/src/main/java/MainApplication.kt ==================
package com.example.personalfinanceapp

import android.app.Application
import android.app.NotificationChannel
import android.app.NotificationManager
import android.os.Build

class MainApplication : Application() {

    companion object {
        const val TRANSACTION_CHANNEL_ID = "transaction_channel"
        const val REMINDER_CHANNEL_ID = "reminder_channel"
    }

    override fun onCreate() {
        super.onCreate()
        // Create all necessary notification channels on app startup
        createTransactionNotificationChannel()
        createReminderNotificationChannel()
        // The worker is now scheduled via the Settings screen, so we no longer
        // need to call it directly from here.
    }

    private fun createTransactionNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val name = "Transactions"
            val descriptionText = "Notifications for newly detected transactions"
            val importance = NotificationManager.IMPORTANCE_DEFAULT
            val channel = NotificationChannel(TRANSACTION_CHANNEL_ID, name, importance).apply {
                description = descriptionText
            }
            val notificationManager: NotificationManager =
                getSystemService(NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
    }

    private fun createReminderNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val name = "Review Reminders"
            val descriptionText = "Daily reminders to approve pending transactions"
            val importance = NotificationManager.IMPORTANCE_DEFAULT
            val channel = NotificationChannel(REMINDER_CHANNEL_ID, name, importance).apply {
                description = descriptionText
            }
            val notificationManager: NotificationManager =
                getSystemService(NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
    }
}
-e 


================== FILE: ./app/src/main/java/Budget.kt ==================
package com.example.personalfinanceapp

import androidx.room.Entity
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

@Serializable
@Entity(tableName = "budgets")
data class Budget(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val categoryName: String,
    val amount: Double,
    val month: Int, // e.g., 6 for June
    val year: Int   // e.g., 2024
)
-e 


================== FILE: ./app/src/main/java/Transaction.kt ==================
package com.example.personalfinanceapp

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

@Serializable
@Entity(
    tableName = "transactions",
    indices = [
        Index(value = ["categoryId"]),
        Index(value = ["accountId"])
    ],
    foreignKeys = [
        ForeignKey(
            entity = Category::class,
            parentColumns = ["id"],
            childColumns = ["categoryId"],
            onDelete = ForeignKey.SET_NULL
        ),
        ForeignKey(
            entity = Account::class,
            parentColumns = ["id"],
            childColumns = ["accountId"],
            onDelete = ForeignKey.CASCADE
        )
    ]
)
data class Transaction(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val description: String,
    val categoryId: Int?,
    // The amount is now always positive.
    val amount: Double,
    val date: Long,
    val accountId: Int,
    val notes: String?,

    // --- NEW: Added to distinguish between income and expense ---
    val transactionType: String = "expense", // Default to 'expense'
    val sourceSmsId: Long? = null
)
-e 


================== FILE: ./app/src/main/java/SmsReceiver.kt ==================
package com.example.personalfinanceapp

import android.Manifest
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.provider.Telephony
import android.util.Log
import androidx.core.app.ActivityCompat
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch

class SmsReceiver : BroadcastReceiver() {

    private val TAG = "SmsReceiver"

    override fun onReceive(context: Context, intent: Intent) {
        Log.d(TAG, "onReceive triggered for action: ${intent.action}")

        if (intent.action == Telephony.Sms.Intents.SMS_RECEIVED_ACTION) {

            val pendingResult = goAsync()
            CoroutineScope(Dispatchers.IO).launch {
                try {
                    val messages = Telephony.Sms.Intents.getMessagesFromIntent(intent)
                    Log.d(TAG, "Received ${messages.size} message parts.")

                    val db = AppDatabase.getInstance(context)
                    val transactionRepository = TransactionRepository(db.transactionDao())
                    val mappingRepository = MerchantMappingRepository(db.merchantMappingDao())

                    // --- CORRECTED: Use the same de-duplication logic as the manual scan ---
                    // 1. Get existing mappings and already imported SMS IDs from the database
                    val existingMappings = mappingRepository.allMappings.first().associateBy({ it.smsSender }, { it.merchantName })
                    val existingSmsIds = transactionRepository.allTransactions.first()
                        .mapNotNull { transactionDetail ->
                            transactionDetail.transaction.notes?.let { notes ->
                                val match = "sms_id:(\\d+)".toRegex().find(notes)
                                match?.groups?.get(1)?.value?.toLongOrNull()
                            }
                        }.toSet()

                    // 2. Process each incoming message
                    for (sms in messages) {
                        // In modern Android, the intent contains the SMS ID. We need to query for it.
                        // For simplicity in the receiver, we will continue to use timestamp as a proxy for the ID.
                        // A more complex implementation might query the ContentResolver again here.
                        val smsId = sms.timestampMillis
                        val sender = sms.originatingAddress ?: "Unknown"

                        Log.d(TAG, "Processing SMS with approximate ID (timestamp): $smsId from $sender")

                        // NOTE: This de-duplication is not perfect because we don't have the real _ID here.
                        // We check against timestamp, which is a good heuristic.
                        if (!existingSmsIds.contains(smsId)) {
                            val smsMessage = SmsMessage(id = smsId, sender = sender, body = sms.messageBody, date = smsId)
                            val potentialTransaction = SmsParser.parse(smsMessage, existingMappings)

                            if (potentialTransaction != null) {
                                Log.d(TAG, "New potential transaction found: $potentialTransaction")
                                if (ActivityCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) == PackageManager.PERMISSION_GRANTED) {
                                    NotificationHelper.showTransactionNotification(context, potentialTransaction)
                                    Log.d(TAG, "Notification sent for transaction.")
                                } else {
                                    Log.w(TAG, "Post Notifications permission not granted.")
                                }
                            } else {
                                Log.d(TAG, "SMS did not parse to a transaction.")
                            }
                        } else {
                            Log.d(TAG, "SMS with ID: $smsId appears to be a duplicate. Skipping.")
                        }
                    }
                } catch(e: Exception) {
                    Log.e(TAG, "Error processing SMS", e)
                }
                finally {
                    pendingResult.finish()
                    Log.d(TAG, "Pending result finished.")
                }
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/NotificationHelper.kt ==================
package com.example.personalfinanceapp

import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.net.toUri

object NotificationHelper {

    private const val DEEP_LINK_URI = "app://personalfinanceapp.example.com"

    fun showTransactionNotification(
        context: Context,
        potentialTransaction: PotentialTransaction
    ) {
        // Create the deep link URI with the transaction details as query parameters
        val approveUri = (
                "$DEEP_LINK_URI/approve?amount=${potentialTransaction.amount}" +
                        "&type=${potentialTransaction.transactionType}" +
                        "&merchant=${potentialTransaction.merchantName ?: "Unknown"}" +
                        "&smsId=${potentialTransaction.sourceSmsId}" +
                        "&smsSender=${potentialTransaction.smsSender}"
                ).toUri()

        // Create an explicit intent for the deep link
        val intent = Intent(Intent.ACTION_VIEW, approveUri).apply {
            `package` = context.packageName
        }

        // Create the PendingIntent
        val pendingIntent = PendingIntent.getActivity(
            context,
            potentialTransaction.sourceSmsId.toInt(), // Use SMS ID for a unique request code
            intent,
            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
        )

        // --- CORRECTED: Replaced custom drawable with a built-in Android system icon ---
        // You can later create your own icon and place it in res/drawable,
        // then change this back to R.drawable.your_icon_name
        val notificationIcon = android.R.drawable.ic_dialog_info

        val builder = NotificationCompat.Builder(context, MainApplication.TRANSACTION_CHANNEL_ID)
            .setSmallIcon(notificationIcon)
            .setContentTitle("New Transaction Found")
            .setContentText("Tap to review and categorize a transaction from ${potentialTransaction.merchantName ?: "Unknown Sender"}.")
            .setStyle(NotificationCompat.BigTextStyle()
                .bigText("Expense of ${"%.2f".format(potentialTransaction.amount)} from ${potentialTransaction.merchantName ?: "Unknown Sender"} detected. Tap to add this to your transaction history."))
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .addAction(notificationIcon, "Review & Categorize", pendingIntent)

        with(NotificationManagerCompat.from(context)) {
            notify(potentialTransaction.sourceSmsId.toInt(), builder.build())
        }
    }
}
-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/screens/AddRecurringTransactionScreen.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.Button
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.ExposedDropdownMenuBox
import androidx.compose.material3.ExposedDropdownMenuDefaults
import androidx.compose.material3.FilterChip
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.example.personalfinanceapp.Account
import com.example.personalfinanceapp.Category
import com.example.personalfinanceapp.RecurringTransactionViewModel
import com.example.personalfinanceapp.TransactionViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddRecurringTransactionScreen(navController: NavController) {
    val recurringViewModel: RecurringTransactionViewModel = viewModel()
    // CORRECTED: Create the TransactionViewModel the standard way
    val transactionViewModel: TransactionViewModel = viewModel()

    var description by remember { mutableStateOf("") }
    var amount by remember { mutableStateOf("") }
    var transactionType by remember { mutableStateOf("expense") }

    val recurrenceIntervals = listOf("Daily", "Weekly", "Monthly", "Yearly")
    var selectedInterval by remember { mutableStateOf(recurrenceIntervals[2]) }
    var intervalExpanded by remember { mutableStateOf(false) }

    val accounts by transactionViewModel.allAccounts.collectAsState(initial = emptyList())
    var selectedAccount by remember { mutableStateOf<Account?>(null) }
    var accountExpanded by remember { mutableStateOf(false) }

    val categories by transactionViewModel.allCategories.collectAsState(initial = emptyList())
    var selectedCategory by remember { mutableStateOf<Category?>(null) }
    var categoryExpanded by remember { mutableStateOf(false) }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Add Recurring Transaction") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back")
                    }
                }
            )
        }
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier.padding(innerPadding),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item { OutlinedTextField(value = description, onValueChange = { description = it }, label = { Text("Description") }, modifier = Modifier.fillMaxWidth()) }
            item { OutlinedTextField(value = amount, onValueChange = { amount = it }, label = { Text("Amount") }, modifier = Modifier.fillMaxWidth(), keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number)) }

            item {
                Row {
                    FilterChip(selected = transactionType == "expense", onClick = { transactionType = "expense" }, label = { Text("Expense") }, modifier = Modifier.weight(1f))
                    Spacer(Modifier.width(8.dp))
                    FilterChip(selected = transactionType == "income", onClick = { transactionType = "income" }, label = { Text("Income") }, modifier = Modifier.weight(1f))
                }
            }

            item {
                ExposedDropdownMenuBox(expanded = intervalExpanded, onExpandedChange = { intervalExpanded = !intervalExpanded }) {
                    OutlinedTextField(value = selectedInterval, onValueChange = {}, readOnly = true, label = { Text("Repeats") }, trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = intervalExpanded) }, modifier = Modifier.fillMaxWidth().menuAnchor())
                    ExposedDropdownMenu(expanded = intervalExpanded, onDismissRequest = { intervalExpanded = false }) {
                        recurrenceIntervals.forEach { interval -> DropdownMenuItem(text = { Text(interval) }, onClick = { selectedInterval = interval; intervalExpanded = false }) }
                    }
                }
            }

            item {
                ExposedDropdownMenuBox(expanded = accountExpanded, onExpandedChange = { accountExpanded = !accountExpanded }) {
                    OutlinedTextField(value = selectedAccount?.name ?: "Select Account", onValueChange = {}, readOnly = true, label = { Text("Account") }, trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = accountExpanded) }, modifier = Modifier.fillMaxWidth().menuAnchor())
                    ExposedDropdownMenu(expanded = accountExpanded, onDismissRequest = { accountExpanded = false }) {
                        accounts.forEach { account -> DropdownMenuItem(text = { Text(account.name) }, onClick = { selectedAccount = account; accountExpanded = false }) }
                    }
                }
            }

            item {
                ExposedDropdownMenuBox(expanded = categoryExpanded, onExpandedChange = { categoryExpanded = !categoryExpanded }) {
                    OutlinedTextField(value = selectedCategory?.name ?: "Select Category", onValueChange = {}, readOnly = true, label = { Text("Category") }, trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = categoryExpanded) }, modifier = Modifier.fillMaxWidth().menuAnchor())
                    ExposedDropdownMenu(expanded = categoryExpanded, onDismissRequest = { categoryExpanded = false }) {
                        categories.forEach { category -> DropdownMenuItem(text = { Text(category.name) }, onClick = { selectedCategory = category; categoryExpanded = false }) }
                    }
                }
            }

            item {
                Button(
                    onClick = {
                        val amountDouble = amount.toDoubleOrNull()
                        if (amountDouble != null && selectedAccount != null) {
                            recurringViewModel.addRecurringTransaction(
                                description, amountDouble, transactionType, selectedInterval, System.currentTimeMillis(), selectedAccount!!.id, selectedCategory?.id
                            )
                            navController.popBackStack()
                        }
                    },
                    modifier = Modifier.fillMaxWidth(),
                    enabled = description.isNotBlank() && amount.isNotBlank() && selectedAccount != null
                ) {
                    Text("Save Rule")
                }
            }
        }
    }
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/screens/CategoryListScreen.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.Divider
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import com.example.personalfinanceapp.Category
import com.example.personalfinanceapp.CategoryViewModel
import com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components.DeleteCategoryDialog
import com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components.EditCategoryDialog

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CategoryListScreen(navController: NavController, viewModel: CategoryViewModel) {
    val categories by viewModel.allCategories.collectAsState(initial = emptyList())
    var newCategoryName by remember { mutableStateOf("") }

    var showEditDialog by remember { mutableStateOf(false) }
    var showDeleteDialog by remember { mutableStateOf(false) }
    var selectedCategory by remember { mutableStateOf<Category?>(null) }

    val snackbarHostState = remember { SnackbarHostState() }

    LaunchedEffect(key1 = viewModel.uiEvent) {
        viewModel.uiEvent.collect { message ->
            snackbarHostState.showSnackbar(message)
        }
    }

    Scaffold(
        snackbarHost = { SnackbarHost(snackbarHostState) },
        topBar = {
            TopAppBar(
                title = { Text("Manage Categories") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(imageVector = Icons.Filled.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
                .padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                OutlinedTextField(
                    value = newCategoryName,
                    onValueChange = { newCategoryName = it },
                    label = { Text("New Category Name") },
                    modifier = Modifier.weight(1f)
                )
                Button(
                    onClick = {
                        if (newCategoryName.isNotBlank()) {
                            viewModel.addCategory(newCategoryName)
                            newCategoryName = ""
                        }
                    },
                    enabled = newCategoryName.isNotBlank()
                ) {
                    Icon(imageVector = Icons.Default.Add, contentDescription = "Add")
                }
            }

            Spacer(modifier = Modifier.height(16.dp))
            Divider()

            LazyColumn {
                items(categories) { category ->
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(text = category.name, modifier = Modifier.weight(1f))
                        IconButton(onClick = {
                            selectedCategory = category
                            showEditDialog = true
                        }) {
                            Icon(imageVector = Icons.Default.Edit, contentDescription = "Edit Category")
                        }
                        IconButton(onClick = {
                            selectedCategory = category
                            showDeleteDialog = true
                        }) {
                            Icon(imageVector = Icons.Default.Delete, contentDescription = "Delete Category", tint = MaterialTheme.colorScheme.error)
                        }
                    }
                    Divider()
                }
            }
        }
    }

    if (showEditDialog) {
        selectedCategory?.let {
            EditCategoryDialog(
                category = it,
                onDismiss = { showEditDialog = false },
                onConfirm = { updatedCategory ->
                    viewModel.updateCategory(updatedCategory)
                    showEditDialog = false
                }
            )
        }
    }

    if (showDeleteDialog) {
        selectedCategory?.let {
            DeleteCategoryDialog(
                category = it,
                onDismiss = { showDeleteDialog = false },
                onConfirm = {
                    viewModel.deleteCategory(it)
                    showDeleteDialog = false
                }
            )
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EditCategoryScreen(
    navController: NavController,
    viewModel: CategoryViewModel,
    categoryId: Int
) {
    val snackbarHostState = remember { SnackbarHostState() }
    var categoryName by remember { mutableStateOf("") }
    var showDeleteDialog by remember { mutableStateOf(false) }
    var categoryToDelete by remember { mutableStateOf<Category?>(null) }

    LaunchedEffect(key1 = categoryId) {
        val category = viewModel.getCategoryById(categoryId)
        if (category != null) {
            categoryName = category.name
        }
    }

    LaunchedEffect(key1 = viewModel.uiEvent) {
        viewModel.uiEvent.collect { message ->
            snackbarHostState.showSnackbar(message)
        }
    }

    Scaffold(
        snackbarHost = { SnackbarHost(snackbarHostState) },
        topBar = {
            TopAppBar(
                title = { Text("Edit Category") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(imageVector = Icons.Filled.ArrowBack, contentDescription = "Back")
                    }
                },
                actions = {
                    IconButton(onClick = {
                        categoryToDelete = Category(id = categoryId, name = categoryName)
                        showDeleteDialog = true
                    }) {
                        Icon(imageVector = Icons.Default.Delete, contentDescription = "Delete Category")
                    }
                }
            )
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            OutlinedTextField(
                value = categoryName,
                onValueChange = { categoryName = it },
                label = { Text("Category Name") },
                modifier = Modifier.fillMaxWidth()
            )
            Button(
                onClick = {
                    if (categoryName.isNotBlank()) {
                        viewModel.updateCategory(Category(id = categoryId, name = categoryName))
                        navController.popBackStack()
                    }
                },
                modifier = Modifier.align(Alignment.End),
                enabled = categoryName.isNotBlank()
            ) {
                Text("Update Category")
            }
        }
    }

    if (showDeleteDialog) {
        AlertDialog(
            onDismissRequest = { showDeleteDialog = false },
            title = { Text("Confirm Deletion") },
            text = { Text("Are you sure you want to delete this category? This cannot be undone.") },
            confirmButton = {
                Button(
                    onClick = {
                        categoryToDelete?.let {
                            viewModel.deleteCategory(it)
                        }
                        showDeleteDialog = false
                        navController.popBackStack()
                    }
                ) { Text("Delete") }
            },
            dismissButton = {
                TextButton(onClick = { showDeleteDialog = false }) { Text("Cancel") }
            }
        )
    }
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/screens/AddBudgetScreen.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.Button
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import com.example.personalfinanceapp.BudgetViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddBudgetScreen(navController: NavController, viewModel: BudgetViewModel) {
    var categoryName by remember { mutableStateOf("") }
    var amount by remember { mutableStateOf("") }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Add New Budget") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(imageVector = Icons.Filled.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            OutlinedTextField(
                value = categoryName,
                onValueChange = { categoryName = it },
                label = { Text("Category Name") },
                modifier = Modifier.fillMaxWidth()
            )
            OutlinedTextField(
                value = amount,
                onValueChange = { amount = it },
                label = { Text("Budget Amount") },
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(16.dp))
            Button(
                onClick = {
                    if (categoryName.isNotBlank() && amount.isNotBlank()) {
                        viewModel.addBudget(categoryName, amount)
                        navController.popBackStack()
                    }
                },
                modifier = Modifier.align(Alignment.End),
                enabled = categoryName.isNotBlank() && amount.isNotBlank()
            ) {
                Text("Save Budget")
            }
        }
    }
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/screens/SmsWorkflowScreens.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.screens

import android.Manifest
import android.content.pm.PackageManager
import android.util.Log
import android.widget.Toast
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.core.content.ContextCompat
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.example.personalfinanceapp.*
import java.net.URLEncoder

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ReviewSmsScreen(navController: NavController, viewModel: SettingsViewModel = viewModel()) {
    val potentialTransactions by viewModel.potentialTransactions.collectAsState()

    // Load transactions when the screen is first displayed
    LaunchedEffect(Unit) {
        viewModel.rescanAllSmsMessages()
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Review Potential Transactions") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { innerPadding ->
        if (potentialTransactions.isEmpty()) {
            Box(
                modifier = Modifier.fillMaxSize().padding(innerPadding),
                contentAlignment = Alignment.Center
            ) {
                Column(horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    Text("No new transactions to review.", style = MaterialTheme.typography.titleMedium)
                    Text("Go back to Settings and tap 'Rescan' to find transactions.", style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center)
                }
            }
        } else {
            LazyColumn(
                modifier = Modifier.padding(innerPadding),
                contentPadding = PaddingValues(16.dp),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                item {
                    Text(
                        "${potentialTransactions.size} potential transactions found.",
                        style = MaterialTheme.typography.labelLarge,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
                items(potentialTransactions) { pt ->
                    PotentialTransactionItem(
                        transaction = pt,
                        onDismiss = { viewModel.dismissPotentialTransaction(it) },
                        onApprove = { transaction ->
                            // --- CORRECTED: Build a detailed route with arguments ---
                            val merchant = URLEncoder.encode(transaction.merchantName ?: "Unknown", "UTF-8")
                            val route = "approve_transaction_screen/${transaction.amount}/${transaction.transactionType}/${merchant}/${transaction.sourceSmsId}/${transaction.smsSender}"
                            navController.navigate(route)
                        }
                    )
                }
            }
        }
    }
}

@Composable
fun PotentialTransactionItem(
    transaction: PotentialTransaction,
    onDismiss: (PotentialTransaction) -> Unit,
    onApprove: (PotentialTransaction) -> Unit
) {
    Card(modifier = Modifier.fillMaxWidth(), elevation = CardDefaults.cardElevation(2.dp)) {
        Column(modifier = Modifier.padding(16.dp)) {
            val amountColor = if (transaction.transactionType == "expense") MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary

            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(
                    text = transaction.merchantName ?: "Unknown Merchant",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    modifier = Modifier.weight(1f)
                )
                Text(
                    text = "${"%.2f".format(transaction.amount)}",
                    style = MaterialTheme.typography.titleLarge,
                    color = amountColor,
                    fontWeight = FontWeight.Bold
                )
            }
            Spacer(Modifier.height(4.dp))
            Text(
                text = "Type: ${transaction.transactionType.replaceFirstChar { it.uppercase() }}",
                style = MaterialTheme.typography.bodyMedium,
            )
            Spacer(Modifier.height(8.dp))
            Text(
                text = "Original Message: ${transaction.originalMessage}",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                maxLines = 2,
                overflow = TextOverflow.Ellipsis
            )

            Spacer(Modifier.height(16.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.End
            ) {
                OutlinedButton(onClick = { onDismiss(transaction) }) {
                    Text("Dismiss")
                }
                Spacer(Modifier.width(8.dp))
                Button(onClick = { onApprove(transaction) }) {
                    Text("Approve")
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ApproveTransactionScreen(
    navController: NavController,
    transactionViewModel: TransactionViewModel = viewModel(),
    settingsViewModel: SettingsViewModel = viewModel(),
    // --- CORRECTED: Receive data as parameters, not from ViewModel state ---
    amount: Float,
    transactionType: String,
    merchant: String,
    smsId: Long,
    smsSender: String
) {
    var description by remember { mutableStateOf(merchant) }
    var notes by remember { mutableStateOf("") }

    val accounts by transactionViewModel.allAccounts.collectAsState(initial = emptyList())
    var selectedAccount by remember { mutableStateOf<Account?>(null) }
    var isAccountDropdownExpanded by remember { mutableStateOf(false) }

    val categories by transactionViewModel.allCategories.collectAsState(initial = emptyList())
    var selectedCategory by remember { mutableStateOf<Category?>(null) }
    var isCategoryDropdownExpanded by remember { mutableStateOf(false) }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Approve Transaction") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back")
                    }
                }
            )
        }
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier.padding(innerPadding),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item { OutlinedTextField(value = description, onValueChange = { description = it }, label = { Text("Description / Merchant") }, modifier = Modifier.fillMaxWidth()) }
            item { OutlinedTextField(value = amount.toString(), onValueChange = {}, readOnly = true, label = { Text("Amount") }, modifier = Modifier.fillMaxWidth()) }

            item {
                ExposedDropdownMenuBox(expanded = isAccountDropdownExpanded, onExpandedChange = { isAccountDropdownExpanded = !isAccountDropdownExpanded }) {
                    OutlinedTextField(
                        value = selectedAccount?.name ?: "Select Account",
                        onValueChange = {}, readOnly = true, label = { Text("Account") },
                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = isAccountDropdownExpanded) },
                        modifier = Modifier.fillMaxWidth().menuAnchor()
                    )
                    ExposedDropdownMenu(expanded = isAccountDropdownExpanded, onDismissRequest = { isAccountDropdownExpanded = false }) {
                        accounts.forEach { account ->
                            DropdownMenuItem(text = { Text(account.name) }, onClick = {
                                selectedAccount = account
                                isAccountDropdownExpanded = false
                            })
                        }
                    }
                }
            }

            item {
                ExposedDropdownMenuBox(expanded = isCategoryDropdownExpanded, onExpandedChange = { isCategoryDropdownExpanded = !isCategoryDropdownExpanded }) {
                    OutlinedTextField(
                        value = selectedCategory?.name ?: "Select Category",
                        onValueChange = {}, readOnly = true, label = { Text("Category") },
                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = isCategoryDropdownExpanded) },
                        modifier = Modifier.fillMaxWidth().menuAnchor()
                    )
                    ExposedDropdownMenu(expanded = isCategoryDropdownExpanded, onDismissRequest = { isCategoryDropdownExpanded = false }) {
                        categories.forEach { category ->
                            DropdownMenuItem(text = { Text(category.name) }, onClick = {
                                selectedCategory = category
                                isCategoryDropdownExpanded = false
                            })
                        }
                    }
                }
            }

            item { OutlinedTextField(value = notes, onValueChange = { notes = it }, label = { Text("Notes (Optional)") }, modifier = Modifier.fillMaxWidth()) }

            item {
                Button(
                    onClick = {
                        settingsViewModel.saveMerchantMapping(smsSender, description)

                        val success = transactionViewModel.addTransaction(
                            description = description,
                            categoryId = selectedCategory?.id,
                            amountStr = amount.toString(),
                            accountId = selectedAccount!!.id,
                            notes = notes.takeIf { it.isNotBlank() },
                            date = System.currentTimeMillis(),
                            transactionType = transactionType,
                            sourceSmsId = smsId // Use the passed-in ID
                        )
                        if (success) {
                            // No need to dismiss here, the list will be re-filtered on next scan
                            navController.popBackStack()
                        }
                    },
                    modifier = Modifier.fillMaxWidth(),
                    enabled = selectedAccount != null && selectedCategory != null
                ) { Text("Save Transaction") }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SmsDebugScreen(navController: NavController, viewModel: SettingsViewModel = viewModel()) {
    val smsMessages by viewModel.smsMessages.collectAsState()
    val context = LocalContext.current
    val hasSmsPermission = ContextCompat.checkSelfPermission(context, Manifest.permission.READ_SMS) == PackageManager.PERMISSION_GRANTED

    LaunchedEffect(hasSmsPermission) {
        if (hasSmsPermission) {
            viewModel.rescanAllSmsMessages()
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("SMS Debug Log") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { innerPadding ->
        Column(modifier = Modifier.padding(innerPadding).padding(16.dp)) {
            Button(
                onClick = {
                    if (hasSmsPermission) {
                        viewModel.rescanAllSmsMessages()
                    } else {
                        Toast.makeText(context, "Grant SMS permission in settings first.", Toast.LENGTH_LONG).show()
                    }
                },
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("Refresh SMS Messages")
            }

            Spacer(Modifier.height(16.dp))

            if (smsMessages.isEmpty() && hasSmsPermission) {
                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    Text("No messages found.")
                }
            } else if (!hasSmsPermission) {
                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    Text("Permission not granted.", textAlign = TextAlign.Center)
                }
            } else {
                LazyColumn(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    items(smsMessages) { sms ->
                        Card {
                            Column(Modifier.padding(8.dp)) {
                                Text(sms.sender, fontWeight = FontWeight.Bold)
                                Text(sms.body, maxLines = 3, overflow = TextOverflow.Ellipsis)
                            }
                        }
                    }
                }
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/screens/EditAccountScreen.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import com.example.personalfinanceapp.AccountViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EditAccountScreen(
    navController: NavController,
    viewModel: AccountViewModel,
    accountId: Int
) {
    val account by viewModel.getAccountById(accountId).collectAsState(initial = null)
    var accountName by remember { mutableStateOf("") }
    var accountType by remember { mutableStateOf("") }
    var showDeleteDialog by remember { mutableStateOf(false) }

    LaunchedEffect(account) {
        account?.let {
            accountName = it.name
            accountType = it.type
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Edit Account") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(imageVector = Icons.Filled.ArrowBack, contentDescription = "Back")
                    }
                },
                actions = {
                    IconButton(onClick = { showDeleteDialog = true }) {
                        Icon(imageVector = Icons.Filled.Delete, contentDescription = "Delete Account")
                    }
                }
            )
        }
    ) { innerPadding ->
        account?.let { currentAccount ->
            Column(
                modifier = Modifier
                    .padding(innerPadding)
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                OutlinedTextField(
                    value = accountName,
                    onValueChange = { accountName = it },
                    label = { Text("Account Name") },
                    modifier = Modifier.fillMaxWidth()
                )
                OutlinedTextField(
                    value = accountType,
                    onValueChange = { accountType = it },
                    label = { Text("Account Type") },
                    modifier = Modifier.fillMaxWidth()
                )
                Spacer(modifier = Modifier.height(16.dp))
                Button(
                    onClick = {
                        val updatedAccount = currentAccount.copy(
                            name = accountName,
                            type = accountType
                        )
                        viewModel.updateAccount(updatedAccount)
                        navController.popBackStack()
                    },
                    modifier = Modifier.align(Alignment.End)
                ) {
                    Text("Update Account")
                }
            }
        }
    }

    if (showDeleteDialog) {
        AlertDialog(
            onDismissRequest = { showDeleteDialog = false },
            title = { Text("Confirm Deletion") },
            text = { Text("Are you sure you want to delete this account? This cannot be undone.") },
            confirmButton = {
                Button(
                    onClick = {
                        account?.let {
                            viewModel.deleteAccount(it)
                            showDeleteDialog = false
                            navController.popBackStack()
                        }
                    }
                ) { Text("Delete") }
            },
            dismissButton = {
                TextButton(onClick = { showDeleteDialog = false }) { Text("Cancel") }
            }
        )
    }
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/screens/AddTransactionScreen.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.AccessTime
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.DateRange
import androidx.compose.material3.Button
import androidx.compose.material3.DatePicker
import androidx.compose.material3.DatePickerDialog
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.ExposedDropdownMenuBox
import androidx.compose.material3.ExposedDropdownMenuDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Tab
import androidx.compose.material3.TabRow
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TimePicker
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.rememberDatePickerState
import androidx.compose.material3.rememberTimePickerState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import com.example.personalfinanceapp.Account
import com.example.personalfinanceapp.Category
import com.example.personalfinanceapp.TransactionViewModel
import com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components.TimePickerDialog
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Locale

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddTransactionScreen(navController: NavController, viewModel: TransactionViewModel) {
    var description by remember { mutableStateOf("") }
    var amount by remember { mutableStateOf("") }
    var notes by remember { mutableStateOf("") }

    var transactionType by remember { mutableStateOf("expense") }
    val transactionTypes = listOf("Expense", "Income")

    val accounts by viewModel.allAccounts.collectAsState(initial = emptyList())
    var selectedAccount by remember { mutableStateOf<Account?>(null) }
    var isAccountDropdownExpanded by remember { mutableStateOf(false) }

    val categories by viewModel.allCategories.collectAsState(initial = emptyList())
    var selectedCategory by remember { mutableStateOf<Category?>(null) }
    var isCategoryDropdownExpanded by remember { mutableStateOf(false) }

    var showDatePicker by remember { mutableStateOf(false) }
    var showTimePicker by remember { mutableStateOf(false) }
    val selectedDateTime by remember { mutableStateOf(Calendar.getInstance()) }

    val snackbarHostState = remember { SnackbarHostState() }
    val validationError by viewModel.validationError.collectAsState()

    LaunchedEffect(validationError) {
        validationError?.let {
            snackbarHostState.showSnackbar(it)
            viewModel.clearError()
        }
    }

    Scaffold(
        snackbarHost = { SnackbarHost(snackbarHostState) },
        topBar = {
            TopAppBar(
                title = { Text("Add New Transaction") },
                navigationIcon = { IconButton(onClick = { navController.popBackStack() }) { Icon(
                    Icons.Filled.ArrowBack, "Back") } }
            )
        }
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            item {
                TabRow(selectedTabIndex = if (transactionType == "expense") 0 else 1) {
                    transactionTypes.forEachIndexed { index, title ->
                        Tab(
                            selected = (if (transactionType == "expense") 0 else 1) == index,
                            onClick = { transactionType = if (index == 0) "expense" else "income" },
                            text = { Text(title) }
                        )
                    }
                }
            }

            item { OutlinedTextField(value = description, onValueChange = { description = it }, label = { Text("Description") }, modifier = Modifier.fillMaxWidth()) }
            item { OutlinedTextField(value = amount, onValueChange = { amount = it }, label = { Text("Amount") }, modifier = Modifier.fillMaxWidth(), keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number)) }
            item { OutlinedTextField(value = notes, onValueChange = { notes = it }, label = { Text("Notes (Optional)") }, modifier = Modifier.fillMaxWidth()) }

            item {
                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                    Button(onClick = { showDatePicker = true }, modifier = Modifier.weight(1f)) {
                        Icon(imageVector = Icons.Default.DateRange, contentDescription = "Select Date")
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(text = SimpleDateFormat("dd/MM/yyyy", Locale.getDefault()).format(selectedDateTime.time))
                    }
                    Button(onClick = { showTimePicker = true }, modifier = Modifier.weight(1f)) {
                        Icon(imageVector = Icons.Default.AccessTime, contentDescription = "Select Time")
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(text = SimpleDateFormat("hh:mm a", Locale.getDefault()).format(selectedDateTime.time))
                    }
                }
            }

            item {
                ExposedDropdownMenuBox(expanded = isAccountDropdownExpanded, onExpandedChange = { isAccountDropdownExpanded = !isAccountDropdownExpanded }) {
                    OutlinedTextField(
                        value = selectedAccount?.name ?: "Select Account",
                        onValueChange = {}, readOnly = true, label = { Text("Account") },
                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = isAccountDropdownExpanded) },
                        modifier = Modifier.fillMaxWidth().menuAnchor()
                    )
                    ExposedDropdownMenu(expanded = isAccountDropdownExpanded, onDismissRequest = { isAccountDropdownExpanded = false }) {
                        accounts.forEach { account ->
                            DropdownMenuItem(text = { Text(account.name) }, onClick = {
                                selectedAccount = account
                                isAccountDropdownExpanded = false
                            })
                        }
                    }
                }
            }

            item {
                ExposedDropdownMenuBox(expanded = isCategoryDropdownExpanded, onExpandedChange = { isCategoryDropdownExpanded = !isCategoryDropdownExpanded }) {
                    OutlinedTextField(
                        value = selectedCategory?.name ?: "Select Category",
                        onValueChange = {}, readOnly = true, label = { Text("Category") },
                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = isCategoryDropdownExpanded) },
                        modifier = Modifier.fillMaxWidth().menuAnchor()
                    )
                    ExposedDropdownMenu(expanded = isCategoryDropdownExpanded, onDismissRequest = { isCategoryDropdownExpanded = false }) {
                        categories.forEach { category ->
                            DropdownMenuItem(text = { Text(category.name) }, onClick = {
                                selectedCategory = category
                                isCategoryDropdownExpanded = false
                            })
                        }
                    }
                }
            }

            item {
                Button(
                    onClick = {
                        val success = viewModel.addTransaction(
                            description = description,
                            categoryId = selectedCategory?.id,
                            amountStr = amount,
                            accountId = selectedAccount!!.id,
                            notes = notes.takeIf { it.isNotBlank() },
                            date = selectedDateTime.timeInMillis,
                            transactionType = transactionType,
                            sourceSmsId = null
                        )
                        if (success) {
                            navController.popBackStack()
                        }
                    },
                    modifier = Modifier.fillMaxWidth(),
                    enabled = selectedAccount != null && amount.isNotBlank() && description.isNotBlank()
                ) {
                    Text("Save Transaction")
                }
            }
        }
    }

    if (showDatePicker) {
        val datePickerState = rememberDatePickerState(initialSelectedDateMillis = selectedDateTime.timeInMillis)
        DatePickerDialog(
            onDismissRequest = { showDatePicker = false },
            confirmButton = {
                TextButton(
                    onClick = {
                        datePickerState.selectedDateMillis?.let {
                            val newCalendar = Calendar.getInstance().apply { timeInMillis = it }
                            selectedDateTime.set(Calendar.YEAR, newCalendar.get(Calendar.YEAR))
                            selectedDateTime.set(Calendar.MONTH, newCalendar.get(Calendar.MONTH))
                            selectedDateTime.set(Calendar.DAY_OF_MONTH, newCalendar.get(Calendar.DAY_OF_MONTH))
                        }
                        showDatePicker = false
                    }
                ) { Text("OK") }
            },
            dismissButton = { TextButton(onClick = { showDatePicker = false }) { Text("Cancel") } }
        ) { DatePicker(state = datePickerState) }
    }

    if (showTimePicker) {
        val timePickerState = rememberTimePickerState(initialHour = selectedDateTime.get(Calendar.HOUR_OF_DAY), initialMinute = selectedDateTime.get(
            Calendar.MINUTE))
        TimePickerDialog(
            onDismissRequest = { showTimePicker = false },
            onConfirm = {
                selectedDateTime.set(Calendar.HOUR_OF_DAY, timePickerState.hour)
                selectedDateTime.set(Calendar.MINUTE, timePickerState.minute)
                showTimePicker = false
            }
        ) { TimePicker(state = timePickerState) }
    }
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/screens/AccountListScreen.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.screens

import androidx.compose.foundation.clickable
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.ListItem
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.navigation.NavController
import com.example.personalfinanceapp.AccountViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AccountListScreen(navController: NavController, viewModel: AccountViewModel) {
    // CORRECTED: Changed 'allAccounts' to 'accountsWithBalance'. This assumes your
    // AccountViewModel has a property like: val accountsWithBalance: Flow<List<AccountWithBalance>>
    val accounts by viewModel.accountsWithBalance.collectAsState(initial = emptyList())
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Manage Accounts") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.Filled.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        },
        floatingActionButton = {
            FloatingActionButton(onClick = { navController.navigate("add_account") }) {
                Icon(Icons.Filled.Add, contentDescription = "Add Account")
            }
        }
    ) { innerPadding ->
        LazyColumn(contentPadding = innerPadding) {
            items(accounts) { account ->
                ListItem(
                    headlineContent = { Text(account.account.name) },
                    supportingContent = { Text("Balance: ${"%.2f".format(account.balance)}") },
                    trailingContent = {
                        IconButton(onClick = { navController.navigate("edit_account/${account.account.id}") }) {
                            Icon(Icons.Filled.Edit, contentDescription = "Edit Account")
                        }
                    },
                    modifier = Modifier.clickable { navController.navigate("account_detail/${account.account.id}") }
                )
            }
        }
    }
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/screens/BudgetScreen.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Home
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components.BudgetItem
import com.example.personalfinanceapp.BudgetViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun BudgetScreen(navController: NavController, viewModel: BudgetViewModel) {
    val budgets by viewModel.budgetsForCurrentMonth.collectAsState(initial = emptyList())
    val monthYear = viewModel.getCurrentMonthYearString()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Budgets for $monthYear") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(imageVector = Icons.Filled.ArrowBack, contentDescription = "Back")
                    }
                },
                actions = {
                    IconButton(onClick = { navController.navigate("dashboard") }) {
                        Icon(imageVector = Icons.Filled.Home, contentDescription = "Dashboard")
                    }
                }
            )
        },
        floatingActionButton = {
            FloatingActionButton(onClick = { navController.navigate("add_budget") }) {
                Icon(imageVector = Icons.Filled.Add, contentDescription = "Add Budget")
            }
        }
    ) { innerPadding ->
        if (budgets.isEmpty()) {
            Box(modifier = Modifier.fillMaxSize().padding(innerPadding), contentAlignment = Alignment.Center) {
                Text("No budgets set for this month. Add one!")
            }
        } else {
            LazyColumn(
                modifier = Modifier
                    .padding(innerPadding),
                contentPadding = PaddingValues(16.dp),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                items(budgets) { budget ->
                    BudgetItem(budget = budget, viewModel = viewModel)
                }
            }
        }
    }
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/screens/SettingsScreen.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.screens

import android.Manifest
import android.content.pm.PackageManager
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.core.content.ContextCompat
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.example.personalfinanceapp.DataExportService
import com.example.personalfinanceapp.SettingsRepository
import com.example.personalfinanceapp.SettingsViewModel
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SettingsScreen(
    navController: NavController,
    viewModel: SettingsViewModel = viewModel()
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val settingsRepository = remember { SettingsRepository(context) }
    val isScanning by viewModel.isScanning.collectAsState()

    // State for all settings
    val isAppLockEnabled by settingsRepository.getAppLockEnabled().collectAsState(initial = false)
    val isWeeklySummaryEnabled by settingsRepository.getWeeklySummaryEnabled().collectAsState(initial = true)
    val isUnknownTransactionPopupEnabled by settingsRepository.getUnknownTransactionPopupEnabled().collectAsState(initial = true)
    // --- ADDED: State for the new reminder toggle ---
    val isDailyReminderEnabled by viewModel.dailyReminderEnabled.collectAsState()


    // Permission Handlers
    var hasSmsPermission by remember {
        mutableStateOf(
            ContextCompat.checkSelfPermission(context, Manifest.permission.READ_SMS) == PackageManager.PERMISSION_GRANTED &&
                    ContextCompat.checkSelfPermission(context, Manifest.permission.RECEIVE_SMS) == PackageManager.PERMISSION_GRANTED
        )
    }
    var hasNotificationPermission by remember {
        mutableStateOf(
            ContextCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) == PackageManager.PERMISSION_GRANTED
        )
    }

    val permissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestMultiplePermissions()
    ) { perms ->
        hasSmsPermission = perms[Manifest.permission.READ_SMS] == true && perms[Manifest.permission.RECEIVE_SMS] == true
    }

    val notificationPermissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestPermission()
    ) { isGranted ->
        hasNotificationPermission = isGranted
    }
    var showImportConfirmDialog by remember { mutableStateOf(false) }

    val fileSaverLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.CreateDocument("application/json"),
        onResult = { uri ->
            uri?.let {
                scope.launch {
                    val jsonString = DataExportService.exportToJsonString(context)
                    if (jsonString != null) {
                        try {
                            context.contentResolver.openOutputStream(it)?.use { outputStream ->
                                outputStream.write(jsonString.toByteArray())
                            }
                            Toast.makeText(context, "Data exported successfully!", Toast.LENGTH_LONG).show()
                        } catch (e: Exception) {
                            Toast.makeText(context, "Error saving file.", Toast.LENGTH_LONG).show()
                        }
                    } else {
                        Toast.makeText(context, "Error exporting data.", Toast.LENGTH_LONG).show()
                    }
                }
            }
        }
    )

    val filePickerLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.OpenDocument(),
        onResult = { uri ->
            uri?.let {
                scope.launch {
                    val success = DataExportService.importDataFromJson(context, it)
                    if (success) {
                        Toast.makeText(context, "Data imported successfully! Please restart the app.", Toast.LENGTH_LONG).show()
                    } else {
                        Toast.makeText(context, "Failed to import data.", Toast.LENGTH_LONG).show()
                    }
                }
            }
        }
    )

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Settings") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier.fillMaxSize().padding(innerPadding),
            contentPadding = PaddingValues(vertical = 8.dp),
        ) {
            item { SettingSectionHeader("General") }
            item {
                Column(Modifier.padding(horizontal = 16.dp)) {
                    val currentBudget by viewModel.overallBudget.collectAsState()
                    var budgetInput by remember(currentBudget) { mutableStateOf(if (currentBudget > 0) currentBudget.toString() else "") }

                    OutlinedTextField(
                        value = budgetInput,
                        onValueChange = { budgetInput = it },
                        label = { Text("Overall Monthly Budget") },
                        modifier = Modifier.fillMaxWidth().padding(bottom = 8.dp),
                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                        leadingIcon = { Text("") }
                    )
                    Button(
                        onClick = { viewModel.saveOverallBudget(budgetInput); Toast.makeText(context, "Budget Saved!", Toast.LENGTH_SHORT).show() },
                        modifier = Modifier.fillMaxWidth()
                    ) { Text("Save Budget") }
                }
            }

            item { SettingSectionHeader("Security") }
            item {
                SettingsToggleItem(
                    title = "Enable App Lock",
                    subtitle = "Use biometrics or screen lock to secure the app.",
                    icon = Icons.Default.Lock,
                    checked = isAppLockEnabled,
                    onCheckedChange = { settingsRepository.saveAppLockEnabled(it) }
                )
            }

            item { SettingSectionHeader("Notifications") }
            // --- ADDED: Daily Reminder Toggle Switch ---
            item {
                SettingsToggleItem(
                    title = "Daily Review Reminder",
                    subtitle = "Get a notification if you have transactions waiting for your approval.",
                    icon = Icons.Default.NotificationsActive,
                    checked = isDailyReminderEnabled,
                    onCheckedChange = { enabled ->
                        viewModel.setDailyReminder(enabled, context)
                    }
                )
            }
            item {
                SettingsToggleItem(
                    title = "Weekly Summary Notification",
                    subtitle = "Receive a summary of your finances every week.",
                    icon = Icons.Default.CalendarToday,
                    checked = isWeeklySummaryEnabled,
                    onCheckedChange = { settingsRepository.saveWeeklySummaryEnabled(it) }
                )
            }
            item {
                SettingsToggleItem(
                    title = "Popup for Unknown Transactions",
                    subtitle = "Show notification for SMS from new merchants.",
                    icon = Icons.Default.Notifications,
                    checked = isUnknownTransactionPopupEnabled,
                    onCheckedChange = { settingsRepository.saveUnknownTransactionPopupEnabled(it) }
                )
            }

            item { SettingSectionHeader("Permissions") }
            item {
                SettingsToggleItem(
                    title = "SMS Access",
                    subtitle = "Allow reading and receiving SMS for auto-detection.",
                    icon = Icons.Default.Message,
                    checked = hasSmsPermission,
                    onCheckedChange = {
                        if (!hasSmsPermission) {
                            permissionLauncher.launch(arrayOf(Manifest.permission.READ_SMS, Manifest.permission.RECEIVE_SMS))
                        }
                    }
                )
            }
            item {
                SettingsToggleItem(
                    title = "Enable Notifications",
                    subtitle = "Show alerts for new transactions and reminders.",
                    icon = Icons.Default.Notifications,
                    checked = hasNotificationPermission,
                    onCheckedChange = {
                        if(!hasNotificationPermission) {
                            notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
                        }
                    }
                )
            }

            item { SettingSectionHeader("Data Management") }
            item {
                Column(Modifier.padding(horizontal = 16.dp)) {
                    SettingsActionItem(
                        text = "Rescan SMS Inbox",
                        icon = Icons.Default.Refresh,
                        onClick = {
                            if (hasSmsPermission) {
                                Toast.makeText(context, "Scanning all messages...", Toast.LENGTH_SHORT).show()
                                viewModel.rescanAllSmsMessages()
                                navController.navigate("review_sms_screen")
                            } else {
                                Toast.makeText(context, "Please grant SMS permission first.", Toast.LENGTH_SHORT).show()
                            }
                        }
                    )
                    SettingsActionItem(
                        text = "Export Data",
                        icon = Icons.Default.UploadFile,
                        onClick = {
                            val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
                            val fileName = "FinanceApp_Backup_${sdf.format(Date())}.json"
                            fileSaverLauncher.launch(fileName)
                        }
                    )
                    SettingsActionItem(
                        text = "Import Data",
                        icon = Icons.Default.Download,
                        onClick = { showImportConfirmDialog = true }
                    )
                }
            }
        }
    }
    if (isScanning) {
        Surface(
            modifier = Modifier.fillMaxSize(),
            color = MaterialTheme.colorScheme.scrim.copy(alpha = 0.5f)
        ) {
            Box(contentAlignment = Alignment.Center) {
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    CircularProgressIndicator()
                    Spacer(Modifier.height(16.dp))
                    Text("Scanning SMS Inbox...", style = MaterialTheme.typography.titleMedium)
                }
            }
        }
    }

    if (showImportConfirmDialog) {
        AlertDialog(
            onDismissRequest = { showImportConfirmDialog = false },
            title = { Text("Import Data?") },
            text = { Text("This will delete all current data and replace it with the data from your backup file. This cannot be undone.") },
            confirmButton = {
                Button(
                    onClick = {
                        showImportConfirmDialog = false
                        filePickerLauncher.launch(arrayOf("application/json"))
                    }
                ) { Text("Import") }
            },
            dismissButton = {
                TextButton(onClick = { showImportConfirmDialog = false }) { Text("Cancel") }
            }
        )
    }
}

@Composable
private fun SettingSectionHeader(title: String) {
    Text(
        text = title.uppercase(),
        style = MaterialTheme.typography.labelSmall,
        color = MaterialTheme.colorScheme.primary,
        modifier = Modifier.padding(top = 24.dp, bottom = 8.dp, start = 16.dp, end = 16.dp)
    )
    Divider()
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun SettingsToggleItem(
    title: String,
    subtitle: String,
    icon: ImageVector,
    checked: Boolean,
    onCheckedChange: (Boolean) -> Unit,
    enabled: Boolean = true
) {
    ListItem(
        headlineContent = { Text(title) },
        supportingContent = { Text(subtitle, style = MaterialTheme.typography.bodySmall) },
        leadingContent = { Icon(icon, contentDescription = null) },
        trailingContent = { Switch(checked = checked, onCheckedChange = onCheckedChange, enabled = enabled) },
        modifier = Modifier.padding(horizontal = 16.dp)
    )
}

@Composable
private fun SettingsActionItem(
    text: String,
    icon: ImageVector,
    onClick: () -> Unit
) {
    TextButton(
        onClick = onClick,
        modifier = Modifier.fillMaxWidth(),
        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 12.dp)
    ) {
        Icon(icon, contentDescription = null, modifier = Modifier.size(20.dp))
        Spacer(Modifier.width(16.dp))
        Text(text)
        Spacer(Modifier.weight(1f))
    }
}
-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/screens/TransactionListScreen.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.screens

import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.navigation.NavController
import com.example.personalfinanceapp.TransactionViewModel
import com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components.TransactionList

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun TransactionListScreen(navController: NavController, viewModel: TransactionViewModel) {
    val transactions by viewModel.allTransactions.collectAsState(initial = emptyList())
    Scaffold(
        topBar = {
            TopAppBar(title = { Text("Transaction History") })
        },
        floatingActionButton = {
            FloatingActionButton(onClick = { navController.navigate("add_transaction") }) {
                Icon(Icons.Filled.Add, contentDescription = "Add transaction")
            }
        }
    ) { innerPadding ->
        TransactionList(transactions = transactions, navController = navController)
    }
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/screens/AccountDetailScreen.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Divider
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import com.example.personalfinanceapp.AccountViewModel
import com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components.AccountTransactionItem

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AccountDetailScreen(
    navController: NavController,
    viewModel: AccountViewModel,
    accountId: Int
) {
    val account by viewModel.getAccountById(accountId).collectAsState(initial = null)
    val balance by viewModel.getAccountBalance(accountId).collectAsState(initial = 0.0)
    // --- CORRECTED: This now correctly collects the list of TransactionDetails ---
    val transactions by viewModel.getTransactionsForAccount(accountId).collectAsState(initial = emptyList())

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(account?.name ?: "Account Details") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(imageVector = Icons.Filled.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .padding(innerPadding)
                .padding(horizontal = 16.dp)
                .fillMaxSize()
        ) {
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(vertical = 8.dp),
                elevation = CardDefaults.cardElevation(4.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Text(
                        text = "Current Balance",
                        style = MaterialTheme.typography.titleMedium,
                        color = Color.Gray
                    )
                    Spacer(modifier = Modifier.height(4.dp))
                    Text(
                        text = "${"%.2f".format(balance)}",
                        style = MaterialTheme.typography.displaySmall,
                        fontWeight = FontWeight.Bold,
                        color = if (balance < 0) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary
                    )
                }
            }
            Spacer(modifier = Modifier.height(16.dp))
            Text(
                text = "Recent Transactions",
                style = MaterialTheme.typography.titleLarge,
                modifier = Modifier.padding(bottom = 8.dp)
            )
            if (transactions.isEmpty()) {
                Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize()) {
                    Text("No transactions for this account yet.")
                }
            } else {
                LazyColumn {
                    // --- CORRECTED: We now pass `details.transaction` to the item composable ---
                    items(transactions) { details ->
                        AccountTransactionItem(transaction = details.transaction)
                        Divider()
                    }
                }
            }
        }
    }
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/screens/DashboardScreen.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.PieChart
import androidx.compose.material.icons.filled.Search
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material.icons.filled.Timeline
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FilledTonalButton
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import androidx.navigation.NavGraph.Companion.findStartDestination
import com.example.personalfinanceapp.BottomNavItem
import com.example.personalfinanceapp.BudgetViewModel
import com.example.personalfinanceapp.DashboardViewModel
import com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components.BudgetWatchCard
import com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components.NetWorthCard
import com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components.OverallBudgetCard
import com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components.RecentActivityCard
import com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components.StatCard

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DashboardScreen(
    navController: NavController,
    viewModel: DashboardViewModel,
    budgetViewModel: BudgetViewModel
) {
    val netWorth by viewModel.netWorth.collectAsState()
    val monthlyIncome by viewModel.monthlyIncome.collectAsState()
    val monthlyExpenses by viewModel.monthlyExpenses.collectAsState()
    val overallBudget by viewModel.overallMonthlyBudget.collectAsState()
    val safeToSpend by viewModel.safeToSpendPerDay.collectAsState()
    val budgetStatus by viewModel.budgetStatus.collectAsState()
    val recentTransactions by viewModel.recentTransactions.collectAsState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Dashboard") },
                actions = {
                    IconButton(onClick = { navController.navigate("search_screen") }) {
                        Icon(imageVector = Icons.Default.Search, contentDescription = "Search")
                    }
                    IconButton(onClick = { navController.navigate(BottomNavItem.Settings.route) }) {
                        Icon(imageVector = Icons.Default.Settings, contentDescription = "Settings")
                    }
                }
            )
        },
        floatingActionButton = {
            FloatingActionButton(onClick = { navController.navigate("add_transaction") }) {
                Icon(imageVector = Icons.Filled.Add, contentDescription = "Add Transaction")
            }
        }
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier.padding(innerPadding),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                OverallBudgetCard(
                    totalBudget = overallBudget,
                    amountSpent = monthlyExpenses.toFloat()
                )
            }
            item {
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(12.dp)) {
                    StatCard(label = "Monthly Income", amount = monthlyIncome.toFloat(), modifier = Modifier.weight(1f))
                    StatCard(label = "Total Budget", amount = overallBudget, modifier = Modifier.weight(1f))
                    StatCard(label = "Safe to Spend", amount = safeToSpend, modifier = Modifier.weight(1f), isPerDay = true)
                }
            }
            item {
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(16.dp)) {
                    FilledTonalButton(
                        onClick = { navController.navigate(BottomNavItem.Reports.route) {
                            popUpTo(navController.graph.findStartDestination().id) { saveState = true }
                            launchSingleTop = true
                            restoreState = true
                        }},
                        modifier = Modifier.weight(1f)
                    ) {
                        Icon(Icons.Default.Timeline, contentDescription = null, modifier = Modifier.size(18.dp))
                        Spacer(modifier = Modifier.width(8.dp))
                        Text("View Trends")
                    }
                    FilledTonalButton(
                        onClick = { navController.navigate(BottomNavItem.Reports.route) {
                            popUpTo(navController.graph.findStartDestination().id) { saveState = true }
                            launchSingleTop = true
                            restoreState = true
                        }},
                        modifier = Modifier.weight(1f)
                    ) {
                        Icon(Icons.Default.PieChart, contentDescription = null, modifier = Modifier.size(18.dp))
                        Spacer(modifier = Modifier.width(8.dp))
                        Text("View Categories")
                    }
                }
            }
            item { NetWorthCard(netWorth) }
            item { RecentActivityCard(recentTransactions, navController) }
            item { BudgetWatchCard(budgetStatus, budgetViewModel) }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/screens/RecurringTransactionScreens.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.example.personalfinanceapp.*
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun RecurringTransactionScreen(navController: NavController) {
    val viewModel: RecurringTransactionViewModel = viewModel()
    val recurringTransactions by viewModel.allRecurringTransactions.collectAsState(initial = emptyList())

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Recurring Transactions") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        },
        floatingActionButton = {
            FloatingActionButton(onClick = { navController.navigate("add_recurring_transaction") }) {
                Icon(Icons.Default.Add, contentDescription = "Add Recurring Transaction")
            }
        }
    ) { innerPadding ->
        if (recurringTransactions.isEmpty()) {
            Box(modifier = Modifier.fillMaxSize().padding(innerPadding), contentAlignment = Alignment.Center) {
                Text("No recurring transactions set up.")
            }
        } else {
            LazyColumn(
                contentPadding = innerPadding,
                modifier = Modifier.padding(horizontal = 16.dp)
            ) {
                items(recurringTransactions) { rule ->
                    ListItem(
                        headlineContent = { Text(rule.description) },
                        supportingContent = { Text("${rule.amount} every ${rule.recurrenceInterval.lowercase(Locale.getDefault())}") },
                        trailingContent = {
                            Text(
                                text = rule.transactionType.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() },
                                color = if (rule.transactionType == "expense") MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary
                            )
                        }
                    )
                    Divider()
                }
            }
        }
    }
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/screens/SearchScreen.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.screens

import android.app.Application
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Clear
import androidx.compose.material.icons.filled.DateRange
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.example.personalfinanceapp.*
import com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components.TransactionItem
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SearchScreen(
    navController: NavController,
) {
    val context = LocalContext.current
    val factory = SearchViewModelFactory(context.applicationContext as Application)
    val viewModel: SearchViewModel = viewModel(factory = factory)

    val searchUiState by viewModel.uiState.collectAsState()
    val searchResults by viewModel.searchResults.collectAsState()

    var showStartDatePicker by remember { mutableStateOf(false) }
    var showEndDatePicker by remember { mutableStateOf(false) }

    val dateFormatter = SimpleDateFormat("dd/MM/yyyy", Locale.getDefault())

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Search Transactions") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { innerPadding ->
        Column(modifier = Modifier.padding(innerPadding)) {
            // Filter Form
            LazyColumn(
                contentPadding = PaddingValues(16.dp),
                verticalArrangement = Arrangement.spacedBy(12.dp),
                modifier = Modifier.weight(1f)
            ) {
                // Keyword Search
                item {
                    OutlinedTextField(
                        value = searchUiState.keyword,
                        onValueChange = { viewModel.onKeywordChange(it) },
                        label = { Text("Keyword (description, notes)") },
                        modifier = Modifier.fillMaxWidth()
                    )
                }

                // Account Dropdown
                item {
                    SearchableDropdown(
                        label = "Account",
                        options = searchUiState.accounts,
                        selectedOption = searchUiState.selectedAccount,
                        onOptionSelected = { viewModel.onAccountChange(it) },
                        getDisplayName = { it.name }
                    )
                }

                // Category Dropdown
                item {
                    SearchableDropdown(
                        label = "Category",
                        options = searchUiState.categories,
                        selectedOption = searchUiState.selectedCategory,
                        onOptionSelected = { viewModel.onCategoryChange(it) },
                        getDisplayName = { it.name }
                    )
                }

                // Transaction Type Dropdown
                item {
                    SearchableDropdown(
                        label = "Transaction Type",
                        options = listOf("All", "Income", "Expense"),
                        selectedOption = searchUiState.transactionType.replaceFirstChar { it.uppercase() },
                        onOptionSelected = { viewModel.onTypeChange(it) },
                        getDisplayName = { it }
                    )
                }

                // Date Range Pickers
                item {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        DateTextField(
                            label = "Start Date",
                            date = searchUiState.startDate,
                            formatter = dateFormatter,
                            onClick = { showStartDatePicker = true },
                            onClear = { viewModel.onDateChange(start = null) },
                            modifier = Modifier.weight(1f)
                        )
                        DateTextField(
                            label = "End Date",
                            date = searchUiState.endDate,
                            formatter = dateFormatter,
                            onClick = { showEndDatePicker = true },
                            onClear = { viewModel.onDateChange(end = null) },
                            modifier = Modifier.weight(1f)
                        )
                    }
                }

                // Search Results
                if (searchResults.isNotEmpty()) {
                    item {
                        Text(
                            text = "Results (${searchResults.size})",
                            style = MaterialTheme.typography.titleMedium,
                            modifier = Modifier.padding(top = 16.dp)
                        )
                        Divider(modifier = Modifier.padding(vertical = 8.dp))
                    }
                    items(searchResults) { transactionDetails ->
                        TransactionItem(
                            transactionDetails = transactionDetails,
                            onClick = { navController.navigate("edit_transaction/${transactionDetails.transaction.id}") }
                        )
                    }
                } else if(searchUiState.hasSearched) {
                    item {
                        Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxWidth().padding(32.dp)) {
                            Text("No transactions match your criteria.")
                        }
                    }
                }
            }

            // Buttons
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                OutlinedButton(
                    onClick = { viewModel.clearFilters() },
                    modifier = Modifier.weight(1f)
                ) { Text("Clear") }

                Button(
                    onClick = { viewModel.executeSearch() },
                    modifier = Modifier.weight(1f)
                ) { Text("Apply Filters") }
            }
        }
    }

    if (showStartDatePicker) {
        val datePickerState = rememberDatePickerState(initialSelectedDateMillis = searchUiState.startDate)
        DatePickerDialog(
            onDismissRequest = { showStartDatePicker = false },
            confirmButton = {
                TextButton(onClick = {
                    viewModel.onDateChange(start = datePickerState.selectedDateMillis)
                    showStartDatePicker = false
                }) { Text("OK") }
            },
            dismissButton = {
                TextButton(onClick = { showStartDatePicker = false }) { Text("Cancel") }
            }
        ) {
            DatePicker(state = datePickerState)
        }
    }

    if (showEndDatePicker) {
        val datePickerState = rememberDatePickerState(initialSelectedDateMillis = searchUiState.endDate)
        DatePickerDialog(
            onDismissRequest = { showEndDatePicker = false },
            confirmButton = {
                TextButton(onClick = {
                    viewModel.onDateChange(end = datePickerState.selectedDateMillis)
                    showEndDatePicker = false
                }) { Text("OK") }
            },
            dismissButton = {
                TextButton(onClick = { showEndDatePicker = false }) { Text("Cancel") }
            }
        ) {
            DatePicker(state = datePickerState)
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun <T> SearchableDropdown(
    label: String,
    options: List<T>,
    selectedOption: T?,
    onOptionSelected: (T?) -> Unit,
    getDisplayName: (T) -> String
) {
    var expanded by remember { mutableStateOf(false) }

    ExposedDropdownMenuBox(
        expanded = expanded,
        onExpandedChange = { expanded = !expanded }
    ) {
        OutlinedTextField(
            value = selectedOption?.let { getDisplayName(it) } ?: "All",
            onValueChange = {},
            readOnly = true,
            label = { Text(label) },
            trailingIcon = {
                Row {
                    if (selectedOption != null) {
                        IconButton(onClick = { onOptionSelected(null) }) {
                            Icon(Icons.Default.Clear, contentDescription = "Clear selection")
                        }
                    }
                    ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded)
                }
            },
            modifier = Modifier
                .menuAnchor()
                .fillMaxWidth()
        )
        ExposedDropdownMenu(
            expanded = expanded,
            onDismissRequest = { expanded = false }
        ) {
            options.forEach { option ->
                DropdownMenuItem(
                    text = { Text(getDisplayName(option)) },
                    onClick = {
                        onOptionSelected(option)
                        expanded = false
                    }
                )
            }
        }
    }
}

@Composable
fun DateTextField(
    label: String,
    date: Long?,
    formatter: SimpleDateFormat,
    onClick: () -> Unit,
    onClear: () -> Unit,
    modifier: Modifier = Modifier
) {
    OutlinedTextField(
        value = date?.let { formatter.format(Date(it)) } ?: "",
        onValueChange = {},
        readOnly = true,
        label = { Text(label) },
        modifier = modifier.clickable(onClick = onClick),
        trailingIcon = {
            if (date != null) {
                IconButton(onClick = onClear) {
                    Icon(Icons.Default.Clear, "Clear Date")
                }
            } else {
                Icon(Icons.Default.DateRange, "Select Date")
            }
        }
    )
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/screens/AddAccountScreen.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.Button
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import com.example.personalfinanceapp.AccountViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddAccountScreen(navController: NavController, viewModel: AccountViewModel) {
    var accountName by remember { mutableStateOf("") }
    var accountType by remember { mutableStateOf("") }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Add New Account") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(imageVector = Icons.Filled.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            OutlinedTextField(
                value = accountName,
                onValueChange = { accountName = it },
                label = { Text("Account Name (e.g., Savings, Credit Card)") },
                modifier = Modifier.fillMaxWidth()
            )
            OutlinedTextField(
                value = accountType,
                onValueChange = { accountType = it },
                label = { Text("Account Type (e.g., Bank, Wallet)") },
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(16.dp))
            Button(
                onClick = {
                    if (accountName.isNotBlank() && accountType.isNotBlank()) {
                        viewModel.addAccount(accountName, accountType)
                        navController.popBackStack()
                    }
                },
                modifier = Modifier.align(Alignment.End),
                enabled = accountName.isNotBlank() && accountType.isNotBlank()
            ) {
                Text("Save Account")
            }
        }
    }
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/screens/EditTransactionScreen.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.AccessTime
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.DateRange
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.DatePicker
import androidx.compose.material3.DatePickerDialog
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.ExposedDropdownMenuBox
import androidx.compose.material3.ExposedDropdownMenuDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Tab
import androidx.compose.material3.TabRow
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TimePicker
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.rememberDatePickerState
import androidx.compose.material3.rememberTimePickerState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import com.example.personalfinanceapp.Account
import com.example.personalfinanceapp.Category
import com.example.personalfinanceapp.TransactionViewModel
import com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components.TimePickerDialog
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Locale

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EditTransactionScreen(navController: NavController, viewModel: TransactionViewModel, transactionId: Int) {
    val transaction by viewModel.getTransactionById(transactionId).collectAsState(initial = null)

    var description by remember { mutableStateOf("") }
    var amount by remember { mutableStateOf("") }
    var notes by remember { mutableStateOf("") }

    var transactionType by remember { mutableStateOf("expense") }
    val transactionTypes = listOf("Expense", "Income")

    val accounts by viewModel.allAccounts.collectAsState(initial = emptyList())
    var selectedAccount by remember { mutableStateOf<Account?>(null) }
    var isAccountDropdownExpanded by remember { mutableStateOf(false) }

    val categories by viewModel.allCategories.collectAsState(initial = emptyList())
    var selectedCategory by remember { mutableStateOf<Category?>(null) }
    var isCategoryDropdownExpanded by remember { mutableStateOf(false) }

    // --- CORRECTED: Typo fixed from 'mutableState of' to 'mutableStateOf' ---
    var showDeleteDialog by remember { mutableStateOf(false) }
    var showDatePicker by remember { mutableStateOf(false) }
    var showTimePicker by remember { mutableStateOf(false) }
    val selectedDateTime = remember { Calendar.getInstance() }

    val snackbarHostState = remember { SnackbarHostState() }
    val validationError by viewModel.validationError.collectAsState()

    LaunchedEffect(validationError) {
        validationError?.let {
            snackbarHostState.showSnackbar(it)
            viewModel.clearError()
        }
    }

    LaunchedEffect(transaction, accounts, categories) {
        transaction?.let { txn ->
            description = txn.description
            amount = txn.amount.toString()
            notes = txn.notes ?: ""
            selectedDateTime.timeInMillis = txn.date
            selectedAccount = accounts.find { it.id == txn.accountId }
            selectedCategory = categories.find { it.id == txn.categoryId }
            transactionType = txn.transactionType
        }
    }

    Scaffold(
        snackbarHost = { SnackbarHost(snackbarHostState) },
        topBar = {
            TopAppBar(
                title = { Text("Edit Transaction") },
                navigationIcon = { IconButton(onClick = { navController.popBackStack() }) { Icon(
                    Icons.Filled.ArrowBack, "Back") } },
                actions = {
                    IconButton(onClick = { showDeleteDialog = true }) {
                        Icon(imageVector = Icons.Default.Delete, contentDescription = "Delete Transaction")
                    }
                }
            )
        }
    ) { innerPadding ->
        transaction?.let { currentTransaction ->
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(innerPadding),
                contentPadding = PaddingValues(16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                item {
                    TabRow(selectedTabIndex = if (transactionType == "expense") 0 else 1) {
                        transactionTypes.forEachIndexed { index, title ->
                            Tab(
                                selected = (if (transactionType == "expense") 0 else 1) == index,
                                onClick = { transactionType = if (index == 0) "expense" else "income" },
                                text = { Text(title) }
                            )
                        }
                    }
                }

                item { OutlinedTextField(value = description, onValueChange = { description = it }, label = { Text("Description") }, modifier = Modifier.fillMaxWidth()) }
                item { OutlinedTextField(value = amount, onValueChange = { amount = it }, label = { Text("Amount") }, modifier = Modifier.fillMaxWidth(), keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number)) }
                item { OutlinedTextField(value = notes, onValueChange = { notes = it }, label = { Text("Notes (Optional)") }, modifier = Modifier.fillMaxWidth()) }

                item {
                    Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                        Button(onClick = { showDatePicker = true }, modifier = Modifier.weight(1f)) {
                            Icon(imageVector = Icons.Default.DateRange, contentDescription = "Select Date")
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(text = SimpleDateFormat("dd/MM/yyyy", Locale.getDefault()).format(selectedDateTime.time))
                        }
                        Button(onClick = { showTimePicker = true }, modifier = Modifier.weight(1f)) {
                            Icon(imageVector = Icons.Default.AccessTime, contentDescription = "Select Time")
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(text = SimpleDateFormat("hh:mm a", Locale.getDefault()).format(selectedDateTime.time))
                        }
                    }
                }

                item {
                    ExposedDropdownMenuBox(expanded = isAccountDropdownExpanded, onExpandedChange = { isAccountDropdownExpanded = !isAccountDropdownExpanded }) {
                        OutlinedTextField(
                            value = selectedAccount?.name ?: "Select Account",
                            onValueChange = {}, readOnly = true, label = { Text("Account") },
                            trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = isAccountDropdownExpanded) },
                            modifier = Modifier.fillMaxWidth().menuAnchor()
                        )
                        ExposedDropdownMenu(expanded = isAccountDropdownExpanded, onDismissRequest = { isAccountDropdownExpanded = false }) {
                            accounts.forEach { account ->
                                DropdownMenuItem(text = { Text(account.name) }, onClick = {
                                    selectedAccount = account
                                    isAccountDropdownExpanded = false
                                })
                            }
                        }
                    }
                }

                item {
                    ExposedDropdownMenuBox(expanded = isCategoryDropdownExpanded, onExpandedChange = { isCategoryDropdownExpanded = !isCategoryDropdownExpanded }) {
                        OutlinedTextField(
                            value = selectedCategory?.name ?: "Select Category",
                            onValueChange = {}, readOnly = true, label = { Text("Category") },
                            trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = isCategoryDropdownExpanded) },
                            modifier = Modifier.fillMaxWidth().menuAnchor()
                        )
                        ExposedDropdownMenu(expanded = isCategoryDropdownExpanded, onDismissRequest = { isCategoryDropdownExpanded = false }) {
                            categories.forEach { category ->
                                DropdownMenuItem(text = { Text(category.name) }, onClick = {
                                    selectedCategory = category
                                    isCategoryDropdownExpanded = false
                                })
                            }
                        }
                    }
                }

                item {
                    Button(
                        onClick = {
                            val updatedAmount = amount.toDoubleOrNull() ?: 0.0
                            val updatedTransaction = currentTransaction.copy(
                                description = description,
                                amount = updatedAmount,
                                accountId = selectedAccount?.id ?: currentTransaction.accountId,
                                categoryId = selectedCategory?.id,
                                notes = notes.takeIf { it.isNotBlank() },
                                date = selectedDateTime.timeInMillis,
                                transactionType = transactionType
                            )
                            val success = viewModel.updateTransaction(updatedTransaction)
                            if (success) {
                                navController.popBackStack()
                            }
                        },
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Text("Update Transaction")
                    }
                }
            }
        }
    }

    if (showDatePicker) {
        val datePickerState = rememberDatePickerState(initialSelectedDateMillis = selectedDateTime.timeInMillis)
        DatePickerDialog(
            onDismissRequest = { showDatePicker = false },
            confirmButton = {
                TextButton(
                    onClick = {
                        datePickerState.selectedDateMillis?.let {
                            val newCalendar = Calendar.getInstance().apply { timeInMillis = it }
                            selectedDateTime.set(Calendar.YEAR, newCalendar.get(Calendar.YEAR))
                            selectedDateTime.set(Calendar.MONTH, newCalendar.get(Calendar.MONTH))
                            selectedDateTime.set(Calendar.DAY_OF_MONTH, newCalendar.get(Calendar.DAY_OF_MONTH))
                        }
                        showDatePicker = false
                    }
                ) { Text("OK") }
            },
            dismissButton = { TextButton(onClick = { showDatePicker = false }) { Text("Cancel") } }
        ) { DatePicker(state = datePickerState) }
    }

    if (showTimePicker) {
        val timePickerState = rememberTimePickerState(initialHour = selectedDateTime.get(Calendar.HOUR_OF_DAY), initialMinute = selectedDateTime.get(
            Calendar.MINUTE))
        TimePickerDialog(
            onDismissRequest = { showTimePicker = false },
            onConfirm = {
                selectedDateTime.set(Calendar.HOUR_OF_DAY, timePickerState.hour)
                selectedDateTime.set(Calendar.MINUTE, timePickerState.minute)
                showTimePicker = false
            }
        ) { TimePicker(state = timePickerState) }
    }

    if (showDeleteDialog) {
        AlertDialog(
            onDismissRequest = { showDeleteDialog = false },
            title = { Text("Confirm Deletion") },
            text = { Text("Are you sure you want to permanently delete this transaction?") },
            confirmButton = {
                Button(onClick = {
                    transaction?.let {
                        viewModel.deleteTransaction(it)
                        showDeleteDialog = false
                        navController.popBackStack()
                    }
                }) { Text("Delete") }
            },
            dismissButton = {
                TextButton(onClick = { showDeleteDialog = false }) { Text("Cancel") }
            }
        )
    }
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/screens/ReportsScreen.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.screens

import android.graphics.Color
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.example.personalfinanceapp.ReportsViewModel
import com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components.ChartLegend
import com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components.GroupedBarChart
import com.github.mikephil.charting.charts.PieChart

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ReportsScreen(navController: NavController, viewModel: ReportsViewModel = viewModel()) {
    val pieData by viewModel.spendingByCategoryPieData.collectAsState(initial = null)
    val trendDataPair by viewModel.monthlyTrendData.collectAsState(initial = null)

    Scaffold(
        topBar = { TopAppBar(title = { Text("Reports") }) }
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier.fillMaxSize().padding(innerPadding),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // --- Pie Chart Card (Unchanged) ---
            item {
                Card(modifier = Modifier.fillMaxWidth(), elevation = CardDefaults.cardElevation(4.dp)) {
                    Column(modifier = Modifier.padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally) {
                        Text("Spending by Category for ${viewModel.monthYear}", style = MaterialTheme.typography.titleLarge)
                        Spacer(modifier = Modifier.height(16.dp))
                        if (pieData == null || pieData?.entryCount == 0) {
                            Box(modifier = Modifier.fillMaxWidth().height(300.dp), contentAlignment = Alignment.Center) {
                                Text("No expense data for this month.")
                            }
                        } else {
                            AndroidView(
                                factory = { context ->
                                    PieChart(context).apply {
                                        description.isEnabled = false; isDrawHoleEnabled = true; setHoleColor(
                                        Color.TRANSPARENT); setEntryLabelColor(Color.BLACK); setEntryLabelTextSize(12f); legend.isEnabled = false
                                    }
                                },
                                update = { chart -> chart.data = pieData; chart.invalidate() },
                                modifier = Modifier.fillMaxWidth().height(300.dp)
                            )
                            Spacer(modifier = Modifier.height(16.dp))
                            ChartLegend(pieData)
                        }
                    }
                }
            }

            // --- Bar Chart Card (REFINED) ---
            item {
                Card(modifier = Modifier.fillMaxWidth(), elevation = CardDefaults.cardElevation(4.dp)) {
                    Column(modifier = Modifier.padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally) {
                        Text("Income vs. Expense Trend", style = MaterialTheme.typography.titleLarge)
                        Spacer(modifier = Modifier.height(16.dp))
                        if (trendDataPair != null && trendDataPair!!.first.entryCount > 0) {
                            // This is the refined BarChart implementation
                            GroupedBarChart(trendDataPair!!)
                        } else {
                            Box(modifier = Modifier.fillMaxWidth().height(250.dp), contentAlignment = Alignment.Center) {
                                Text("Not enough data for trend analysis.")
                            }
                        }
                    }
                }
            }
        }
    }
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/components/UtilityComponents.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import com.example.personalfinanceapp.PotentialTransaction
import com.github.mikephil.charting.charts.BarChart
import com.github.mikephil.charting.components.XAxis
import com.github.mikephil.charting.data.BarData
import com.github.mikephil.charting.data.PieData
import com.github.mikephil.charting.data.PieDataSet
import com.github.mikephil.charting.formatter.IndexAxisValueFormatter

@Composable
fun TimePickerDialog(
    title: String = "Select Time",
    onDismissRequest: () -> Unit,
    onConfirm: () -> Unit,
    content: @Composable () -> Unit,
) {
    AlertDialog(
        onDismissRequest = onDismissRequest,
        title = { Text(title) },
        text = {
            Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                content()
            }
        },
        confirmButton = {
            TextButton(onClick = onConfirm) {
                Text("OK")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismissRequest) {
                Text("Cancel")
            }
        }
    )
}

@Composable
fun ChartLegend(pieData: PieData?) {
    // Safely get the dataset from the PieData object.
    val dataSet = pieData?.dataSet as? PieDataSet ?: return

    // Use a classic for loop for maximum compatibility with the Java library.
    // This explicitly gets each entry and its corresponding color by index.
    Column {
        for (i in 0 until dataSet.entryCount) {
            val entry = dataSet.getEntryForIndex(i)
            val color = dataSet.getColor(i)

            Row(
                verticalAlignment = Alignment.CenterVertically,
                modifier = Modifier.padding(vertical = 4.dp)
            ) {
                Box(
                    modifier = Modifier
                        .size(12.dp)
                        .clip(CircleShape)
                        .background(Color(color)) // Convert the Android integer color to a Compose Color
                )
                Spacer(modifier = Modifier.width(8.dp))
                // The 'label' property of PieEntry holds the category name.
                Text(text = "${entry.label} - ${"%.2f".format(entry.value)}")
            }
        }
    }
}

@Composable
fun GroupedBarChart(trendDataPair: Pair<BarData, List<String>>) {
    val (barData, labels) = trendDataPair

    AndroidView(
        factory = { context ->
            // FACTORY: For one-time, data-independent setup
            BarChart(context).apply {
                description.isEnabled = false
                legend.isEnabled = true
                setDrawGridBackground(false)

                xAxis.position = XAxis.XAxisPosition.BOTTOM
                xAxis.setDrawGridLines(false)
                xAxis.granularity = 1f // Essential for labels to align with bars

                axisLeft.axisMinimum = 0f
                axisLeft.setDrawGridLines(true)

                axisRight.isEnabled = false
            }
        },
        update = { chart ->
            // UPDATE: For applying data and data-dependent properties

            // 1. Define the widths and spacing for the grouped bars
            val barWidth = 0.25f
            val barSpace = 0.05f
            val groupSpace = 0.4f
            barData.barWidth = barWidth

            // 2. Apply the data to the chart
            chart.data = barData

            // 3. Set the labels for the X-Axis
            chart.xAxis.valueFormatter = IndexAxisValueFormatter(labels)

            // 4. Set the visible range of the x-axis
            // This is crucial for groupBars to work correctly
            chart.xAxis.axisMinimum = 0f
            chart.xAxis.axisMaximum = labels.size.toFloat()

            // 5. Center the labels under the groups
            chart.xAxis.setCenterAxisLabels(true)

            // 6. Group the bars. The 'fromX' (first param) should be the starting point.
            chart.groupBars(0f, groupSpace, barSpace)

            // 7. Refresh the chart to apply all changes
            chart.invalidate()
        },
        modifier = Modifier
            .fillMaxWidth()
            .height(250.dp)
    )
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/components/DashboardComponents.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components

import androidx.compose.animation.core.LinearEasing
import androidx.compose.animation.core.animateFloat
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.infiniteRepeatable
import androidx.compose.animation.core.rememberInfiniteTransition
import androidx.compose.animation.core.tween
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.AccountBalanceWallet
import androidx.compose.material.icons.filled.Assessment
import androidx.compose.material.icons.filled.Category
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Divider
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.LinearProgressIndicator
import androidx.compose.material3.ListItem
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.drawscope.clipPath
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import androidx.navigation.NavGraph.Companion.findStartDestination
import com.example.personalfinanceapp.BottomNavItem
import com.example.personalfinanceapp.Budget
import com.example.personalfinanceapp.BudgetViewModel
import com.example.personalfinanceapp.BudgetWithSpending
import com.example.personalfinanceapp.TransactionDetails
import kotlinx.coroutines.flow.map
import kotlin.math.sin

private fun formatAmountCompact(amount: Float): String {
    return when {
        amount >= 1_000_000 -> "${"%.1f".format(amount / 1_000_000)}M"
        amount >= 1_000 -> "${"%.1f".format(amount / 1_000)}k"
        else -> "${"%.0f".format(amount)}"
    }
}

@Composable
fun StatCard(
    label: String,
    amount: Float,
    modifier: Modifier = Modifier,
    isPerDay: Boolean = false
) {
    Card(
        modifier = modifier,
        elevation = CardDefaults.cardElevation(2.dp)
    ) {
        Column(
            modifier = Modifier.padding(12.dp).fillMaxWidth(),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            Text(
                text = label,
                style = MaterialTheme.typography.labelMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                textAlign = TextAlign.Center
            )
            Spacer(modifier = Modifier.height(4.dp))
            // --- UPDATED: Call the top-level helper function directly ---
            Text(
                text = "${formatAmountCompact(amount)}${if (isPerDay) "/day" else ""}",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold,
                textAlign = TextAlign.Center
            )
        }
    }
}

@Composable
fun OverallBudgetCard(totalBudget: Float, amountSpent: Float) {
    if (totalBudget <= 0) {
        return
    }

    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(4.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
        ) {
            Text("Monthly Budget", style = MaterialTheme.typography.titleLarge)
            Spacer(modifier = Modifier.height(16.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.SpaceAround
            ) {
                // The Liquid Tumbler visualization
                LiquidTumbler(
                    progress = (amountSpent / totalBudget),
                    modifier = Modifier.size(120.dp)
                )

                // The text summary
                Column {
                    Text("Spent", style = MaterialTheme.typography.labelLarge)
                    Text(
                        text = "${"%.2f".format(amountSpent)}",
                        style = MaterialTheme.typography.headlineSmall,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.error
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                    Text("Remaining", style = MaterialTheme.typography.labelLarge)
                    Text(
                        text = "${"%.2f".format(totalBudget - amountSpent)}",
                        style = MaterialTheme.typography.headlineSmall,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.primary
                    )
                }
            }
        }
    }
}

// --- LiquidTumbler Composable (CORRECTED) ---
@Composable
fun LiquidTumbler(progress: Float, modifier: Modifier = Modifier) {
    val clampedProgress = progress.coerceIn(0f, 1f)

    val animatedProgress by animateFloatAsState(
        targetValue = clampedProgress,
        animationSpec = tween(durationMillis = 1000, easing = LinearEasing),
        label = "LiquidFillAnimation"
    )

    val infiniteTransition = rememberInfiniteTransition(label = "WaveAnimation")
    val waveOffset by infiniteTransition.animateFloat(
        initialValue = 0f,
        targetValue = 2f,
        animationSpec = infiniteRepeatable(
            animation = tween(durationMillis = 1500, easing = LinearEasing)
        ), label = "WaveOffset"
    )

    // --- CORRECTED: Resolve colors and pixel values in the Composable context ---
    val waterColor = when {
        clampedProgress >= 1f -> MaterialTheme.colorScheme.error
        clampedProgress > 0.8f -> Color(0xFFFBC02D) // Amber
        else -> MaterialTheme.colorScheme.primary
    }
    val glassColor = MaterialTheme.colorScheme.onSurfaceVariant
    val strokeWidthPx = with(LocalDensity.current) { 4.dp.toPx() }


    Box(
        contentAlignment = Alignment.Center,
        modifier = modifier
    ) {
        Canvas(modifier = Modifier.fillMaxSize()) {
            val width = size.width
            val height = size.height

            val glassPath = Path().apply {
                moveTo(width * 0.1f, height * 0.05f)
                lineTo(width * 0.2f, height * 0.95f)
                quadraticBezierTo(width * 0.5f, height * 1.05f, width * 0.8f, height * 0.95f)
                lineTo(width * 0.9f, height * 0.05f)
                close()
            }

            // --- CORRECTED: Use the pre-resolved values ---
            drawPath(
                path = glassPath,
                color = glassColor,
                style = Stroke(width = strokeWidthPx)
            )

            clipPath(glassPath) {
                drawRect(
                    brush = Brush.verticalGradient(
                        colors = listOf(waterColor.copy(alpha = 0.5f), waterColor),
                        startY = height * (1 - animatedProgress),
                        endY = height
                    ),
                    topLeft = Offset(0f, height * (1 - animatedProgress)),
                    size = size
                )

                val wavePath = Path().apply {
                    moveTo(-width, height * (1 - animatedProgress))
                    for (i in 0..width.toInt() * 2) {
                        lineTo(
                            i.toFloat(),
                            height * (1 - animatedProgress) + sin((i * 0.03f) + (waveOffset * Math.PI.toFloat())) * 5f
                        )
                    }
                    lineTo(width * 2, height)
                    lineTo(-width, height)
                    close()
                }
                drawPath(path = wavePath, color = waterColor)
            }
        }
        Text(
            text = "${(clampedProgress * 100).toInt()}%",
            color = MaterialTheme.colorScheme.onSurface,
            fontSize = 24.sp,
            fontWeight = FontWeight.Bold
        )
    }
}

// --- NEW: Composable to host the MPAndroidChart PieChart ---
//@Composable
//fun BudgetPieChart(totalBudget: Float, amountSpent: Float) {
//    val remaining = totalBudget - amountSpent
//    val percentageSpent = if (totalBudget > 0) (amountSpent / totalBudget) * 100 else 0f
//
//    val spentColor = MaterialTheme.colorScheme.error.toArgb()
//    val remainingColor = MaterialTheme.colorScheme.primaryContainer.toArgb()
//
//    // --- CORRECTED: Get the color in the Composable context ---
//    val centerTextColor = MaterialTheme.colorScheme.onSurface.toArgb()
//
//    AndroidView(
//        factory = { context ->
//            PieChart(context).apply {
//                description.isEnabled = false
//                legend.isEnabled = false
//                isDrawHoleEnabled = true
//                setHoleColor(AndroidColor.TRANSPARENT)
//                setUsePercentValues(true)
//                setEntryLabelColor(AndroidColor.BLACK)
//                setEntryLabelTypeface(Typeface.DEFAULT_BOLD)
//            }
//        },
//        update = { chart ->
//            val entries = mutableListOf<PieEntry>()
//            if (amountSpent > 0) {
//                entries.add(PieEntry(amountSpent, "Spent"))
//            }
//            if (remaining > 0) {
//                entries.add(PieEntry(remaining, "Remaining"))
//            }
//
//            val dataSet = PieDataSet(entries, "Budget").apply {
//                colors = listOf(spentColor, remainingColor)
//                setDrawValues(false)
//            }
//
//            chart.data = PieData(dataSet)
//
//            chart.centerText = "%.1f%%".format(percentageSpent)
//            chart.setCenterTextSize(24f)
//            chart.setCenterTextTypeface(Typeface.DEFAULT_BOLD)
//            // --- CORRECTED: Use the color variable here ---
//            chart.setCenterTextColor(centerTextColor)
//
//            chart.invalidate()
//        },
//        modifier = Modifier.fillMaxSize()
//    )
//}

@Composable
fun NetWorthCard(netWorth: Double) {
    Card(elevation = CardDefaults.cardElevation(4.dp), modifier = Modifier.fillMaxWidth()) {
        Column(modifier = Modifier.padding(16.dp)) {
            Text("Net Worth", style = MaterialTheme.typography.titleMedium)
            Text(
                text = "${"%.2f".format(netWorth)}",
                style = MaterialTheme.typography.displaySmall,
                fontWeight = FontWeight.Bold
            )
        }
    }
}

@Composable
fun RecentActivityCard(transactions: List<TransactionDetails>, navController: NavController) {
    Card(elevation = CardDefaults.cardElevation(4.dp), modifier = Modifier.fillMaxWidth()) {
        Column(modifier = Modifier.padding(16.dp)) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Text("Recent Transactions", style = MaterialTheme.typography.titleMedium, modifier = Modifier.weight(1f))
                TextButton(
                    onClick = {
                        // --- CORRECTED: Use the same navigation logic as the bottom bar ---
                        navController.navigate(BottomNavItem.Transactions.route) {
                            popUpTo(navController.graph.findStartDestination().id) { saveState = true }
                            launchSingleTop = true
                            restoreState = true
                        }
                    }
                ) { Text("View All") }
            }
            Spacer(modifier = Modifier.height(8.dp))
            if(transactions.isEmpty()){
                Text("No transactions yet.", modifier = Modifier.padding(vertical = 16.dp))
            } else {
                transactions.forEach { details ->
                    TransactionItem(transactionDetails = details) {
                        // This navigation is correct as it's a detail screen, not a main tab
                        navController.navigate("edit_transaction/${details.transaction.id}")
                    }
                }
            }
        }
    }
}

@Composable
fun BudgetWatchCard(budgetStatus: List<BudgetWithSpending>, viewModel: BudgetViewModel) {
    Card(elevation = CardDefaults.cardElevation(4.dp), modifier = Modifier.fillMaxWidth()) {
        Column(modifier = Modifier.padding(16.dp)) {
            Text("Budget Watch", style = MaterialTheme.typography.titleMedium)
            Spacer(modifier = Modifier.height(8.dp))
            if (budgetStatus.isEmpty()) {
                Text("No budgets set for this month.", style = MaterialTheme.typography.bodyMedium)
            } else {
                budgetStatus.forEach { budgetWithSpendingItem ->
                    BudgetItem(budget = budgetWithSpendingItem.budget, viewModel = viewModel)
                }
            }
        }
    }
}

@Composable
fun BudgetItem(budget: Budget, viewModel: BudgetViewModel) {
    val spendingFlow = remember(budget.categoryName) {
        viewModel.getActualSpending(budget.categoryName).map { spending ->
            Math.abs(spending ?: 0.0)
        }
    }
    val actualSpending by spendingFlow.collectAsState(initial = 0.0)

    val progress = if (budget.amount > 0) (actualSpending / budget.amount).toFloat() else 0f
    val amountRemaining = budget.amount - actualSpending

    val progressColor = when {
        progress > 1f -> MaterialTheme.colorScheme.error
        progress > 0.8f -> Color(0xFFFBC02D) // Amber
        else -> MaterialTheme.colorScheme.primary
    }

    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(2.dp)
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Row(modifier = Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
                Text(
                    text = budget.categoryName,
                    style = MaterialTheme.typography.titleLarge,
                    modifier = Modifier.weight(1f)
                )
                Text(
                    text = "${"%.2f".format(budget.amount)}",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.secondary
                )
            }
            Spacer(modifier = Modifier.height(12.dp))
            LinearProgressIndicator(
                progress = { progress },
                modifier = Modifier.fillMaxWidth().height(8.dp),
                color = progressColor
            )
            Spacer(modifier = Modifier.height(8.dp))
            Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
                Text(
                    text = "Spent: ${"%.2f".format(actualSpending)}",
                    style = MaterialTheme.typography.bodyMedium
                )
                Text(
                    text = "Remaining: ${"%.2f".format(amountRemaining)}",
                    style = MaterialTheme.typography.bodyMedium,
                    color = if (amountRemaining < 0) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.onSurface
                )
            }
        }
    }
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/components/TransactionItem.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Card
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontStyle
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import com.example.personalfinanceapp.Transaction
import com.example.personalfinanceapp.TransactionDetails
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun TransactionItem(transactionDetails: TransactionDetails, onClick: () -> Unit) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        onClick = onClick
    ) {
        Row(modifier = Modifier.padding(16.dp), verticalAlignment = Alignment.CenterVertically) {
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = transactionDetails.transaction.description,
                    style = MaterialTheme.typography.bodyLarge,
                    fontWeight = FontWeight.Bold
                )
                if (!transactionDetails.transaction.notes.isNullOrBlank()) {
                    Text(
                        text = transactionDetails.transaction.notes!!,
                        style = MaterialTheme.typography.bodyMedium,
                        fontStyle = FontStyle.Italic,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
                Text(
                    text = "${transactionDetails.categoryName ?: "Uncategorized"}  ${transactionDetails.accountName ?: "Unknown"}",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.secondary
                )
                Text(
                    text = SimpleDateFormat("dd MMM yy, h:mm a", Locale.getDefault()).format(Date(transactionDetails.transaction.date)),
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            Text(
                text = "${"%.2f".format(transactionDetails.transaction.amount)}",
                style = MaterialTheme.typography.bodyLarge,
                fontWeight = FontWeight.SemiBold,
                color = if (transactionDetails.transaction.transactionType == "expense") MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary
            )
        }
    }
}

@Composable
fun AccountTransactionItem(transaction: Transaction) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 12.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Text(text = transaction.description, style = MaterialTheme.typography.bodyLarge)
            Text(
                text = SimpleDateFormat("dd MMM yy", Locale.getDefault()).format(Date(transaction.date)),
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
        Text(
            text = "${"%.2f".format(transaction.amount)}",
            style = MaterialTheme.typography.bodyLarge,
            color = if (transaction.transactionType == "expense") MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary
        )
    }
}

@Composable
fun TransactionList(transactions: List<TransactionDetails>, navController: NavController) {
    if (transactions.isEmpty()) {
        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            Text("No transactions yet. Add one!")
        }
    } else {
        LazyColumn(modifier = Modifier.fillMaxSize(), contentPadding = PaddingValues(16.dp)) {
            items(transactions) { details ->
                TransactionItem(transactionDetails = details, onClick = {
                    navController.navigate("edit_transaction/${details.transaction.id}")
                })
            }
        }
    }
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/components/CategoryDialogs.kt ==================
package com.example.personalfinanceapp.com.example.personalfinanceapp.ui.components

import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import com.example.personalfinanceapp.Category

@Composable
fun EditCategoryDialog(
    category: Category,
    onDismiss: () -> Unit,
    onConfirm: (Category) -> Unit
) {
    var updatedName by remember { mutableStateOf(category.name) }

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Edit Category") },
        text = {
            OutlinedTextField(
                value = updatedName,
                onValueChange = { updatedName = it },
                label = { Text("Category Name") }
            )
        },
        confirmButton = {
            Button(
                onClick = {
                    if (updatedName.isNotBlank()) {
                        onConfirm(category.copy(name = updatedName))
                    }
                },
                enabled = updatedName.isNotBlank()
            ) {
                Text("Update")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        }
    )
}

@Composable
fun DeleteCategoryDialog(
    category: Category,
    onDismiss: () -> Unit,
    onConfirm: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Delete Category") },
        text = { Text("Are you sure you want to delete the category '${category.name}'? This cannot be undone.") },
        confirmButton = {
            Button(
                onClick = onConfirm,
                colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
            ) {
                Text("Delete")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        }
    )
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/theme/Color.kt ==================
package com.example.personalfinanceapp.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/theme/Theme.kt ==================
package com.example.personalfinanceapp.ui.theme

import android.app.Activity
import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.platform.LocalContext

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40

    /* Other default colors to override
    background = Color(0xFFFFFBFE),
    surface = Color(0xFFFFFBFE),
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color(0xFF1C1B1F),
    onSurface = Color(0xFF1C1B1F),
    */
)

@Composable
fun PersonalFinanceAppTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/ui/theme/Type.kt ==================
package com.example.personalfinanceapp.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
    /* Other default text styles to override
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
    */
)-e 


================== FILE: ./app/src/main/java/com/example/personalfinanceapp/MainActivity.kt ==================
package com.example.personalfinanceapp

import android.Manifest
import android.content.pm.PackageManager
import android.os.Bundle
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.biometric.BiometricPrompt
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.core.content.ContextCompat
import androidx.fragment.app.FragmentActivity
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import androidx.navigation.NavDestination.Companion.hierarchy
import androidx.navigation.NavGraph.Companion.findStartDestination
import androidx.navigation.NavType
import androidx.navigation.compose.*
import androidx.navigation.navArgument
import androidx.navigation.navDeepLink
import com.example.personalfinanceapp.com.example.personalfinanceapp.ui.screens.*
import com.example.personalfinanceapp.ui.theme.PersonalFinanceAppTheme
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import java.net.URLDecoder
import java.util.concurrent.Executor

// --- Navigation Destinations ---
sealed class BottomNavItem(val route: String, val icon: ImageVector, val label: String) {
    object Dashboard : BottomNavItem("dashboard", Icons.Filled.Home, "Dashboard")
    object Transactions : BottomNavItem("transaction_list", Icons.Filled.Receipt, "History")
    object Reports : BottomNavItem("reports_screen", Icons.Filled.Assessment, "Reports")
    object Settings : BottomNavItem("settings_screen", Icons.Filled.Settings, "Settings")
}

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()

        val settingsRepository = SettingsRepository(this)
        val initialLockStatus = settingsRepository.isAppLockEnabledBlocking()

        setContent {
            PersonalFinanceAppTheme {
                FinanceAppWithLockScreen(isInitiallyLocked = initialLockStatus)
            }
        }
    }
}

@Composable
fun FinanceAppWithLockScreen(isInitiallyLocked: Boolean) {
    val context = LocalContext.current
    val settingsRepository = remember { SettingsRepository(context) }

    var isLocked by remember { mutableStateOf(isInitiallyLocked) }
    val appLockEnabled by settingsRepository.getAppLockEnabled().collectAsState(initial = isInitiallyLocked)

    // --- PERMISSION ONBOARDING LOGIC ---
    val permissionsToRequest = arrayOf(
        Manifest.permission.READ_SMS,
        Manifest.permission.RECEIVE_SMS,
        Manifest.permission.POST_NOTIFICATIONS
    )
    val permissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestMultiplePermissions()
    ) { perms ->
        val allPermissionsGranted = perms.all { it.value }
        if (!allPermissionsGranted) {
            Toast.makeText(context, "Some permissions were denied. The app may not function fully.", Toast.LENGTH_LONG).show()
        }
    }

    // Check for permissions on the first launch
    LaunchedEffect(key1 = true) {
        val areAllPermissionsGranted = permissionsToRequest.all {
            ContextCompat.checkSelfPermission(context, it) == PackageManager.PERMISSION_GRANTED
        }
        if (!areAllPermissionsGranted) {
            permissionLauncher.launch(permissionsToRequest)
        }
    }
    // --- END PERMISSION LOGIC ---

    LaunchedEffect(appLockEnabled) {
        if (!appLockEnabled) {
            isLocked = false
        }
    }

    if (isLocked) {
        LockScreen(onUnlock = { isLocked = false })
    } else {
        FinanceApp()
    }
}


@Composable
fun LockScreen(onUnlock: () -> Unit) {
    val context = LocalContext.current
    val activity = LocalContext.current as FragmentActivity
    val executor: Executor = remember { ContextCompat.getMainExecutor(context) }

    val promptInfo = remember {
        BiometricPrompt.PromptInfo.Builder()
            .setTitle("App Locked")
            .setSubtitle("Authenticate to access your finances")
            .setNegativeButtonText("Cancel")
            .build()
    }

    val biometricPrompt = remember {
        BiometricPrompt(activity, executor,
            object : BiometricPrompt.AuthenticationCallback() {
                override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {
                    super.onAuthenticationSucceeded(result)
                    onUnlock()
                }

                override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {
                    super.onAuthenticationError(errorCode, errString)
                    if (errorCode != BiometricPrompt.ERROR_NEGATIVE_BUTTON && errorCode != BiometricPrompt.ERROR_USER_CANCELED) {
                        Toast.makeText(context, "Authentication error: $errString", Toast.LENGTH_SHORT).show()
                    }
                }

                override fun onAuthenticationFailed() {
                    super.onAuthenticationFailed()
                    Toast.makeText(context, "Authentication failed", Toast.LENGTH_SHORT).show()
                }
            })
    }

    LaunchedEffect(Unit) {
        biometricPrompt.authenticate(promptInfo)
    }

    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Button(onClick = { biometricPrompt.authenticate(promptInfo) }) {
            Icon(Icons.Default.Fingerprint, contentDescription = null, modifier = Modifier.size(24.dp))
            Spacer(Modifier.width(8.dp))
            Text("Unlock App")
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun FinanceApp() {
    val navController = rememberNavController()
    val bottomNavItems = listOf(
        BottomNavItem.Dashboard,
        BottomNavItem.Transactions,
        BottomNavItem.Reports,
        BottomNavItem.Settings
    )

    Scaffold(
        bottomBar = {
            NavigationBar {
                val navBackStackEntry by navController.currentBackStackEntryAsState()
                val currentDestination = navBackStackEntry?.destination
                bottomNavItems.forEach { screen ->
                    NavigationBarItem(
                        icon = { Icon(screen.icon, contentDescription = screen.label) },
                        label = { Text(screen.label) },
                        selected = currentDestination?.hierarchy?.any { it.route == screen.route } == true,
                        onClick = {
                            navController.navigate(screen.route) {
                                popUpTo(navController.graph.findStartDestination().id) { saveState = true }
                                launchSingleTop = true
                                restoreState = true
                            }
                        }
                    )
                }
            }
        }
    ) { innerPadding ->
        NavHost(
            navController = navController,
            startDestination = BottomNavItem.Dashboard.route,
            modifier = Modifier.padding(innerPadding)
        ) {
            composable(BottomNavItem.Dashboard.route) { DashboardScreen(navController, viewModel(), viewModel()) }
            composable(BottomNavItem.Transactions.route) { TransactionListScreen(navController, viewModel()) }
            composable(BottomNavItem.Reports.route) { ReportsScreen(navController, viewModel()) }
            composable(BottomNavItem.Settings.route) { SettingsScreen(navController, viewModel()) }
            composable("search_screen") { SearchScreen(navController) }

            // --- UPDATED: Added deep link to the review screen ---
            composable(
                route = "review_sms_screen",
                deepLinks = listOf(navDeepLink { uriPattern = "app://personalfinanceapp.example.com/review_sms" })
            ) { ReviewSmsScreen(navController, viewModel()) }

            composable("sms_debug_screen") { SmsDebugScreen(navController, viewModel()) }
            composable(
                route = "approve_transaction_screen/{amount}/{type}/{merchant}/{smsId}/{smsSender}",
                arguments = listOf(
                    navArgument("amount") { type = NavType.FloatType },
                    navArgument("type") { type = NavType.StringType },
                    navArgument("merchant") { type = NavType.StringType },
                    navArgument("smsId") { type = NavType.LongType },
                    navArgument("smsSender") { type = NavType.StringType }
                ),
                deepLinks = listOf(navDeepLink { uriPattern = "app://personalfinanceapp.example.com/approve?amount={amount}&type={type}&merchant={merchant}&smsId={smsId}&smsSender={smsSender}" })
            ) { backStackEntry ->
                val arguments = requireNotNull(backStackEntry.arguments)
                ApproveTransactionScreen(
                    navController = navController,
                    amount = arguments.getFloat("amount"),
                    transactionType = arguments.getString("type") ?: "expense",
                    merchant = URLDecoder.decode(arguments.getString("merchant") ?: "Unknown", "UTF-8"),
                    smsId = arguments.getLong("smsId"),
                    smsSender = arguments.getString("smsSender") ?: ""
                )
            }
            composable("add_transaction") { AddTransactionScreen(navController, viewModel()) }
            composable("edit_transaction/{transactionId}", arguments = listOf(navArgument("transactionId") { type = NavType.IntType })) { backStackEntry ->
                val transactionId = backStackEntry.arguments?.getInt("transactionId")
                if (transactionId != null) { EditTransactionScreen(navController, viewModel(), transactionId) }
            }
            composable("account_list") { AccountListScreen(navController, viewModel()) }
            composable("add_account") { AddAccountScreen(navController, viewModel()) }
            composable("edit_account/{accountId}", arguments = listOf(navArgument("accountId") { type = NavType.IntType })) { backStackEntry ->
                val accountId = backStackEntry.arguments?.getInt("accountId")
                if (accountId != null) { EditAccountScreen(navController, viewModel(), accountId) }
            }
            composable("account_detail/{accountId}", arguments = listOf(navArgument("accountId") { type = NavType.IntType })) { backStackEntry ->
                val accountId = backStackEntry.arguments?.getInt("accountId")
                if (accountId != null) { AccountDetailScreen(navController, viewModel(), accountId) }
            }
            composable("budget_screen") { BudgetScreen(navController, viewModel()) }
            composable("recurring_transactions") { RecurringTransactionScreen(navController) }
            composable("add_recurring_transaction") { AddRecurringTransactionScreen(navController) }
            composable("add_budget") { AddBudgetScreen(navController, viewModel()) }
            composable("category_list") { CategoryListScreen(navController, viewModel()) }
            composable("edit_category/{categoryId}", arguments = listOf(navArgument("categoryId") { type = NavType.IntType })) { backStackEntry ->
                val categoryId = backStackEntry.arguments?.getInt("categoryId")
                if (categoryId != null) { EditCategoryScreen(navController, viewModel(), categoryId) }
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/TransactionRepository.kt ==================
package com.example.personalfinanceapp

import kotlinx.coroutines.flow.Flow

class TransactionRepository(private val transactionDao: TransactionDao) {

    val allTransactions: Flow<List<TransactionDetails>> = transactionDao.getAllTransactions()

    // --- NEW: Expose the new DAO method to the ViewModel layer ---
    fun getTransactionsForAccountDetails(accountId: Int): Flow<List<TransactionDetails>> {
        return transactionDao.getTransactionsForAccountDetails(accountId)
    }

    fun getTransactionDetailsForRange(startDate: Long, endDate: Long): Flow<List<TransactionDetails>> {
        return transactionDao.getTransactionDetailsForRange(startDate, endDate)
    }

    fun getAllTransactionsSimple(): Flow<List<Transaction>> {
        return transactionDao.getAllTransactionsSimple()
    }

    fun getAllTransactionsForRange(startDate: Long, endDate: Long): Flow<List<Transaction>> {
        return transactionDao.getAllTransactionsForRange(startDate, endDate)
    }

    fun getTransactionById(id: Int): Flow<Transaction?> {
        return transactionDao.getTransactionById(id)
    }

    fun getTransactionsForAccount(accountId: Int): Flow<List<Transaction>> {
        return transactionDao.getTransactionsForAccount(accountId)
    }

    fun getSpendingForCategory(categoryName: String, startDate: Long, endDate: Long): Flow<Double?> {
        return transactionDao.getSpendingForCategory(categoryName, startDate, endDate)
    }

    fun getSpendingByCategoryForMonth(startDate: Long, endDate: Long): Flow<List<CategorySpending>> {
        return transactionDao.getSpendingByCategoryForMonth(startDate, endDate)
    }
    fun getMonthlyTrends(startDate: Long): Flow<List<MonthlyTrend>> {
        return transactionDao.getMonthlyTrends(startDate)
    }

    suspend fun countTransactionsForCategory(categoryId: Int): Int {
        return transactionDao.countTransactionsForCategory(categoryId)
    }

    suspend fun insert(transaction: Transaction) {
        transactionDao.insert(transaction)
    }

    suspend fun update(transaction: Transaction) {
        transactionDao.update(transaction)
    }

    suspend fun delete(transaction: Transaction) {
        transactionDao.delete(transaction)
    }
}
-e 


================== FILE: ./app/src/main/java/DashboardViewModel.kt ==================
package com.example.personalfinanceapp

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import java.util.Calendar

class DashboardViewModel(application: Application) : AndroidViewModel(application) {

    private val transactionRepository: TransactionRepository
    private val accountRepository: AccountRepository
    private val budgetDao: BudgetDao
    private val settingsRepository: SettingsRepository

    val netWorth: StateFlow<Double>
    val monthlyIncome: StateFlow<Double>
    val monthlyExpenses: StateFlow<Double>
    val recentTransactions: StateFlow<List<TransactionDetails>>
    val budgetStatus: StateFlow<List<BudgetWithSpending>>
    val overallMonthlyBudget: StateFlow<Float>
    val amountRemaining: StateFlow<Float>
    // --- NEW: StateFlow for the "Safe to Spend" metric ---
    val safeToSpendPerDay: StateFlow<Float>

    init {
        val db = AppDatabase.getInstance(application)
        transactionRepository = TransactionRepository(db.transactionDao())
        accountRepository = AccountRepository(db.accountDao())
        budgetDao = db.budgetDao()
        settingsRepository = SettingsRepository(application)

        val calendar = Calendar.getInstance()
        val monthStart = calendar.apply {
            set(Calendar.DAY_OF_MONTH, 1)
            set(Calendar.HOUR_OF_DAY, 0)
            set(Calendar.MINUTE, 0)
            set(Calendar.SECOND, 0)
            set(Calendar.MILLISECOND, 0)
        }.timeInMillis
        val monthEnd = calendar.apply {
            add(Calendar.MONTH, 1)
            set(Calendar.DAY_OF_MONTH, 1)
            add(Calendar.DAY_OF_MONTH, -1)
            set(Calendar.HOUR_OF_DAY, 23)
            set(Calendar.MINUTE, 59)
            set(Calendar.SECOND, 59)
            set(Calendar.MILLISECOND, 999)
        }.timeInMillis

        val transactionsThisMonth = transactionRepository.getTransactionDetailsForRange(monthStart, monthEnd)

        monthlyIncome = transactionsThisMonth.map { transactions ->
            transactions
                .filter { it.transaction.transactionType == "income" }
                .sumOf { it.transaction.amount }
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0.0)

        monthlyExpenses = transactionsThisMonth.map { transactions ->
            transactions
                .filter { it.transaction.transactionType == "expense" }
                .sumOf { it.transaction.amount }
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0.0)

        overallMonthlyBudget = settingsRepository.getOverallBudgetForCurrentMonth()
            .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0f)

        amountRemaining = combine(overallMonthlyBudget, monthlyExpenses) { budget, expenses ->
            budget - expenses.toFloat()
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0f)

        // --- NEW: "Safe to Spend" Calculation Logic ---
        safeToSpendPerDay = combine(amountRemaining) { (remaining) ->
            val today = Calendar.getInstance()
            val lastDayOfMonth = today.getActualMaximum(Calendar.DAY_OF_MONTH)
            val remainingDays = (lastDayOfMonth - today.get(Calendar.DAY_OF_MONTH) + 1).coerceAtLeast(1)

            if (remaining > 0) remaining / remainingDays else 0f
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0f)


        netWorth = accountRepository.accountsWithBalance.map { list ->
            list.sumOf { it.balance }
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0.0)

        recentTransactions = transactionRepository.allTransactions.map { it.take(5) }
            .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

        val currentMonth = Calendar.getInstance().get(Calendar.MONTH) + 1
        val currentYear = Calendar.getInstance().get(Calendar.YEAR)
        val budgets = budgetDao.getBudgetsForMonth(currentMonth, currentYear)

        budgetStatus = budgets.combine(transactionRepository.allTransactions) { budgetList, allTransactions ->
            budgetList.map { budget ->
                val spending = allTransactions
                    .filter { it.categoryName == budget.categoryName }
                    .filter { it.transaction.transactionType == "expense" }
                    .filter {
                        val cal = Calendar.getInstance().apply { timeInMillis = it.transaction.date }
                        cal.get(Calendar.MONTH) + 1 == currentMonth && cal.get(Calendar.YEAR) == currentYear
                    }
                    .sumOf { it.transaction.amount }

                BudgetWithSpending(budget = budget, spent = spending)
            }
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())
    }
}
-e 


