Project Context for Personal Finance App
Generated on: Wed Jul 16 11:08:44 IST 2025
========================================

================== FILE: ./app/build.gradle.kts ==================
import java.util.Properties
import java.io.FileInputStream

// It's good practice to define versions in one place.
val roomVersion = "2.6.1"
val lifecycleVersion = "2.8.2"
val activityComposeVersion = "1.9.0"
val coreKtxVersion = "1.13.1"
val navigationVersion = "2.7.7"
val androidxTestVersion = "1.6.1"
val testExtJunitVersion = "1.2.1"
val espressoVersion = "3.6.1"
val tracingVersion = "1.2.0"
val workVersion = "2.9.0"
val robolectricVersion = "4.13"
val coroutinesTestVersion = "1.8.1"
val gsonVersion = "2.10.1"
val coilVersion = "2.6.0"
// --- NEW: Add Image Cropper library version ---
val imageCropperVersion = "4.5.0"

// Read properties from local.properties
val keystorePropertiesFile = rootProject.file("local.properties")
val keystoreProperties = Properties()
if (keystorePropertiesFile.exists()) {
    keystoreProperties.load(FileInputStream(keystorePropertiesFile))
}


plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("com.google.devtools.ksp")
    id("org.jetbrains.kotlin.plugin.compose")
    id("org.jetbrains.kotlin.plugin.serialization")
    id("org.jlleitschuh.gradle.ktlint") version "12.1.1"
}

android {
    namespace = "io.pm.finlight"
    compileSdk = 35

    signingConfigs {
        create("release") {
            keyAlias = keystoreProperties["key.alias"] as String?
            keyPassword = keystoreProperties["key.password"] as String?
            storeFile = keystoreProperties["keystore.path"]?.let { rootProject.file(it) }
            storePassword = keystoreProperties["keystore.password"] as String?
        }
    }

    defaultConfig {
        applicationId = "io.pm.finlight"
        minSdk = 24
        targetSdk = 35
        versionCode = 1
        versionName = "1.0"
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
        ksp {
            arg("room.schemaLocation", "$projectDir/schemas")
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro",
            )
            signingConfig = signingConfigs.getByName("release")
        }
        // --- NEW: Explicitly define the debug build type ---
        // This ensures that the App Inspector can connect to your app to view
        // databases, background workers, and other debug information.
        debug {
            isDebuggable = true
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = "17"
    }
    buildFeatures {
        compose = true
    }
    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }
    testOptions {
        unitTests {
            isIncludeAndroidResources = true
            // --- FIX: Return default values for Android framework methods in unit tests ---
            isReturnDefaultValues = true
        }
    }
}

configurations.all {
    resolutionStrategy {
        force("androidx.core:core-ktx:$coreKtxVersion")
        force("androidx.core:core:$coreKtxVersion")
        force("androidx.tracing:tracing-ktx:$tracingVersion")
    }
}

dependencies {
    implementation("androidx.core:core-ktx:$coreKtxVersion")
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:$lifecycleVersion")
    implementation("androidx.activity:activity-compose:$activityComposeVersion")

    implementation(platform("androidx.compose:compose-bom:2024.06.00"))
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-graphics")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")
    implementation("androidx.compose.material:material-icons-extended")
    implementation("androidx.compose.runtime:runtime-livedata")

    implementation("androidx.room:room-runtime:$roomVersion")
    implementation("androidx.room:room-ktx:$roomVersion")
    implementation("androidx.appcompat:appcompat:1.7.1")
    implementation("com.google.firebase:firebase-crashlytics-buildtools:3.0.4")
    ksp("androidx.room:room-compiler:$roomVersion")

    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:$lifecycleVersion")
    implementation("androidx.navigation:navigation-compose:$navigationVersion")

    implementation("com.google.android.material:material:1.12.0")

    implementation("com.github.PhilJay:MPAndroidChart:v3.1.0")

    implementation("com.google.code.gson:gson:$gsonVersion")

    implementation("androidx.tracing:tracing-ktx:$tracingVersion")

    implementation("io.coil-kt:coil-compose:$coilVersion")

    implementation("com.vanniktech:android-image-cropper:$imageCropperVersion")

    // Local unit tests
    testImplementation("junit:junit:4.13.2")
    testImplementation("org.mockito:mockito-inline:5.2.0")
    testImplementation("androidx.test:core-ktx:$androidxTestVersion")
    testImplementation("androidx.test.ext:junit:$testExtJunitVersion")
    testImplementation("org.robolectric:robolectric:$robolectricVersion")
    testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:$coroutinesTestVersion")
    testImplementation("androidx.arch.core:core-testing:2.2.0")

    // Instrumented UI tests
    androidTestImplementation("androidx.tracing:tracing-ktx:$tracingVersion")
    androidTestImplementation("androidx.test:runner:$androidxTestVersion")
    androidTestImplementation("androidx.test:core-ktx:$androidxTestVersion")
    androidTestImplementation("androidx.test.ext:junit-ktx:$testExtJunitVersion")
    androidTestImplementation("androidx.test:rules:$androidxTestVersion")
    androidTestImplementation("androidx.test.espresso:espresso-core:$espressoVersion")
    androidTestImplementation(platform("androidx.compose:compose-bom:2024.06.00"))
    androidTestImplementation("androidx.compose.ui:ui-test-junit4")

    // Debug dependencies
    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")

    implementation("androidx.biometric:biometric:1.2.0-alpha05")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3")
    implementation("androidx.work:work-runtime-ktx:$workVersion")
}



================== FILE: ./app/src/main/AndroidManifest.xml ==================
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-feature
        android:name="android.hardware.telephony"
        android:required="false" />
    <uses-feature
        android:name="android.hardware.camera"
        android:required="false" />

    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.READ_SMS" />
    <uses-permission android:name="android.permission.RECEIVE_SMS" />
    <uses-permission android:name="android.permission.USE_BIOMETRIC" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />


    <application
        android:name=".MainApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.PersonalFinanceApp"
        tools:targetApi="33"
        android:enableOnBackInvokedCallback="true">

        <!--
        // =================================================================================
        // BACKUP CONFIGURATION:
        // android:allowBackup="true" -> Enables the app to participate in the backup/restore infrastructure.
        // android:dataExtractionRules="@xml/data_extraction_rules" -> Points to our custom rules file.
        // android:fullBackupContent="true" -> Required for apps targeting API 31+ to enable Auto Backup.
        // =================================================================================
        -->

        <meta-data
            android:name="com.google.firebase.messaging.default_notification_icon"
            android:resource="@drawable/ic_launcher_foreground" />

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:label="@string/app_name"
            android:launchMode="singleTop"
            android:theme="@style/Theme.PersonalFinanceApp">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />
                <data
                    android:host="finlight.pm.io"
                    android:scheme="app" />
            </intent-filter>
        </activity>

        <receiver
            android:name=".SmsReceiver"
            android:exported="true"
            android:permission="android.permission.BROADCAST_SMS">
            <intent-filter android:priority="999">
                <action android:name="android.provider.Telephony.SMS_RECEIVED" />
            </intent-filter>
        </receiver>

        <receiver
            android:name=".BootReceiver"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>

        <activity
            android:name="com.canhub.cropper.CropImageActivity"
            android:theme="@style/Theme.AppCompat.DayNight"
            />

        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.provider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_paths" />
        </provider>

    </application>

</manifest>



---------- Main Source Files ----------
================== FILE: ./app/src/main/java/RuleCreationViewModel.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/RuleCreationViewModel.kt
// REASON: FEATURE - The ViewModel now fully supports "edit mode". A new
// `loadRuleForEditing` function fetches an existing rule by its ID and populates
// the UI state. The `saveRule` logic is updated to check for an active rule ID
// and calls the DAO's `update` function instead of `insert`, completing the
// feature's data flow.
// =================================================================================
package io.pm.finlight

import android.app.Application
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.firstOrNull
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import java.util.regex.Pattern

/**
 * Data class to hold the state of a user's selection for a custom rule.
 */
data class RuleSelection(
    val selectedText: String = "",
    val startIndex: Int = -1,
    val endIndex: Int = -1
)

/**
 * UI state for the RuleCreationScreen.
 */
data class RuleCreationUiState(
    val triggerSelection: RuleSelection = RuleSelection(),
    val merchantSelection: RuleSelection = RuleSelection(),
    val amountSelection: RuleSelection = RuleSelection(),
    val accountSelection: RuleSelection = RuleSelection(),
    val transactionType: String? = null,
    val ruleIdToEdit: Int? = null // --- NEW: Track the ID of the rule being edited
)

/**
 * ViewModel for the RuleCreationScreen.
 */
class RuleCreationViewModel(application: Application) : AndroidViewModel(application) {

    private val _uiState = MutableStateFlow(RuleCreationUiState())
    val uiState = _uiState.asStateFlow()

    private val customSmsRuleDao = AppDatabase.getInstance(application).customSmsRuleDao()

    fun initializeStateForCreation(potentialTxn: PotentialTransaction) {
        val amountStr = String.format("%.2f", potentialTxn.amount)
        val amountIndex = potentialTxn.originalMessage.indexOf(amountStr)

        val amountSelection = if (amountIndex != -1) {
            RuleSelection(
                selectedText = amountStr,
                startIndex = amountIndex,
                endIndex = amountIndex + amountStr.length
            )
        } else {
            RuleSelection()
        }

        _uiState.value = RuleCreationUiState(
            amountSelection = amountSelection,
            transactionType = potentialTxn.transactionType
        )
    }

    // --- NEW: Function to load an existing rule for editing ---
    fun loadRuleForEditing(ruleId: Int) {
        viewModelScope.launch {
            val rule = customSmsRuleDao.getRuleById(ruleId).firstOrNull() ?: return@launch
            _uiState.value = RuleCreationUiState(
                triggerSelection = RuleSelection(selectedText = rule.triggerPhrase),
                merchantSelection = RuleSelection(selectedText = rule.merchantNameExample ?: ""),
                amountSelection = RuleSelection(selectedText = rule.amountExample ?: ""),
                accountSelection = RuleSelection(selectedText = rule.accountNameExample ?: ""),
                ruleIdToEdit = rule.id
            )
        }
    }

    fun onMarkAsTrigger(selection: RuleSelection) {
        _uiState.update { it.copy(triggerSelection = selection) }
    }

    fun onMarkAsMerchant(selection: RuleSelection) {
        _uiState.update { it.copy(merchantSelection = selection) }
    }

    fun onMarkAsAmount(selection: RuleSelection) {
        _uiState.update { it.copy(amountSelection = selection) }
    }

    fun onMarkAsAccount(selection: RuleSelection) {
        _uiState.update { it.copy(accountSelection = selection) }
    }

    fun saveRule(fullSmsText: String, onComplete: () -> Unit) {
        viewModelScope.launch {
            val currentState = _uiState.value
            if (currentState.triggerSelection.selectedText.isBlank()) {
                Log.e("RuleCreation", "Cannot save rule without a trigger phrase.")
                onComplete()
                return@launch
            }

            val merchantRegex = if (currentState.merchantSelection.selectedText.isNotBlank()) {
                generateRegex(fullSmsText, currentState.merchantSelection)
            } else null

            val amountRegex = if (currentState.amountSelection.selectedText.isNotBlank()) {
                generateRegex(fullSmsText, currentState.amountSelection)
            } else null

            val accountRegex = if (currentState.accountSelection.selectedText.isNotBlank()) {
                generateRegex(fullSmsText, currentState.accountSelection)
            } else null

            val rule = CustomSmsRule(
                id = currentState.ruleIdToEdit ?: 0, // Use existing ID if editing
                triggerPhrase = currentState.triggerSelection.selectedText,
                merchantRegex = merchantRegex,
                amountRegex = amountRegex,
                accountRegex = accountRegex,
                merchantNameExample = currentState.merchantSelection.selectedText.takeIf { it.isNotBlank() },
                amountExample = currentState.amountSelection.selectedText.takeIf { it.isNotBlank() },
                accountNameExample = currentState.accountSelection.selectedText.takeIf { it.isNotBlank() },
                priority = 10,
                sourceSmsBody = fullSmsText
            )

            // --- UPDATED: Check if we are editing or creating ---
            if (currentState.ruleIdToEdit != null) {
                Log.d("RuleCreation", "Updating existing rule: $rule")
                customSmsRuleDao.update(rule)
            } else {
                Log.d("RuleCreation", "Saving new trigger-based rule: $rule")
                customSmsRuleDao.insert(rule)
            }
            onComplete()
        }
    }

    private fun generateRegex(fullText: String, selection: RuleSelection): String? {
        if (selection.startIndex == -1 || selection.selectedText.isBlank()) return null

        val textBefore = fullText.substring(0, selection.startIndex)
        val textAfter = fullText.substring(selection.endIndex)

        val prefixWords = textBefore.trim().split(Regex("\\s+")).takeLast(2)
        val prefix = prefixWords.joinToString(separator = " ")

        val suffixWords = textAfter.trim().split(Regex("\\s+")).take(2)
        val suffix = suffixWords.joinToString(separator = " ")

        val escapedPrefix = if (prefix.isNotBlank()) Pattern.quote(prefix) else ""
        val escapedSuffix = if (suffix.isNotBlank()) Pattern.quote(suffix) else ""

        return when {
            escapedPrefix.isNotBlank() && escapedSuffix.isNotBlank() -> "$escapedPrefix\\s*(.*?)\\s*$escapedSuffix"
            escapedPrefix.isNotBlank() -> "$escapedPrefix\\s*(.*)"
            escapedSuffix.isNotBlank() -> "(.*?)\\s*$escapedSuffix"
            else -> Pattern.quote(selection.selectedText)
        }
    }
}
-e 


================== FILE: ./app/src/main/java/DashboardViewModelFactory.kt ==================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider

/**
 * Factory for creating a DashboardViewModel with a constructor that takes dependencies.
 */
class DashboardViewModelFactory(private val application: Application) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(DashboardViewModel::class.java)) {
            val db = AppDatabase.getInstance(application)
            val transactionRepository = TransactionRepository(db.transactionDao())
            val accountRepository = AccountRepository(db.accountDao())
            val settingsRepository = SettingsRepository(application)

            @Suppress("UNCHECKED_CAST")
            return DashboardViewModel(
                transactionRepository = transactionRepository,
                accountRepository = accountRepository,
                budgetDao = db.budgetDao(),
                settingsRepository = settingsRepository,
            ) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
-e 


================== FILE: ./app/src/main/java/MerchantRenameRuleDao.kt ==================
package io.pm.finlight

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import kotlinx.coroutines.flow.Flow

@Dao
interface MerchantRenameRuleDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(rule: MerchantRenameRule)

    @Query("SELECT * FROM merchant_rename_rules")
    fun getAllRules(): Flow<List<MerchantRenameRule>>

    @Query("DELETE FROM merchant_rename_rules WHERE originalName = :originalName")
    suspend fun deleteByOriginalName(originalName: String)
}
-e 


================== FILE: ./app/src/main/java/MonthlySummaryItem.kt ==================
package io.pm.finlight

import java.util.Calendar

/**
 * A data class to hold a Calendar instance for a specific month
 * and the total amount spent during that month.
 *
 * @param calendar The Calendar object representing the month.
 * @param totalSpent The total expenses for that month.
 */
data class MonthlySummaryItem(val calendar: Calendar, val totalSpent: Double)
-e 


================== FILE: ./app/src/main/java/DataExportService.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/DataExportService.kt
// REASON: FEATURE - The CSV export functionality has been enhanced to include
// tags. The CSV header now includes a "Tags" column, and the export logic
// fetches the tags for each transaction and appends them as a pipe-separated
// string, providing a more complete data export.
// =================================================================================
package io.pm.finlight

import android.content.Context
import android.net.Uri
import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.withContext
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import java.text.SimpleDateFormat
import java.util.*

object DataExportService {
    private val json =
        Json {
            prettyPrint = true
            isLenient = true
            ignoreUnknownKeys = true
        }

    // --- UPDATED: Add "Tags" to the CSV template header ---
    fun getCsvTemplateString(): String {
        return "Date,Description,Amount,Type,Category,Account,Notes,IsExcluded,Tags\n"
    }

    suspend fun exportToJsonString(context: Context): String? {
        return withContext(Dispatchers.IO) {
            try {
                val db = AppDatabase.getInstance(context)

                val backupData =
                    AppDataBackup(
                        transactions = db.transactionDao().getAllTransactionsSimple().first(),
                        accounts = db.accountDao().getAllAccounts().first(),
                        categories = db.categoryDao().getAllCategories().first(),
                        budgets = db.budgetDao().getAllBudgets().first(),
                        merchantMappings = db.merchantMappingDao().getAllMappings().first(),
                    )

                json.encodeToString(backupData)
            } catch (e: Exception) {
                Log.e("DataExportService", "Error exporting to JSON", e)
                null
            }
        }
    }

    suspend fun importDataFromJson(
        context: Context,
        uri: Uri,
    ): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                val jsonString = context.contentResolver.openInputStream(uri)?.bufferedReader().use { it?.readText() }
                if (jsonString == null) return@withContext false

                val backupData = json.decodeFromString<AppDataBackup>(jsonString)

                val db = AppDatabase.getInstance(context)
                val transactionDao = db.transactionDao()
                val accountDao = db.accountDao()
                val categoryDao = db.categoryDao()
                val budgetDao = db.budgetDao()
                val merchantMappingDao = db.merchantMappingDao()

                transactionDao.deleteAll()
                accountDao.deleteAll()
                categoryDao.deleteAll()
                budgetDao.deleteAll()
                merchantMappingDao.deleteAll()

                accountDao.insertAll(backupData.accounts)
                categoryDao.insertAll(backupData.categories)
                budgetDao.insertAll(backupData.budgets)
                merchantMappingDao.insertAll(backupData.merchantMappings)
                transactionDao.insertAll(backupData.transactions)

                true
            } catch (e: Exception) {
                Log.e("DataExportService", "Error importing from JSON", e)
                false
            }
        }
    }

    suspend fun exportToCsvString(context: Context): String? {
        return withContext(Dispatchers.IO) {
            try {
                val db = AppDatabase.getInstance(context)
                val transactionDao = db.transactionDao()
                val transactions = transactionDao.getAllTransactions().first()
                val csvBuilder = StringBuilder()

                csvBuilder.append(getCsvTemplateString())

                val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())

                transactions.forEach { details: TransactionDetails ->
                    val date = dateFormat.format(Date(details.transaction.date))
                    val description = escapeCsvField(details.transaction.description)
                    val amount = details.transaction.amount.toString()
                    val type = details.transaction.transactionType
                    val category = escapeCsvField(details.categoryName ?: "N/A")
                    val account = escapeCsvField(details.accountName ?: "N/A")
                    val notes = escapeCsvField(details.transaction.notes ?: "")
                    val isExcluded = details.transaction.isExcluded.toString()

                    // --- NEW: Fetch and append tags ---
                    val tags = transactionDao.getTagsForTransactionSimple(details.transaction.id)
                    val tagsString = tags.joinToString("|") { it.name } // Use pipe as a safe delimiter
                    val escapedTags = escapeCsvField(tagsString)

                    csvBuilder.append("$date,$description,$amount,$type,$category,$account,$notes,$isExcluded,$escapedTags\n")
                }
                csvBuilder.toString()
            } catch (e: Exception) {
                Log.e("DataExportService", "Error exporting to CSV", e)
                null
            }
        }
    }

    // --- NOTE: The importFromCsv function has been moved to SettingsViewModel ---
    // This file now only handles data formatting (export).

    private fun escapeCsvField(field: String): String {
        if (field.contains(",") || field.contains("\"") || field.contains("\n")) {
            return "\"${field.replace("\"", "\"\"")}\""
        }
        return field
    }
}-e 


================== FILE: ./app/src/main/java/AccountRepository.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/AccountRepository.kt
// REASON: Updated the insert function to return the new account's ID (Long).
// =================================================================================
package io.pm.finlight

import kotlinx.coroutines.flow.Flow

class AccountRepository(private val accountDao: AccountDao) {
    val accountsWithBalance: Flow<List<AccountWithBalance>> = accountDao.getAccountsWithBalance()

    val allAccounts: Flow<List<Account>> = accountDao.getAllAccounts()

    fun getAccountById(accountId: Int): Flow<Account?> {
        return accountDao.getAccountById(accountId)
    }

    // --- UPDATED: Returns the new row ID from the DAO ---
    suspend fun insert(account: Account): Long {
        return accountDao.insert(account)
    }

    suspend fun update(account: Account) {
        accountDao.update(account)
    }

    suspend fun delete(account: Account) {
        accountDao.delete(account)
    }
}
-e 


================== FILE: ./app/src/main/java/FinancialSummary.kt ==================
package io.pm.finlight

/**
 * A data class to hold a financial summary, typically for a specific date range.
 * This is used for fetching aggregated income and expense data from the database.
 *
 * @param totalIncome The sum of all income transactions in the period.
 * @param totalExpenses The sum of all expense transactions in the period.
 */
data class FinancialSummary(
    val totalIncome: Double,
    val totalExpenses: Double
)
-e 


================== FILE: ./app/src/main/java/BudgetRepository.kt ==================
package io.pm.finlight

import kotlinx.coroutines.flow.Flow

class BudgetRepository(private val budgetDao: BudgetDao) {
    fun getBudgetsForMonth(
        month: Int,
        year: Int,
    ): Flow<List<Budget>> {
        return budgetDao.getBudgetsForMonth(month, year)
    }

    fun getBudgetsForMonthWithSpending(yearMonth: String, month: Int, year: Int): Flow<List<BudgetWithSpending>> {
        return budgetDao.getBudgetsWithSpendingForMonth(yearMonth, month, year)
    }

    fun getActualSpendingForCategory(
        categoryName: String,
        month: Int,
        year: Int,
    ): Flow<Double?> {
        return budgetDao.getActualSpendingForCategory(categoryName, month, year)
    }

    suspend fun update(budget: Budget) {
        budgetDao.update(budget)
    }

    suspend fun insert(budget: Budget) {
        budgetDao.insert(budget)
    }

    suspend fun delete(budget: Budget) {
        budgetDao.delete(budget)
    }

    fun getBudgetById(id: Int): Flow<Budget?> {
        return budgetDao.getById(id)
    }
}
-e 


================== FILE: ./app/src/main/java/TimePeriodReportViewModel.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/TimePeriodReportViewModel.kt
// REASON: REFACTOR - The date range calculation for the Daily report has been
// restored to a rolling 24-hour window. This ensures that when a user clicks
// the daily report notification, they see data from the 24 hours preceding the
// notification's generation time, as intended.
// BUG FIX: The logic for generating the 7-day bar chart on the daily report
// screen has been corrected. It now correctly calculates the date for each bar
// based on the start of the 7-day period, not the selected date. This ensures
// the chart accurately reflects the spending for the week leading up to the
// report date, regardless of which day the user is viewing.
// BUG FIX: The ViewModel now correctly initializes its selectedDate with the
// initialDateMillis provided from the notification deep link, ensuring the
// report displays data for the correct 24-hour period.
// =================================================================================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.github.mikephil.charting.data.BarData
import com.github.mikephil.charting.data.BarDataSet
import com.github.mikephil.charting.data.BarEntry
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.*
import java.text.SimpleDateFormat
import java.util.*
import kotlin.math.roundToInt

class TimePeriodReportViewModelFactory(
    private val application: Application,
    private val timePeriod: TimePeriod,
    private val initialDateMillis: Long?
) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(TimePeriodReportViewModel::class.java)) {
            val db = AppDatabase.getInstance(application)
            @Suppress("UNCHECKED_CAST")
            return TimePeriodReportViewModel(db.transactionDao(), timePeriod, initialDateMillis) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

data class ReportInsights(
    val percentageChange: Int?,
    val topCategory: CategorySpending?
)

@OptIn(ExperimentalCoroutinesApi::class)
class TimePeriodReportViewModel(
    private val transactionDao: TransactionDao,
    private val timePeriod: TimePeriod,
    initialDateMillis: Long?
) : ViewModel() {

    private val _selectedDate = MutableStateFlow(
        Calendar.getInstance().apply {
            // --- FIX: Use the provided initialDateMillis from the notification ---
            if (initialDateMillis != null && initialDateMillis != -1L) {
                timeInMillis = initialDateMillis
            }
        }
    )
    val selectedDate: StateFlow<Calendar> = _selectedDate.asStateFlow()

    val transactionsForPeriod: StateFlow<List<TransactionDetails>> = _selectedDate.flatMapLatest { calendar ->
        val (start, end) = getPeriodDateRange(calendar)
        transactionDao.getTransactionsForDateRange(start, end)
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

    val totalIncome: StateFlow<Double> = transactionsForPeriod.map { transactions ->
        transactions
            .filter { it.transaction.transactionType == "income" && !it.transaction.isExcluded }
            .sumOf { it.transaction.amount }
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0.0)


    val insights: StateFlow<ReportInsights?> = _selectedDate.flatMapLatest { calendar ->
        flow {
            val (currentStart, currentEnd) = getPeriodDateRange(calendar)

            val previousPeriodEndCal = (calendar.clone() as Calendar).apply {
                when (timePeriod) {
                    TimePeriod.DAILY -> add(Calendar.HOUR_OF_DAY, -24) // Compare with previous 24-hour window
                    TimePeriod.WEEKLY -> add(Calendar.DAY_OF_YEAR, -7)
                    TimePeriod.MONTHLY -> add(Calendar.DAY_OF_YEAR, -30)
                }
            }
            val (previousStart, previousEnd) = getPeriodDateRange(previousPeriodEndCal)

            val currentSummary = transactionDao.getFinancialSummaryForRange(currentStart, currentEnd)
            val previousSummary = transactionDao.getFinancialSummaryForRange(previousStart, previousEnd)
            val topCategories = transactionDao.getTopSpendingCategoriesForRange(currentStart, currentEnd)

            val percentageChange = if (previousSummary?.totalExpenses != null && previousSummary.totalExpenses > 0) {
                val currentExpenses = currentSummary?.totalExpenses ?: 0.0
                ((currentExpenses - previousSummary.totalExpenses) / previousSummary.totalExpenses * 100).roundToInt()
            } else {
                null
            }

            emit(ReportInsights(percentageChange, topCategories.firstOrNull()))
        }
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), null)


    val chartData: StateFlow<Pair<BarData, List<String>>?> = _selectedDate.flatMapLatest { calendar ->
        when (timePeriod) {
            TimePeriod.DAILY -> {
                val endCal = (calendar.clone() as Calendar)
                val startCal = (calendar.clone() as Calendar).apply { add(Calendar.DAY_OF_YEAR, -6) }

                transactionDao.getDailySpendingForDateRange(startCal.timeInMillis, endCal.timeInMillis).map { dailyTotals ->
                    if (dailyTotals.isEmpty()) return@map null

                    val entries = mutableListOf<BarEntry>()
                    val labels = mutableListOf<String>()
                    val dayFormat = SimpleDateFormat("EEE", Locale.getDefault())
                    val fullDateFormat = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())

                    val totalsMap = dailyTotals.associateBy { it.date }

                    for (i in 0..6) {
                        val dayCal = (startCal.clone() as Calendar).apply { add(Calendar.DAY_OF_YEAR, i) }
                        val dateString = fullDateFormat.format(dayCal.time)

                        val total = totalsMap[dateString]?.totalAmount?.toFloat() ?: 0f
                        entries.add(BarEntry(i.toFloat(), total))
                        labels.add(dayFormat.format(dayCal.time))
                    }

                    val dataSet = BarDataSet(entries, "Daily Spending").apply {
                        color = 0xFF81D4FA.toInt() // Light Blue
                        setDrawValues(true)
                        valueTextColor = 0xFFFFFFFF.toInt()
                    }
                    Pair(BarData(dataSet), labels)
                }
            }
            TimePeriod.WEEKLY -> {
                val endCal = (calendar.clone() as Calendar).apply {
                    set(Calendar.DAY_OF_WEEK, firstDayOfWeek)
                    add(Calendar.WEEK_OF_YEAR, 1)
                    add(Calendar.DAY_OF_YEAR, -1)
                }
                val startCal = (calendar.clone() as Calendar).apply {
                    add(Calendar.WEEK_OF_YEAR, -7) // 8 weeks total
                    set(Calendar.DAY_OF_WEEK, firstDayOfWeek)
                }

                transactionDao.getWeeklySpendingForDateRange(startCal.timeInMillis, endCal.timeInMillis).map { weeklyTotals ->
                    if (weeklyTotals.isEmpty()) return@map null

                    val entries = mutableListOf<BarEntry>()
                    val labels = mutableListOf<String>()
                    val totalsMap = weeklyTotals.associateBy { it.period }

                    for (i in 0..7) {
                        val weekCal = (startCal.clone() as Calendar).apply { add(Calendar.WEEK_OF_YEAR, i) }
                        val yearWeek = "${weekCal.get(Calendar.YEAR)}-${weekCal.get(Calendar.WEEK_OF_YEAR).toString().padStart(2, '0')}"

                        val total = totalsMap[yearWeek]?.totalAmount?.toFloat() ?: 0f
                        entries.add(BarEntry(i.toFloat(), total))
                        labels.add("W${weekCal.get(Calendar.WEEK_OF_YEAR)}")
                    }

                    val dataSet = BarDataSet(entries, "Weekly Spending").apply {
                        color = 0xFF9575CD.toInt() // Deep Purple
                        setDrawValues(true)
                        valueTextColor = 0xFFFFFFFF.toInt()
                    }
                    Pair(BarData(dataSet), labels)
                }
            }
            TimePeriod.MONTHLY -> {
                val endCal = (calendar.clone() as Calendar).apply {
                    set(Calendar.DAY_OF_MONTH, getActualMaximum(Calendar.DAY_OF_MONTH))
                }
                val startCal = (calendar.clone() as Calendar).apply {
                    add(Calendar.MONTH, -5) // 6 months total
                    set(Calendar.DAY_OF_MONTH, 1)
                }

                transactionDao.getMonthlySpendingForDateRange(startCal.timeInMillis, endCal.timeInMillis).map { monthlyTotals ->
                    if (monthlyTotals.isEmpty()) return@map null

                    val entries = mutableListOf<BarEntry>()
                    val labels = mutableListOf<String>()
                    val monthFormat = SimpleDateFormat("MMM", Locale.getDefault())
                    val yearMonthFormat = SimpleDateFormat("yyyy-MM", Locale.getDefault())
                    val totalsMap = monthlyTotals.associateBy { it.period }

                    for (i in 0..5) {
                        val monthCal = (startCal.clone() as Calendar).apply { add(Calendar.MONTH, i) }
                        val yearMonth = yearMonthFormat.format(monthCal.time)

                        val total = totalsMap[yearMonth]?.totalAmount?.toFloat() ?: 0f
                        entries.add(BarEntry(i.toFloat(), total))
                        labels.add(monthFormat.format(monthCal.time))
                    }

                    val dataSet = BarDataSet(entries, "Monthly Spending").apply {
                        color = 0xFF4DB6AC.toInt() // Teal
                        setDrawValues(true)
                        valueTextColor = 0xFFFFFFFF.toInt()
                    }
                    Pair(BarData(dataSet), labels)
                }
            }
        }
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), null)


    fun selectPreviousPeriod() {
        _selectedDate.update {
            (it.clone() as Calendar).apply {
                add(
                    when (timePeriod) {
                        TimePeriod.DAILY -> Calendar.DAY_OF_YEAR
                        TimePeriod.WEEKLY -> Calendar.WEEK_OF_YEAR
                        TimePeriod.MONTHLY -> Calendar.MONTH
                    }, -1
                )
            }
        }
    }

    fun selectNextPeriod() {
        _selectedDate.update {
            (it.clone() as Calendar).apply {
                add(
                    when (timePeriod) {
                        TimePeriod.DAILY -> Calendar.DAY_OF_YEAR
                        TimePeriod.WEEKLY -> Calendar.WEEK_OF_YEAR
                        TimePeriod.MONTHLY -> Calendar.MONTH
                    }, 1
                )
            }
        }
    }

    private fun getPeriodDateRange(calendar: Calendar): Pair<Long, Long> {
        val endCal = (calendar.clone() as Calendar)
        val startCal = (endCal.clone() as Calendar)

        when (timePeriod) {
            TimePeriod.DAILY -> startCal.add(Calendar.HOUR_OF_DAY, -24)
            TimePeriod.WEEKLY -> startCal.add(Calendar.DAY_OF_YEAR, -7)
            TimePeriod.MONTHLY -> startCal.add(Calendar.DAY_OF_YEAR, -30)
        }

        return Pair(startCal.timeInMillis, endCal.timeInMillis)
    }
}
-e 


================== FILE: ./app/src/main/java/CustomSmsRuleDao.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/CustomSmsRuleDao.kt
// REASON: FEATURE - Added the `getRuleById` and `update` functions. These are
// essential for the "Edit Rule" feature, allowing the ViewModel to fetch a
// specific rule for editing and then save the updated version back to the
// database.
// =================================================================================
package io.pm.finlight

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import kotlinx.coroutines.flow.Flow

/**
 * Data Access Object (DAO) for the CustomSmsRule entity.
 * Provides methods to interact with the custom_sms_rules table in the database.
 */
@Dao
interface CustomSmsRuleDao {

    /**
     * Inserts a new custom SMS rule into the database. If a rule with the same primary key
     * already exists, it will be replaced.
     *
     * @param rule The CustomSmsRule object to insert.
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(rule: CustomSmsRule)

    /**
     * Retrieves all custom SMS rules from the database, ordered by priority in descending order.
     * This ensures that higher-priority rules are evaluated first.
     *
     * @return A Flow emitting a list of all CustomSmsRule objects.
     */
    @Query("SELECT * FROM custom_sms_rules ORDER BY priority DESC")
    fun getAllRules(): Flow<List<CustomSmsRule>>

    /**
     * Deletes a specific custom rule from the database.
     *
     * @param rule The CustomSmsRule object to delete.
     */
    @Delete
    suspend fun delete(rule: CustomSmsRule)

    // --- NEW: Function to get a single rule by its ID ---
    @Query("SELECT * FROM custom_sms_rules WHERE id = :id")
    fun getRuleById(id: Int): Flow<CustomSmsRule?>

    // --- NEW: Function to update an existing rule ---
    @Update
    suspend fun update(rule: CustomSmsRule)
}
-e 


================== FILE: ./app/src/main/java/TransactionViewModel.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/TransactionViewModel.kt
// REASON: BUG FIX - The call to `SmsParser.parse` within the
// `reparseTransactionFromSms` function has been updated to include the required
// `merchantCategoryMappingDao` argument, resolving a compilation error.
// =================================================================================
package io.pm.finlight

import android.app.Application
import android.net.Uri
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Date
import java.util.Locale

private const val TAG = "TransactionViewModel"

data class TransactionFilterState(
    val keyword: String = "",
    val account: Account? = null,
    val category: Category? = null
)

data class RetroUpdateSheetState(
    val originalDescription: String,
    val newDescription: String? = null,
    val newCategoryId: Int? = null,
    val similarTransactions: List<Transaction> = emptyList(),
    val selectedIds: Set<Int> = emptySet(),
    val isLoading: Boolean = true
)

@OptIn(ExperimentalCoroutinesApi::class)
class TransactionViewModel(application: Application) : AndroidViewModel(application) {
    private val transactionRepository: TransactionRepository
    val accountRepository: AccountRepository
    val categoryRepository: CategoryRepository
    private val tagRepository: TagRepository
    private val settingsRepository: SettingsRepository
    private val smsRepository: SmsRepository
    private val merchantRenameRuleRepository: MerchantRenameRuleRepository
    private val merchantCategoryMappingRepository: MerchantCategoryMappingRepository
    private val context = application

    private val db = AppDatabase.getInstance(application)
    private var areTagsLoadedForCurrentTxn = false
    private var currentTxnIdForTags: Int? = null

    private val _selectedMonth = MutableStateFlow(Calendar.getInstance())
    val selectedMonth: StateFlow<Calendar> = _selectedMonth.asStateFlow()

    private val _filterState = MutableStateFlow(TransactionFilterState())
    val filterState: StateFlow<TransactionFilterState> = _filterState.asStateFlow()

    private val _showFilterSheet = MutableStateFlow(false)
    val showFilterSheet: StateFlow<Boolean> = _showFilterSheet.asStateFlow()

    private val combinedState: Flow<Pair<Calendar, TransactionFilterState>> =
        _selectedMonth.combine(_filterState) { month, filters ->
            Pair(month, filters)
        }

    private val merchantAliases: StateFlow<Map<String, String>>

    val transactionsForSelectedMonth: StateFlow<List<TransactionDetails>>
    val monthlyIncome: StateFlow<Double>
    val monthlyExpenses: StateFlow<Double>
    val categorySpendingForSelectedMonth: StateFlow<List<CategorySpending>>
    val merchantSpendingForSelectedMonth: StateFlow<List<MerchantSpendingSummary>>
    val overallMonthlyBudget: StateFlow<Float>
    val amountRemaining: StateFlow<Float>
    val safeToSpendPerDay: StateFlow<Float>
    val allTransactions: StateFlow<List<TransactionDetails>>
    val allAccounts: StateFlow<List<Account>>
    val allCategories: Flow<List<Category>>
    val allTags: StateFlow<List<Tag>>
    private val _validationError = MutableStateFlow<String?>(null)
    val validationError = _validationError.asStateFlow()
    private val _selectedTags = MutableStateFlow<Set<Tag>>(emptySet())
    val selectedTags = _selectedTags.asStateFlow()
    private val _transactionImages = MutableStateFlow<List<TransactionImage>>(emptyList())
    val transactionImages: StateFlow<List<TransactionImage>> = _transactionImages.asStateFlow()
    val monthlySummaries: StateFlow<List<MonthlySummaryItem>>

    private val _defaultAccount = MutableStateFlow<Account?>(null)
    val defaultAccount: StateFlow<Account?> = _defaultAccount.asStateFlow()

    private val _originalSmsText = MutableStateFlow<String?>(null)
    val originalSmsText: StateFlow<String?> = _originalSmsText.asStateFlow()

    private val _visitCount = MutableStateFlow(0)
    val visitCount: StateFlow<Int> = _visitCount.asStateFlow()

    private val _retroUpdateSheetState = MutableStateFlow<RetroUpdateSheetState?>(null)
    val retroUpdateSheetState = _retroUpdateSheetState.asStateFlow()

    init {
        transactionRepository = TransactionRepository(db.transactionDao())
        accountRepository = AccountRepository(db.accountDao())
        categoryRepository = CategoryRepository(db.categoryDao())
        tagRepository = TagRepository(db.tagDao(), db.transactionDao())
        settingsRepository = SettingsRepository(application)
        smsRepository = SmsRepository(application)
        merchantRenameRuleRepository = MerchantRenameRuleRepository(db.merchantRenameRuleDao())
        merchantCategoryMappingRepository = MerchantCategoryMappingRepository(db.merchantCategoryMappingDao())

        merchantAliases = merchantRenameRuleRepository.getAliasesAsMap()
            .map { it.mapKeys { (key, _) -> key.lowercase(Locale.getDefault()) } }
            .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyMap())

        transactionsForSelectedMonth = combinedState.flatMapLatest { (calendar, filters) ->
            val monthStart = (calendar.clone() as Calendar).apply { set(Calendar.DAY_OF_MONTH, 1); set(Calendar.HOUR_OF_DAY, 0); set(Calendar.MINUTE, 0); set(Calendar.SECOND, 0) }.timeInMillis
            val monthEnd = (calendar.clone() as Calendar).apply { add(Calendar.MONTH, 1); set(Calendar.DAY_OF_MONTH, 1); add(Calendar.DAY_OF_MONTH, -1); set(Calendar.HOUR_OF_DAY, 23); set(Calendar.MINUTE, 59); set(Calendar.SECOND, 59) }.timeInMillis
            transactionRepository.getTransactionDetailsForRange(monthStart, monthEnd, filters.keyword.takeIf { it.isNotBlank() }, filters.account?.id, filters.category?.id)
        }.combine(merchantAliases) { transactions, aliases ->
            applyAliases(transactions, aliases)
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

        monthlyIncome = transactionsForSelectedMonth.map { txns ->
            txns.filter { it.transaction.transactionType == "income" && !it.transaction.isExcluded }.sumOf { it.transaction.amount }
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0.0)

        monthlyExpenses = transactionsForSelectedMonth.map { txns ->
            txns.filter { it.transaction.transactionType == "expense" && !it.transaction.isExcluded }.sumOf { it.transaction.amount }
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0.0)

        categorySpendingForSelectedMonth = combinedState.flatMapLatest { (calendar, filters) ->
            val monthStart = (calendar.clone() as Calendar).apply { set(Calendar.DAY_OF_MONTH, 1); set(Calendar.HOUR_OF_DAY, 0); set(Calendar.MINUTE, 0); set(Calendar.SECOND, 0) }.timeInMillis
            val monthEnd = (calendar.clone() as Calendar).apply { add(Calendar.MONTH, 1); set(Calendar.DAY_OF_MONTH, 1); add(Calendar.DAY_OF_MONTH, -1); set(Calendar.HOUR_OF_DAY, 23); set(Calendar.MINUTE, 59); set(Calendar.SECOND, 59) }.timeInMillis
            transactionRepository.getSpendingByCategoryForMonth(monthStart, monthEnd, filters.keyword.takeIf { it.isNotBlank() }, filters.account?.id, filters.category?.id)
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

        merchantSpendingForSelectedMonth = combinedState.flatMapLatest { (calendar, filters) ->
            val monthStart = (calendar.clone() as Calendar).apply { set(Calendar.DAY_OF_MONTH, 1); set(Calendar.HOUR_OF_DAY, 0); set(Calendar.MINUTE, 0); set(Calendar.SECOND, 0) }.timeInMillis
            val monthEnd = (calendar.clone() as Calendar).apply { add(Calendar.MONTH, 1); set(Calendar.DAY_OF_MONTH, 1); add(Calendar.DAY_OF_MONTH, -1); set(Calendar.HOUR_OF_DAY, 23); set(Calendar.MINUTE, 59); set(Calendar.SECOND, 59) }.timeInMillis
            transactionRepository.getSpendingByMerchantForMonth(monthStart, monthEnd, filters.keyword.takeIf { it.isNotBlank() }, filters.account?.id, filters.category?.id)
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

        allTransactions = transactionRepository.allTransactions
            .combine(merchantAliases) { transactions, aliases ->
                applyAliases(transactions, aliases)
            }
            .stateIn(
                scope = viewModelScope,
                started = SharingStarted.WhileSubscribed(5000),
                initialValue = emptyList()
            )
        allAccounts = accountRepository.allAccounts.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )
        allCategories = categoryRepository.allCategories
        allTags = tagRepository.allTags.onEach {
            Log.d(TAG, "allTags flow collected new data. Count: ${it.size}")
        }.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )
        val twelveMonthsAgo = Calendar.getInstance().apply { add(Calendar.YEAR, -1) }.timeInMillis
        monthlySummaries = transactionRepository.getMonthlyTrends(twelveMonthsAgo)
            .map { trends ->
                val dateFormat = SimpleDateFormat("yyyy-MM", Locale.getDefault())
                val monthMap = trends.associate {
                    val cal = Calendar.getInstance().apply {
                        time = dateFormat.parse(it.monthYear) ?: Date()
                    }
                    (cal.get(Calendar.YEAR) * 100 + cal.get(Calendar.MONTH)) to it.totalExpenses
                }

                (0..11).map { i ->
                    val cal = Calendar.getInstance().apply { add(Calendar.MONTH, -i) }
                    val key = cal.get(Calendar.YEAR) * 100 + cal.get(Calendar.MONTH)
                    val spent = monthMap[key] ?: 0.0
                    MonthlySummaryItem(calendar = cal, totalSpent = spent)
                }.reversed()
            }
            .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

        overallMonthlyBudget = _selectedMonth.flatMapLatest { settingsRepository.getOverallBudgetForMonth(it.get(Calendar.YEAR), it.get(Calendar.MONTH) + 1) }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0f)
        amountRemaining = combine(overallMonthlyBudget, monthlyExpenses) { budget, expenses -> budget - expenses.toFloat() }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0f)
        safeToSpendPerDay = combine(amountRemaining, _selectedMonth) { remaining, calendar ->
            val today = Calendar.getInstance()
            val lastDayOfMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH)
            val remainingDays = if (today.get(Calendar.YEAR) == calendar.get(Calendar.YEAR) && today.get(Calendar.MONTH) == calendar.get(Calendar.MONTH)) { (lastDayOfMonth - today.get(Calendar.DAY_OF_MONTH) + 1).coerceAtLeast(1) } else if (calendar.after(today)) { lastDayOfMonth } else { 1 }
            if (remaining > 0) remaining / remainingDays else 0f
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0f)

        viewModelScope.launch {
            _defaultAccount.value = db.accountDao().findByName("Cash Spends")
        }
    }

    private fun applyAliases(transactions: List<TransactionDetails>, aliases: Map<String, String>): List<TransactionDetails> {
        return transactions.map { details ->
            val key = (details.transaction.originalDescription ?: details.transaction.description).lowercase(Locale.getDefault())
            val newDescription = aliases[key] ?: details.transaction.description
            details.copy(transaction = details.transaction.copy(description = newDescription))
        }
    }

    fun findTransactionDetailsById(id: Int): Flow<TransactionDetails?> {
        return transactionRepository.getTransactionDetailsById(id)
            .combine(merchantAliases) { details, aliases ->
                details?.let { applyAliases(listOf(it), aliases).firstOrNull() }
            }
    }

    fun loadVisitCount(originalDescription: String?, fallbackDescription: String) {
        val descriptionToQuery = originalDescription ?: fallbackDescription
        viewModelScope.launch {
            transactionRepository.getTransactionCountForMerchant(descriptionToQuery).collect { count ->
                _visitCount.value = count
            }
        }
    }

    suspend fun addTransaction(
        description: String,
        categoryId: Int?,
        amountStr: String,
        accountId: Int,
        notes: String?,
        date: Long,
        transactionType: String,
        imageUris: List<Uri>
    ): Boolean {
        _validationError.value = null

        if (description.isBlank()) {
            _validationError.value = "Description cannot be empty."
            return false
        }
        val amount = amountStr.toDoubleOrNull()
        if (amount == null || amount <= 0.0) {
            _validationError.value = "Please enter a valid, positive amount."
            return false
        }
        if (categoryId == null) {
            _validationError.value = "Please select a category."
            return false
        }


        return try {
            withContext(Dispatchers.IO) {
                val savedImagePaths = imageUris.mapNotNull { uri ->
                    saveImageToInternalStorage(uri)
                }
                val newTransaction =
                    Transaction(
                        description = description,
                        originalDescription = description,
                        categoryId = categoryId,
                        amount = amount,
                        date = date,
                        accountId = accountId,
                        notes = notes,
                        transactionType = transactionType,
                        isExcluded = false,
                        sourceSmsId = null,
                        sourceSmsHash = null,
                        source = "Added Manually"
                    )

                transactionRepository.insertTransactionWithTagsAndImages(
                    newTransaction,
                    _selectedTags.value,
                    savedImagePaths
                )
            }
            true
        } catch (e: Exception) {
            Log.e(TAG, "Failed to save transaction", e)
            _validationError.value = "An error occurred while saving."
            false
        }
    }

    fun clearAddTransactionState() {
        _selectedTags.value = emptySet()
    }


    fun loadOriginalSms(sourceSmsId: Long?) {
        if (sourceSmsId == null) {
            _originalSmsText.value = null
            return
        }
        viewModelScope.launch {
            val sms = getOriginalSmsMessage(sourceSmsId)
            _originalSmsText.value = sms?.body
            Log.d(TAG, "Loaded SMS for ID $sourceSmsId. Found: ${sms != null}")
        }
    }

    fun clearOriginalSms() {
        _originalSmsText.value = null
    }

    suspend fun getOriginalSmsMessage(smsId: Long): SmsMessage? {
        return withContext(Dispatchers.IO) {
            smsRepository.getSmsDetailsById(smsId)
        }
    }

    fun reparseTransactionFromSms(transactionId: Int) {
        viewModelScope.launch(Dispatchers.IO) {
            val logTag = "ReparseLogic"
            Log.d(logTag, "--- Starting reparse for transactionId: $transactionId ---")

            val transaction = transactionRepository.getTransactionById(transactionId).first()
            if (transaction?.sourceSmsId == null) {
                Log.w(logTag, "FAILURE: Transaction or sourceSmsId is null.")
                return@launch
            }
            Log.d(logTag, "Found transaction: $transaction")

            val smsMessage = smsRepository.getSmsDetailsById(transaction.sourceSmsId)
            if (smsMessage == null) {
                Log.w(logTag, "FAILURE: Could not find original SMS for sourceSmsId: ${transaction.sourceSmsId}")
                return@launch
            }
            Log.d(logTag, "Found original SMS: ${smsMessage.body}")

            // --- FIX: Pass the missing merchantCategoryMappingDao argument ---
            val potentialTxn = SmsParser.parse(
                smsMessage,
                emptyMap(),
                db.customSmsRuleDao(),
                db.merchantRenameRuleDao(),
                db.ignoreRuleDao(),
                db.merchantCategoryMappingDao()
            )
            Log.d(logTag, "SmsParser result: $potentialTxn")

            if (potentialTxn != null) {
                if (potentialTxn.merchantName != null && potentialTxn.merchantName != transaction.description) {
                    Log.d(logTag, "Updating description for txnId $transactionId from '${transaction.description}' to '${potentialTxn.merchantName}'")
                    transactionRepository.updateDescription(transactionId, potentialTxn.merchantName)
                }

                potentialTxn.potentialAccount?.let { parsedAccount ->
                    Log.d(logTag, "Parsed account found: Name='${parsedAccount.formattedName}', Type='${parsedAccount.accountType}'")
                    val currentAccount = accountRepository.getAccountById(transaction.accountId).first()
                    Log.d(logTag, "Current account in DB: Name='${currentAccount?.name}'")

                    if (currentAccount?.name?.equals(parsedAccount.formattedName, ignoreCase = true) == false) {
                        Log.d(logTag, "Account names differ. Proceeding with find-or-create.")

                        var account = db.accountDao().findByName(parsedAccount.formattedName)
                        Log.d(logTag, "Attempting to find existing account by name '${parsedAccount.formattedName}'. Found: ${account != null}")

                        if (account == null) {
                            Log.d(logTag, "Account not found. Creating new one.")
                            val newAccount = Account(name = parsedAccount.formattedName, type = parsedAccount.accountType)
                            val newId = accountRepository.insert(newAccount)
                            Log.d(logTag, "Inserted new account, got ID: $newId")
                            account = db.accountDao().getAccountById(newId.toInt()).first()
                            Log.d(logTag, "Re-fetched new account from DB: $account")
                        }

                        if (account != null) {
                            Log.d(logTag, "SUCCESS: Updating transaction $transactionId to use accountId ${account.id} ('${account.name}')")
                            transactionRepository.updateAccountId(transactionId, account.id)
                        } else {
                            Log.e(logTag, "FAILURE: Failed to find or create the new account '${parsedAccount.formattedName}'.")
                        }
                    } else {
                        Log.d(logTag, "Account names are the same. No update needed.")
                    }
                } ?: Log.d(logTag, "No potential account was parsed from the SMS.")
            } else {
                Log.d(logTag, "SmsParser returned null. No updates to perform.")
            }
            Log.d(logTag, "--- Reparse finished for transactionId: $transactionId ---")
        }
    }


    fun updateFilterKeyword(keyword: String) {
        _filterState.update { it.copy(keyword = keyword) }
    }

    fun updateFilterAccount(account: Account?) {
        _filterState.update { it.copy(account = account) }
    }

    fun updateFilterCategory(category: Category?) {
        _filterState.update { it.copy(category = category) }
    }

    fun clearFilters() {
        _filterState.value = TransactionFilterState()
    }

    fun onFilterClick() {
        _showFilterSheet.value = true
    }

    fun onFilterSheetDismiss() {
        _showFilterSheet.value = false
    }

    fun setSelectedMonth(calendar: Calendar) {
        _selectedMonth.value = calendar
    }

    fun createAccount(name: String, type: String, onAccountCreated: (Account) -> Unit) {
        if (name.isBlank() || type.isBlank()) return
        viewModelScope.launch {
            val existingAccount = db.accountDao().findByName(name)
            if (existingAccount != null) {
                _validationError.value = "An account named '$name' already exists."
                return@launch
            }

            val newAccountId = accountRepository.insert(Account(name = name, type = type))
            accountRepository.getAccountById(newAccountId.toInt()).first()?.let { newAccount ->
                onAccountCreated(newAccount)
            }
        }
    }

    fun createCategory(name: String, iconKey: String, colorKey: String, onCategoryCreated: (Category) -> Unit) {
        if (name.isBlank()) return
        viewModelScope.launch {
            val existingCategory = db.categoryDao().findByName(name)
            if (existingCategory != null) {
                _validationError.value = "A category named '$name' already exists."
                return@launch
            }

            val usedColorKeys = allCategories.first().map { it.colorKey }
            val finalIconKey = if (iconKey == "category") "letter_default" else iconKey
            val finalColorKey = if (colorKey == "gray_light") CategoryIconHelper.getNextAvailableColor(usedColorKeys) else colorKey

            val newCategory = Category(name = name, iconKey = finalIconKey, colorKey = finalColorKey)
            val newCategoryId = categoryRepository.insert(newCategory)
            categoryRepository.getCategoryById(newCategoryId.toInt())?.let { createdCategory ->
                onCategoryCreated(createdCategory)
            }
        }
    }

    fun attachPhotoToTransaction(transactionId: Int, sourceUri: Uri) {
        viewModelScope.launch {
            val localPath = saveImageToInternalStorage(sourceUri)
            if (localPath != null) {
                transactionRepository.addImageToTransaction(transactionId, localPath)
            }
        }
    }

    fun deleteTransactionImage(image: TransactionImage) {
        viewModelScope.launch {
            transactionRepository.deleteImage(image)
            withContext(Dispatchers.IO) {
                try {
                    File(image.imageUri).delete()
                } catch (e: Exception) {
                    Log.e(TAG, "Failed to delete image file: ${image.imageUri}", e)
                }
            }
        }
    }

    fun loadImagesForTransaction(transactionId: Int) {
        viewModelScope.launch {
            transactionRepository.getImagesForTransaction(transactionId).collect {
                _transactionImages.value = it
            }
        }
    }

    private suspend fun saveImageToInternalStorage(sourceUri: Uri): String? {
        return withContext(Dispatchers.IO) {
            try {
                val inputStream = context.contentResolver.openInputStream(sourceUri)
                val fileName = "txn_attach_${System.currentTimeMillis()}.jpg"
                val file = File(context.filesDir, fileName)
                val outputStream = FileOutputStream(file)
                inputStream?.use { input ->
                    outputStream.use { output ->
                        input.copyTo(output)
                    }
                }
                file.absolutePath
            } catch (e: Exception) {
                Log.e("TransactionViewModel", "Error saving image to internal storage", e)
                null
            }
        }
    }

    fun updateTransactionDescription(id: Int, newDescription: String) = viewModelScope.launch(Dispatchers.IO) {
        if (newDescription.isNotBlank()) {
            val transaction = transactionRepository.getTransactionById(id).first() ?: return@launch
            val originalDescription = transaction.originalDescription ?: transaction.description

            transactionRepository.updateDescription(id, newDescription)

            val similar = transactionRepository.findSimilarTransactions(originalDescription, id)
            if (similar.isNotEmpty()) {
                _retroUpdateSheetState.value = RetroUpdateSheetState(
                    originalDescription = originalDescription,
                    newDescription = newDescription,
                    newCategoryId = null,
                    similarTransactions = similar,
                    selectedIds = similar.map { it.id }.toSet(),
                    isLoading = false
                )
            }
        }
    }

    fun updateTransactionAmount(id: Int, amountStr: String) = viewModelScope.launch {
        amountStr.toDoubleOrNull()?.let {
            if (it > 0) {
                transactionRepository.updateAmount(id, it)
            }
        }
    }

    fun updateTransactionNotes(id: Int, notes: String) = viewModelScope.launch {
        transactionRepository.updateNotes(id, notes.takeIf { it.isNotBlank() })
    }

    fun updateTransactionCategory(id: Int, categoryId: Int?) = viewModelScope.launch(Dispatchers.IO) {
        val transaction = transactionRepository.getTransactionById(id).first() ?: return@launch
        val originalDescription = transaction.originalDescription ?: transaction.description

        transactionRepository.updateCategoryId(id, categoryId)

        if (categoryId != null && transaction.sourceSmsId != null && !transaction.originalDescription.isNullOrBlank()) {
            val mapping = MerchantCategoryMapping(
                parsedName = transaction.originalDescription,
                categoryId = categoryId
            )
            merchantCategoryMappingRepository.insert(mapping)
            Log.d(TAG, "Learned category mapping for '${transaction.originalDescription}' -> categoryId $categoryId")
        }

        val similar = transactionRepository.findSimilarTransactions(originalDescription, id)
        if (similar.isNotEmpty()) {
            _retroUpdateSheetState.value = RetroUpdateSheetState(
                originalDescription = originalDescription,
                newDescription = null,
                newCategoryId = categoryId,
                similarTransactions = similar,
                selectedIds = similar.map { it.id }.toSet(),
                isLoading = false
            )
        }
    }


    fun updateTransactionAccount(id: Int, accountId: Int) = viewModelScope.launch {
        transactionRepository.updateAccountId(id, accountId)
    }

    fun updateTransactionDate(id: Int, date: Long) = viewModelScope.launch {
        transactionRepository.updateDate(id, date)
    }

    fun updateTransactionExclusion(id: Int, isExcluded: Boolean) = viewModelScope.launch {
        transactionRepository.updateExclusionStatus(id, isExcluded)
    }

    fun updateTagsForTransaction(transactionId: Int) = viewModelScope.launch {
        Log.d(TAG, "updateTagsForTransaction: Saving tags for txn ID $transactionId. Tags: ${_selectedTags.value.map { it.name }}")
        transactionRepository.updateTagsForTransaction(transactionId, _selectedTags.value)
    }

    fun onTagSelected(tag: Tag) {
        Log.d(TAG, "onTagSelected: Toggled tag '${tag.name}' (ID: ${tag.id})")
        _selectedTags.update { if (tag in it) it - tag else it + tag }
    }

    fun addTagOnTheGo(tagName: String) {
        if (tagName.isNotBlank()) {
            viewModelScope.launch {
                val existingTag = db.tagDao().findByName(tagName)
                if (existingTag != null) {
                    _validationError.value = "A tag named '$tagName' already exists."
                    return@launch
                }
                val newTag = Tag(name = tagName)
                val newId = tagRepository.insert(newTag)
                if (newId != -1L) {
                    _selectedTags.update { it + newTag.copy(id = newId.toInt()) }
                }
            }
        }
    }

    fun loadTagsForTransaction(transactionId: Int) {
        if (currentTxnIdForTags == transactionId && areTagsLoadedForCurrentTxn) {
            return
        }
        viewModelScope.launch {
            val initialTags = transactionRepository.getTagsForTransaction(transactionId).first()
            _selectedTags.value = initialTags.toSet()
            areTagsLoadedForCurrentTxn = true
            currentTxnIdForTags = transactionId
        }
    }

    fun clearSelectedTags() {
        _selectedTags.value = emptySet()
        areTagsLoadedForCurrentTxn = false
        currentTxnIdForTags = null
    }

    fun getTransactionById(id: Int): Flow<Transaction?> {
        return transactionRepository.getTransactionById(id)
    }

    suspend fun approveSmsTransaction(
        potentialTxn: PotentialTransaction,
        description: String,
        categoryId: Int?,
        notes: String?,
        tags: Set<Tag>
    ): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                val accountName = potentialTxn.potentialAccount?.formattedName ?: "Unknown Account"
                val accountType = potentialTxn.potentialAccount?.accountType ?: "General"

                var account = db.accountDao().findByName(accountName)
                if (account == null) {
                    val newAccount = Account(name = accountName, type = accountType)
                    accountRepository.insert(newAccount)
                    account = db.accountDao().findByName(accountName)
                }

                if (account == null) {
                    return@withContext false
                }

                val newTransaction = Transaction(
                    description = description,
                    originalDescription = potentialTxn.merchantName,
                    categoryId = categoryId,
                    amount = potentialTxn.amount,
                    date = System.currentTimeMillis(),
                    accountId = account.id,
                    notes = notes,
                    transactionType = potentialTxn.transactionType,
                    sourceSmsId = potentialTxn.sourceSmsId,
                    sourceSmsHash = potentialTxn.sourceSmsHash,
                    source = "Imported"
                )
                transactionRepository.insertTransactionWithTags(newTransaction, tags)

                if (categoryId != null && potentialTxn.merchantName != null) {
                    val mapping = MerchantCategoryMapping(
                        parsedName = potentialTxn.merchantName,
                        categoryId = categoryId
                    )
                    merchantCategoryMappingRepository.insert(mapping)
                    Log.d(TAG, "Saved learned category mapping: ${potentialTxn.merchantName} -> Category ID $categoryId")
                }

                true
            } catch (e: Exception) {
                false
            }
        }
    }

    fun updateTransaction(transaction: Transaction): Boolean {
        _validationError.value = null

        if (transaction.description.isBlank()) {
            _validationError.value = "Description cannot be empty."
            return false
        }
        if (transaction.amount <= 0.0) {
            _validationError.value = "Amount must be a valid, positive number."
            return false
        }

        viewModelScope.launch {
            transactionRepository.updateTransactionWithTags(transaction, _selectedTags.value)
        }
        return true
    }

    fun deleteTransaction(transaction: Transaction) =
        viewModelScope.launch {
            transactionRepository.delete(transaction)
        }

    fun clearError() {
        _validationError.value = null
    }

    fun dismissRetroUpdateSheet() {
        _retroUpdateSheetState.value = null
    }

    fun toggleRetroUpdateSelection(id: Int) {
        _retroUpdateSheetState.update { currentState ->
            currentState?.copy(
                selectedIds = currentState.selectedIds.toMutableSet().apply {
                    if (id in this) remove(id) else add(id)
                }
            )
        }
    }

    fun toggleRetroUpdateSelectAll() {
        _retroUpdateSheetState.update { currentState ->
            currentState?.let {
                if (it.selectedIds.size == it.similarTransactions.size) {
                    it.copy(selectedIds = emptySet()) // Deselect all
                } else {
                    it.copy(selectedIds = it.similarTransactions.map { t -> t.id }.toSet()) // Select all
                }
            }
        }
    }

    fun performBatchUpdate() {
        viewModelScope.launch {
            val state = _retroUpdateSheetState.value ?: return@launch
            val idsToUpdate = state.selectedIds.toList()
            if (idsToUpdate.isEmpty()) return@launch

            state.newDescription?.let {
                transactionRepository.updateDescriptionForIds(idsToUpdate, it)
            }
            state.newCategoryId?.let {
                transactionRepository.updateCategoryForIds(idsToUpdate, it)
            }
            dismissRetroUpdateSheet()
        }
    }
}-e 


================== FILE: ./app/src/main/java/TransactionDetails.kt ==================
package io.pm.finlight

import androidx.room.Embedded
import androidx.room.Relation

data class TransactionDetails(
    @Embedded
    val transaction: Transaction,
    @Relation(
        parentColumn = "id",
        entityColumn = "transactionId"
    )
    val images: List<TransactionImage>, // --- NEW: Add relation to images ---
    val accountName: String?,
    val categoryName: String?,
    val categoryIconKey: String?,
    val categoryColorKey: String?
)
-e 


================== FILE: ./app/src/main/java/CsvValidationReport.kt ==================
package io.pm.finlight

/**
 * An enum to represent the validation status of a single row from the CSV.
 */
enum class CsvRowStatus {
    VALID,
    INVALID_COLUMN_COUNT,
    INVALID_DATE,
    INVALID_AMOUNT,
    ACCOUNT_NOT_FOUND,
    CATEGORY_NOT_FOUND,
    NEEDS_ACCOUNT_CREATION,
    NEEDS_CATEGORY_CREATION,
    NEEDS_BOTH_CREATION,
}

/**
 * A data class representing a single, reviewable row from the imported CSV file.
 * It holds the original data and its current validation status.
 */
data class ReviewableRow(
    val lineNumber: Int,
    var rowData: List<String>,
    var status: CsvRowStatus,
    var statusMessage: String,
)

/**
 * A data class to hold the full results of a CSV validation process.
 */
data class CsvValidationReport(
    val reviewableRows: List<ReviewableRow> = emptyList(),
    val totalRowCount: Int = 0,
)
-e 


================== FILE: ./app/src/main/java/MerchantCategoryMappingDao.kt ==================
package io.pm.finlight

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query

/**
 * Data Access Object (DAO) for the MerchantCategoryMapping entity.
 */
@Dao
interface MerchantCategoryMappingDao {

    /**
     * Inserts a new merchant-category mapping. If a mapping for the merchant
     * already exists, it will be replaced with the new one.
     *
     * @param mapping The MerchantCategoryMapping object to insert or update.
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(mapping: MerchantCategoryMapping)

    /**
     * Retrieves the learned category ID for a given merchant name.
     *
     * @param parsedName The name of the merchant to look up.
     * @return The associated category ID (Int), or null if no mapping exists.
     */
    @Query("SELECT categoryId FROM merchant_category_mapping WHERE parsedName = :parsedName")
    suspend fun getCategoryIdForMerchant(parsedName: String): Int?
}
-e 


================== FILE: ./app/src/main/java/MonthlySummaryWorker.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/MonthlySummaryWorker.kt
// REASON: Added a call to ReminderManager.scheduleMonthlySummary at the end of the
// worker's execution to create a continuous chain of precisely scheduled tasks.
// =================================================================================
package io.pm.finlight

import android.content.Context
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.util.Calendar
import kotlin.math.roundToInt

class MonthlySummaryWorker(
    private val context: Context,
    workerParams: WorkerParameters
) : CoroutineWorker(context, workerParams) {

    override suspend fun doWork(): Result {
        return withContext(Dispatchers.IO) {
            try {
                Log.d("MonthlySummaryWorker", "Worker starting...")
                val transactionDao = AppDatabase.getInstance(context).transactionDao()

                // --- Date range for LAST MONTH ---
                val lastMonthCalendar = Calendar.getInstance().apply { add(Calendar.MONTH, -1) }
                val lastMonthEnd = Calendar.getInstance().apply { set(Calendar.DAY_OF_MONTH, 1); add(Calendar.DAY_OF_MONTH, -1); set(Calendar.HOUR_OF_DAY, 23); set(Calendar.MINUTE, 59) }.timeInMillis
                val lastMonthStart = Calendar.getInstance().apply { add(Calendar.MONTH, -1); set(Calendar.DAY_OF_MONTH, 1); set(Calendar.HOUR_OF_DAY, 0); set(Calendar.MINUTE, 0) }.timeInMillis

                // --- Date range for PREVIOUS-TO-LAST MONTH ---
                val prevMonthEnd = Calendar.getInstance().apply { add(Calendar.MONTH, -1); set(Calendar.DAY_OF_MONTH, 1); add(Calendar.DAY_OF_MONTH, -1); set(Calendar.HOUR_OF_DAY, 23); set(Calendar.MINUTE, 59) }.timeInMillis
                val prevMonthStart = Calendar.getInstance().apply { add(Calendar.MONTH, -2); set(Calendar.DAY_OF_MONTH, 1); set(Calendar.HOUR_OF_DAY, 0); set(Calendar.MINUTE, 0) }.timeInMillis


                val lastMonthSummary = transactionDao.getFinancialSummaryForRange(lastMonthStart, lastMonthEnd)
                val lastMonthExpenses = lastMonthSummary?.totalExpenses ?: 0.0

                val prevMonthSummary = transactionDao.getFinancialSummaryForRange(prevMonthStart, prevMonthEnd)
                val prevMonthExpenses = prevMonthSummary?.totalExpenses ?: 0.0

                val topCategories = transactionDao.getTopSpendingCategoriesForRange(lastMonthStart, lastMonthEnd)

                val percentageChange = if (prevMonthExpenses > 0) {
                    ((lastMonthExpenses - prevMonthExpenses) / prevMonthExpenses * 100).roundToInt()
                } else null

                NotificationHelper.showMonthlySummaryNotification(context, lastMonthCalendar, lastMonthExpenses, percentageChange, topCategories)

                ReminderManager.scheduleMonthlySummary(context)
                Log.d("MonthlySummaryWorker", "Worker finished and rescheduled.")
                Result.success()
            } catch (e: Exception) {
                Log.e("MonthlySummaryWorker", "Worker failed", e)
                Result.retry()
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/NavItems.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/NavItems.kt
// REASON: FEATURE - Added a new entry for "goals_screen" to the screenTitles
// map, ensuring the new Savings Goals screen will have the correct title in
// the app's top bar.
// UPDATE: Added new entries for the reorganized settings screens.
// =================================================================================
package io.pm.finlight

import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Assessment
import androidx.compose.material.icons.filled.Home
import androidx.compose.material.icons.filled.Person
import androidx.compose.material.icons.filled.Receipt
import androidx.compose.ui.graphics.vector.ImageVector

sealed class BottomNavItem(val route: String, val icon: ImageVector, val label: String) {
    object Dashboard : BottomNavItem("dashboard", Icons.Filled.Home, "Dashboard")
    object Transactions : BottomNavItem("transaction_list", Icons.Filled.Receipt, "Transactions")
    object Reports : BottomNavItem("reports_screen", Icons.Filled.Assessment, "Reports")
    object Profile : BottomNavItem("profile", Icons.Filled.Person, "Profile")
}
val screenTitles = mapOf(
    BottomNavItem.Dashboard.route to "Dashboard",
    BottomNavItem.Transactions.route to "All Transactions",
    BottomNavItem.Reports.route to "Reports",
    BottomNavItem.Profile.route to "Profile",
    "settings_screen" to "App Settings",
    "add_transaction" to "Add Transaction",
    "transaction_detail/{transactionId}" to "Edit Transaction",
    "account_list" to "Your Accounts",
    "add_account" to "Add New Account",
    "edit_account/{accountId}" to "Edit Account",
    "account_detail/{accountId}" to "Account Details",
    "budget_screen" to "Manage Budgets",
    "add_budget" to "Add Category Budget",
    "edit_budget/{budgetId}" to "Edit Budget",
    "category_list" to "Manage Categories",
    "recurring_transactions" to "Recurring Transactions",
    "add_recurring_transaction?ruleId={ruleId}" to "Add/Edit Recurring Rule",
    "search_screen" to "Search",
    "review_sms_screen" to "Review SMS Transactions",
    "approve_transaction_screen/{amount}/{type}/{merchant}/{smsId}/{smsSender}" to "Approve Transaction",
    "tag_management" to "Manage Tags",
    "edit_profile" to "Edit Profile",
    "income_screen" to "Income",
    "rule_creation_screen?potentialTransactionJson={potentialTransactionJson}&ruleId={ruleId}" to "Create/Edit Rule",
    "manage_parse_rules" to "Manage Parsing Rules",
    "manage_ignore_rules" to "Manage Ignore List",
    "link_transaction_screen/{potentialTransactionJson}" to "Link to Existing Transaction",
    "retrospective_update_screen/{transactionId}/{originalDescription}?newDescription={newDescription}&newCategoryId={newCategoryId}" to "Update Similar",
    "goals_screen" to "Savings Goals",
    // --- NEW: Titles for reorganized settings screens ---
    "appearance_settings" to "Theme & Appearance",
    "automation_settings" to "Automation & AI",
    "notification_settings" to "Notifications",
    "data_settings" to "Security & Data"
)
-e 


================== FILE: ./app/src/main/java/DashboardCardType.kt ==================
package io.pm.finlight

/**
 * Represents the different types of cards that can be displayed on the dashboard.
 * Used for managing customizable dashboard layouts.
 */
enum class DashboardCardType {
    // --- UPDATED: Replaced OVERALL_BUDGET and QUICK_STATS with a single HERO_BUDGET ---
    HERO_BUDGET,
    QUICK_ACTIONS,
    NET_WORTH,
    RECENT_ACTIVITY,
    ACCOUNTS_CAROUSEL,
    BUDGET_WATCH
}
-e 


================== FILE: ./app/src/main/java/WeeklySummaryWorker.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/WeeklySummaryWorker.kt
// REASON: FIX - The calculation logic has been updated to explicitly filter out
// excluded transactions. The `forEach` loop was replaced with more efficient
// `filter` and `sumOf` calls, which now include the `!details.transaction.isExcluded`
// condition. This ensures the weekly summary report is accurate.
// =================================================================================
package io.pm.finlight

import android.content.Context
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.withContext
import java.util.Calendar
import kotlin.math.roundToInt

class WeeklySummaryWorker(
    private val context: Context,
    workerParams: WorkerParameters,
) : CoroutineWorker(context, workerParams) {
    override suspend fun doWork(): Result {
        return withContext(Dispatchers.IO) {
            try {
                Log.d("WeeklySummaryWorker", "Worker starting...")
                val transactionDao = AppDatabase.getInstance(context).transactionDao()

                // Date range for LAST 7 DAYS
                val thisWeekEnd = Calendar.getInstance().timeInMillis
                val thisWeekStart = Calendar.getInstance().apply { add(Calendar.DAY_OF_YEAR, -7) }.timeInMillis

                // Date range for PREVIOUS 7 DAYS (8-14 days ago)
                val lastWeekEnd = Calendar.getInstance().apply { add(Calendar.DAY_OF_YEAR, -8) }.timeInMillis
                val lastWeekStart = Calendar.getInstance().apply { add(Calendar.DAY_OF_YEAR, -14) }.timeInMillis

                val thisWeekSummary = transactionDao.getFinancialSummaryForRange(thisWeekStart, thisWeekEnd)
                val thisWeekExpenses = thisWeekSummary?.totalExpenses ?: 0.0

                val lastWeekSummary = transactionDao.getFinancialSummaryForRange(lastWeekStart, lastWeekEnd)
                val lastWeekExpenses = lastWeekSummary?.totalExpenses ?: 0.0

                val topCategories = transactionDao.getTopSpendingCategoriesForRange(thisWeekStart, thisWeekEnd)

                val percentageChange = if (lastWeekExpenses > 0) {
                    ((thisWeekExpenses - lastWeekExpenses) / lastWeekExpenses * 100).roundToInt()
                } else null

                NotificationHelper.showWeeklySummaryNotification(context, thisWeekExpenses, percentageChange, topCategories)

                ReminderManager.scheduleWeeklySummary(context)
                Log.d("WeeklySummaryWorker", "Worker finished and rescheduled.")
                Result.success()
            } catch (e: Exception) {
                Log.e("WeeklySummaryWorker", "Worker failed", e)
                Result.retry()
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/IncomeViewModel.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/IncomeViewModel.kt
// REASON: Added state management for filters and refactored data flows to be
// reactive to filter changes, enabling a dynamic filtering experience.
// BUG FIX: The ViewModel now correctly exposes its own lists of accounts and
// categories, making it self-sufficient and removing the dependency on
// TransactionViewModel from the UI layer.
// =================================================================================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.*
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Date
import java.util.Locale

@OptIn(ExperimentalCoroutinesApi::class)
class IncomeViewModel(application: Application) : AndroidViewModel(application) {

    private val transactionRepository: TransactionRepository
    // --- NEW: Add repositories for accounts and categories ---
    val accountRepository: AccountRepository
    val categoryRepository: CategoryRepository

    private val _selectedMonth = MutableStateFlow(Calendar.getInstance())
    val selectedMonth: StateFlow<Calendar> = _selectedMonth.asStateFlow()

    private val _filterState = MutableStateFlow(TransactionFilterState())
    val filterState: StateFlow<TransactionFilterState> = _filterState.asStateFlow()

    private val combinedState: Flow<Pair<Calendar, TransactionFilterState>> =
        _selectedMonth.combine(_filterState) { month, filters ->
            Pair(month, filters)
        }

    // --- NEW: Expose account and category flows ---
    val allAccounts: StateFlow<List<Account>>
    val allCategories: Flow<List<Category>>

    val incomeTransactionsForSelectedMonth: StateFlow<List<TransactionDetails>> = combinedState.flatMapLatest { (calendar, filters) ->
        val monthStart = (calendar.clone() as Calendar).apply { set(Calendar.DAY_OF_MONTH, 1); set(Calendar.HOUR_OF_DAY, 0); set(Calendar.MINUTE, 0); set(Calendar.SECOND, 0) }.timeInMillis
        val monthEnd = (calendar.clone() as Calendar).apply { add(Calendar.MONTH, 1); set(Calendar.DAY_OF_MONTH, 1); add(Calendar.DAY_OF_MONTH, -1); set(Calendar.HOUR_OF_DAY, 23); set(Calendar.MINUTE, 59); set(Calendar.SECOND, 59) }.timeInMillis
        transactionRepository.getIncomeTransactionsForRange(monthStart, monthEnd, filters.keyword.takeIf { it.isNotBlank() }, filters.account?.id, filters.category?.id)
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

    val totalIncomeForSelectedMonth: StateFlow<Double> = incomeTransactionsForSelectedMonth.map { transactions ->
        transactions.sumOf { it.transaction.amount }
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0.0)

    val incomeByCategoryForSelectedMonth: StateFlow<List<CategorySpending>> = combinedState.flatMapLatest { (calendar, filters) ->
        val monthStart = (calendar.clone() as Calendar).apply { set(Calendar.DAY_OF_MONTH, 1); set(Calendar.HOUR_OF_DAY, 0); set(Calendar.MINUTE, 0); set(Calendar.SECOND, 0) }.timeInMillis
        val monthEnd = (calendar.clone() as Calendar).apply { add(Calendar.MONTH, 1); set(Calendar.DAY_OF_MONTH, 1); add(Calendar.DAY_OF_MONTH, -1); set(Calendar.HOUR_OF_DAY, 23); set(Calendar.MINUTE, 59); set(Calendar.SECOND, 59) }.timeInMillis
        transactionRepository.getIncomeByCategoryForMonth(monthStart, monthEnd, filters.keyword.takeIf { it.isNotBlank() }, filters.account?.id, filters.category?.id)
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

    val monthlySummaries: StateFlow<List<MonthlySummaryItem>>

    init {
        val db = AppDatabase.getInstance(application)
        transactionRepository = TransactionRepository(db.transactionDao())
        accountRepository = AccountRepository(db.accountDao())
        categoryRepository = CategoryRepository(db.categoryDao())

        allAccounts = accountRepository.allAccounts.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )
        allCategories = categoryRepository.allCategories

        val twelveMonthsAgo = Calendar.getInstance().apply { add(Calendar.YEAR, -1) }.timeInMillis
        monthlySummaries = transactionRepository.getMonthlyTrends(twelveMonthsAgo)
            .map { trends ->
                val dateFormat = SimpleDateFormat("yyyy-MM", Locale.getDefault())
                val monthMap = trends.associate {
                    val cal = Calendar.getInstance().apply {
                        time = dateFormat.parse(it.monthYear) ?: Date()
                    }
                    (cal.get(Calendar.YEAR) * 100 + cal.get(Calendar.MONTH)) to it.totalIncome
                }

                (0..11).map { i ->
                    val cal = Calendar.getInstance().apply { add(Calendar.MONTH, -i) }
                    val key = cal.get(Calendar.YEAR) * 100 + cal.get(Calendar.MONTH)
                    val income = monthMap[key] ?: 0.0
                    MonthlySummaryItem(calendar = cal, totalSpent = income)
                }.reversed()
            }
            .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())
    }

    fun setSelectedMonth(calendar: Calendar) {
        _selectedMonth.value = calendar
    }

    fun updateFilterKeyword(keyword: String) {
        _filterState.update { it.copy(keyword = keyword) }
    }

    fun updateFilterAccount(account: Account?) {
        _filterState.update { it.copy(account = account) }
    }

    fun updateFilterCategory(category: Category?) {
        _filterState.update { it.copy(category = category) }
    }

    fun clearFilters() {
        _filterState.value = TransactionFilterState()
    }
}
-e 


================== FILE: ./app/src/main/java/SearchViewModel.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/SearchViewModel.kt
// REASON: Implemented a dynamic, debounced search mechanism. The ViewModel now
// automatically triggers a search query 300ms after any filter or keyword
// changes, removing the need for a manual "Apply" button.
// =================================================================================
package io.pm.finlight

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.FlowPreview
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch

data class SearchUiState(
    val keyword: String = "",
    val selectedAccount: Account? = null,
    val selectedCategory: Category? = null,
    val transactionType: String = "All", // "All", "Income", "Expense"
    val startDate: Long? = null,
    val endDate: Long? = null,
    val accounts: List<Account> = emptyList(),
    val categories: List<Category> = emptyList(),
    val hasSearched: Boolean = false,
)

@OptIn(FlowPreview::class)
class SearchViewModel(
    private val transactionDao: TransactionDao,
    private val accountDao: AccountDao,
    private val categoryDao: CategoryDao,
) : ViewModel() {
    private val _uiState = MutableStateFlow(SearchUiState())
    val uiState: StateFlow<SearchUiState> = _uiState.asStateFlow()

    private val _searchResults = MutableStateFlow<List<TransactionDetails>>(emptyList())
    val searchResults: StateFlow<List<TransactionDetails>> = _searchResults.asStateFlow()

    init {
        // Load initial filter options (accounts and categories)
        viewModelScope.launch {
            accountDao.getAllAccounts().collect { accounts ->
                _uiState.update { it.copy(accounts = accounts) }
            }
        }
        viewModelScope.launch {
            categoryDao.getAllCategories().collect { categories ->
                _uiState.update { it.copy(categories = categories) }
            }
        }

        // --- NEW: Reactive search logic ---
        // This flow automatically executes a search whenever the UI state changes,
        // with a 300ms debounce to prevent excessive queries while typing.
        viewModelScope.launch {
            uiState
                .debounce(300L)
                .collectLatest { state -> // Use collectLatest to cancel previous searches if a new state arrives
                    val filtersAreActive = state.selectedAccount != null ||
                            state.selectedCategory != null ||
                            state.transactionType != "All" ||
                            state.startDate != null ||
                            state.endDate != null

                    if (state.keyword.isNotBlank() || filtersAreActive) {
                        _uiState.update { it.copy(hasSearched = true) }
                        val results = transactionDao.searchTransactions(
                            keyword = state.keyword,
                            accountId = state.selectedAccount?.id,
                            categoryId = state.selectedCategory?.id,
                            transactionType = if (state.transactionType.equals("All", ignoreCase = true)) null else state.transactionType.lowercase(),
                            startDate = state.startDate,
                            endDate = state.endDate
                        )
                        _searchResults.value = results
                    } else {
                        // Clear results and search status if no filters/keyword are active
                        _searchResults.value = emptyList()
                        _uiState.update { it.copy(hasSearched = false) }
                    }
                }
        }
    }

    fun onKeywordChange(newKeyword: String) {
        _uiState.update { it.copy(keyword = newKeyword) }
    }

    fun onAccountChange(account: Account?) {
        _uiState.update { it.copy(selectedAccount = account) }
    }

    fun onCategoryChange(category: Category?) {
        _uiState.update { it.copy(selectedCategory = category) }
    }

    fun onTypeChange(type: String?) {
        _uiState.update { it.copy(transactionType = type ?: "All") }
    }

    fun onDateChange(
        start: Long? = _uiState.value.startDate,
        end: Long? = _uiState.value.endDate,
    ) {
        _uiState.update { it.copy(startDate = start, endDate = end) }
    }

    fun clearFilters() {
        _uiState.value =
            SearchUiState(
                accounts = _uiState.value.accounts,
                categories = _uiState.value.categories,
            )
        // Results will clear automatically due to the reactive flow
    }

    // The manual executeSearch function is no longer needed.
}
-e 


================== FILE: ./app/src/main/java/GoalDao.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/GoalDao.kt
// REASON: NEW FILE - Defines the DAO for the Goal entity, providing all
// necessary CRUD operations and a query to fetch goals with their associated
// account names for display in the UI.
// =================================================================================
package io.pm.finlight

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import kotlinx.coroutines.flow.Flow

/**
 * A data class to hold a Goal and its associated account's name.
 */
data class GoalWithAccountName(
    val id: Int,
    val name: String,
    val targetAmount: Double,
    val savedAmount: Double,
    val targetDate: Long?,
    val accountId: Int,
    val accountName: String
)

@Dao
interface GoalDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(goal: Goal)

    @Update
    suspend fun update(goal: Goal)

    @Delete
    suspend fun delete(goal: Goal)

    @Query("SELECT * FROM goals WHERE id = :id")
    fun getGoalById(id: Int): Flow<Goal?>

    @Query("""
        SELECT
            g.id, g.name, g.targetAmount, g.savedAmount, g.targetDate, g.accountId, a.name as accountName
        FROM goals as g
        INNER JOIN accounts as a ON g.accountId = a.id
        ORDER BY g.targetDate ASC
    """)
    fun getAllGoalsWithAccountName(): Flow<List<GoalWithAccountName>>

    @Query("SELECT * FROM goals WHERE accountId = :accountId")
    fun getGoalsForAccount(accountId: Int): Flow<List<Goal>>
}
-e 


================== FILE: ./app/src/main/java/ManageIgnoreRulesViewModel.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ManageIgnoreRulesViewModel.kt
// REASON: FEATURE - The ViewModel is updated to handle the new distinction
// between default and user-added rules. It now includes a method to update a
// rule's `isEnabled` status, allowing users to toggle the default rules.
// BUG FIX - Renamed `updateRule` to `updateIgnoreRule` to provide a more
// specific function name and resolve a persistent compilation error.
// =================================================================================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

class ManageIgnoreRulesViewModel(application: Application) : AndroidViewModel(application) {

    private val ignoreRuleDao = AppDatabase.getInstance(application).ignoreRuleDao()

    /**
     * A flow of all ignore rules, collected as a StateFlow for the UI.
     */
    val allRules: StateFlow<List<IgnoreRule>> = ignoreRuleDao.getAll()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )

    /**
     * Adds a new ignore phrase to the database.
     * @param phrase The phrase to be added.
     */
    fun addIgnoreRule(phrase: String) {
        if (phrase.isNotBlank()) {
            viewModelScope.launch {
                // User-added rules are not default rules
                ignoreRuleDao.insert(IgnoreRule(phrase = phrase.trim(), isDefault = false))
            }
        }
    }

    /**
     * Updates an existing ignore rule, typically to toggle its enabled status.
     * @param rule The rule to be updated.
     */
    fun updateIgnoreRule(rule: IgnoreRule) {
        viewModelScope.launch {
            ignoreRuleDao.update(rule)
        }
    }

    /**
     * Deletes a given ignore rule from the database. This should only be called
     * for non-default rules.
     * @param rule The rule to be deleted.
     */
    fun deleteIgnoreRule(rule: IgnoreRule) {
        // Safety check to prevent deleting default rules
        if (!rule.isDefault) {
            viewModelScope.launch {
                ignoreRuleDao.delete(rule)
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/RecurringTransactionDao.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/RecurringTransactionDao.kt
// REASON: FEATURE - Added the `updateLastRunDate` function, which the worker will
// call after successfully creating a transaction from a rule. Also renamed `getAll`
// to `getAllRules` for clarity and consistency with the worker's implementation.
// REASON: FIX - Added a new suspend function `getAllRulesList()` for the worker to
// fetch a one-time list, resolving compilation errors. The original Flow-based
// function was renamed to `getAllRulesFlow()` for clarity.
// =================================================================================
package io.pm.finlight

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import kotlinx.coroutines.flow.Flow

@Dao
interface RecurringTransactionDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(recurringTransaction: RecurringTransaction)

    @Update
    suspend fun update(recurringTransaction: RecurringTransaction)

    @Delete
    suspend fun delete(recurringTransaction: RecurringTransaction)

    @Query("SELECT * FROM recurring_transactions ORDER BY startDate DESC")
    fun getAllRulesFlow(): Flow<List<RecurringTransaction>>

    @Query("SELECT * FROM recurring_transactions")
    suspend fun getAllRulesList(): List<RecurringTransaction>

    @Query("SELECT * FROM recurring_transactions WHERE id = :id")
    fun getById(id: Int): Flow<RecurringTransaction?>

    @Query("UPDATE recurring_transactions SET lastRunDate = :lastRunDate WHERE id = :id")
    suspend fun updateLastRunDate(id: Int, lastRunDate: Long)
}
-e 


================== FILE: ./app/src/main/java/MerchantMapping.kt ==================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

@Serializable
@Entity(tableName = "merchant_mappings")
data class MerchantMapping(
    @PrimaryKey
    val smsSender: String, // e.g., "AM-HDFCBK"
    val merchantName: String, // e.g., "McDonald's"
)
-e 


================== FILE: ./app/src/main/java/AccountWithBalance.kt ==================
package io.pm.finlight

import androidx.room.Embedded

/**
 * A data class to hold an Account and its dynamically calculated balance.
 * This is used for display purposes in the UI and is not a database entity.
 */
data class AccountWithBalance(
    @Embedded
    val account: Account,
    val balance: Double,
)
-e 


================== FILE: ./app/src/main/java/Account.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/Account.kt
// REASON: REFACTOR - A unique, case-insensitive index (`collate = NOCASE`) has
// been added to the 'name' column. This prevents duplicate account names with
// different casing (e.g., "SBI" and "sbi") from being created.
// =================================================================================
package io.pm.finlight

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.Index
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

@Serializable
@Entity(
    tableName = "accounts",
    // --- NEW: Add a unique, case-insensitive index to the name column ---
    indices = [Index(value = ["name"], unique = true, name = "index_accounts_name_nocase")]
)
data class Account(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    // --- UPDATED: Added COLLATE NOCASE to the column definition ---
    @ColumnInfo(name = "name", collate = ColumnInfo.NOCASE)
    val name: String,
    val type: String,
    // The balance field is intentionally removed from the database entity.
    // It will be calculated on-the-fly.
)-e 


================== FILE: ./app/src/main/java/SmsMessage.kt ==================
package io.pm.finlight

/**
 * A simple data class to hold the relevant information from an SMS message.
 */
data class SmsMessage(
    val id: Long,
    val sender: String,
    val body: String,
    val date: Long,
)
-e 


================== FILE: ./app/src/main/java/GoalViewModel.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/GoalViewModel.kt
// REASON: NEW FILE - Manages the business logic for the Savings Goals feature.
// It exposes goals, handles saving/deleting, and provides data for the UI.
// =================================================================================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

class GoalViewModel(application: Application) : AndroidViewModel(application) {

    private val goalRepository: GoalRepository
    val allGoals: StateFlow<List<GoalWithAccountName>>

    init {
        val db = AppDatabase.getInstance(application)
        goalRepository = GoalRepository(db.goalDao())
        allGoals = goalRepository.getAllGoalsWithAccountName()
            .stateIn(
                scope = viewModelScope,
                started = SharingStarted.WhileSubscribed(5000),
                initialValue = emptyList()
            )
    }

    fun getGoalById(id: Int): Flow<Goal?> {
        return goalRepository.getGoalById(id)
    }

    fun saveGoal(
        id: Int?,
        name: String,
        targetAmount: Double,
        savedAmount: Double,
        targetDate: Long?,
        accountId: Int
    ) {
        viewModelScope.launch {
            val goal = Goal(
                id = id ?: 0,
                name = name,
                targetAmount = targetAmount,
                savedAmount = savedAmount,
                targetDate = targetDate,
                accountId = accountId
            )
            if (id == null) {
                goalRepository.insert(goal)
            } else {
                goalRepository.update(goal)
            }
        }
    }

    fun deleteGoal(goal: Goal) {
        viewModelScope.launch {
            goalRepository.delete(goal)
        }
    }
}
-e 


================== FILE: ./app/src/main/java/MonthlyTrend.kt ==================
package io.pm.finlight

data class MonthlyTrend(
    val monthYear: String, // Format: "YYYY-MM"
    val totalIncome: Double,
    val totalExpenses: Double,
)
-e 


================== FILE: ./app/src/main/java/RecurringTransaction.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/RecurringTransaction.kt
// REASON: FEATURE - Added a new nullable `lastRunDate` field. This will store
// the timestamp of the last time a transaction was created from this rule,
// which is essential for the RecurringTransactionWorker to determine the next
// due date.
// =================================================================================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

@Serializable
@Entity(
    tableName = "recurring_transactions",
    indices = [
        Index(value = ["accountId"]),
        Index(value = ["categoryId"]),
    ],
    foreignKeys = [
        ForeignKey(
            entity = Account::class,
            parentColumns = ["id"],
            childColumns = ["accountId"],
            onDelete = ForeignKey.CASCADE,
        ),
        ForeignKey(
            entity = Category::class,
            parentColumns = ["id"],
            childColumns = ["categoryId"],
            onDelete = ForeignKey.SET_NULL,
        ),
    ],
)
data class RecurringTransaction(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val description: String,
    val amount: Double,
    val transactionType: String, // "income" or "expense"
    val recurrenceInterval: String, // e.g., "Daily", "Weekly", "Monthly", "Yearly"
    val startDate: Long, // Timestamp for the first occurrence
    val accountId: Int,
    val categoryId: Int?,
    // --- NEW: Track the last execution date of this rule ---
    val lastRunDate: Long? = null
)-e 


================== FILE: ./app/src/main/java/LinkTransactionViewModel.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/LinkTransactionViewModel.kt
// REASON: REFACTOR - The transaction matching logic has been updated. Instead
// of searching for specific matches, the ViewModel now fetches all transactions
// from the last two days (today and yesterday), providing the user with a
// broader, more useful list of candidates to link their recurring payment to.
// =================================================================================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.launch
import java.util.Calendar

class LinkTransactionViewModelFactory(
    private val application: Application,
    private val potentialTransaction: PotentialTransaction
) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(LinkTransactionViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return LinkTransactionViewModel(application, potentialTransaction) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

class LinkTransactionViewModel(
    application: Application,
    val potentialTransaction: PotentialTransaction
) : AndroidViewModel(application) {

    private val transactionRepository: TransactionRepository
    private val recurringTransactionDao: RecurringTransactionDao

    private val _linkableTransactions = MutableStateFlow<List<Transaction>>(emptyList())
    val linkableTransactions = _linkableTransactions.asStateFlow()

    init {
        val db = AppDatabase.getInstance(application)
        transactionRepository = TransactionRepository(db.transactionDao())
        recurringTransactionDao = db.recurringTransactionDao()
        findMatches()
    }

    private fun findMatches() {
        viewModelScope.launch {
            val todayEnd = Calendar.getInstance().apply {
                set(Calendar.HOUR_OF_DAY, 23)
                set(Calendar.MINUTE, 59)
                set(Calendar.SECOND, 59)
            }.timeInMillis

            val yesterdayStart = Calendar.getInstance().apply {
                add(Calendar.DAY_OF_YEAR, -1)
                set(Calendar.HOUR_OF_DAY, 0)
                set(Calendar.MINUTE, 0)
                set(Calendar.SECOND, 0)
            }.timeInMillis

            // Use the existing DAO method to get all transactions in the date range.
            // This returns a Flow, so we collect it to update our state.
            transactionRepository.getAllTransactionsForRange(yesterdayStart, todayEnd)
                .collect { transactions ->
                    _linkableTransactions.value = transactions
                }
        }
    }

    fun linkTransaction(selectedTransactionId: Int, onComplete: () -> Unit) {
        viewModelScope.launch {
            // Link the transaction by setting its hash
            potentialTransaction.sourceSmsHash?.let { hash ->
                transactionRepository.setSmsHash(selectedTransactionId, hash)
            }
            // Update the last run date of the rule to today
            val ruleId = potentialTransaction.sourceSmsId.toInt()
            recurringTransactionDao.updateLastRunDate(ruleId, System.currentTimeMillis())
            onComplete()
        }
    }

    fun remindTomorrow(onComplete: () -> Unit) {
        viewModelScope.launch {
            // To "remind tomorrow", we simply update the last run date to yesterday.
            // This makes the rule due again starting today.
            val yesterday = Calendar.getInstance().apply { add(Calendar.DAY_OF_YEAR, -1) }.timeInMillis
            val ruleId = potentialTransaction.sourceSmsId.toInt()
            recurringTransactionDao.updateLastRunDate(ruleId, yesterday)
            onComplete()
        }
    }
}
-e 


================== FILE: ./app/src/main/java/CategoryViewModel.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/CategoryViewModel.kt
// REASON: UX REFINEMENT - The `addCategory` function now performs a
// case-insensitive check to see if a category with the same name already exists
// before insertion. If it does, it sends a feedback message to the UI via the
// `uiEvent` channel, preventing silent failures.
// =================================================================================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.firstOrNull
import kotlinx.coroutines.flow.receiveAsFlow
import kotlinx.coroutines.launch

class CategoryViewModel(application: Application) : AndroidViewModel(application) {
    private val categoryRepository: CategoryRepository
    private val transactionRepository: TransactionRepository
    private val categoryDao: CategoryDao // Expose DAO for direct checks

    val allCategories: Flow<List<Category>>
    private val _uiEvent = Channel<String>()
    val uiEvent = _uiEvent.receiveAsFlow()

    init {
        val db = AppDatabase.getInstance(application)
        categoryDao = db.categoryDao() // Initialize DAO
        categoryRepository = CategoryRepository(categoryDao)
        transactionRepository = TransactionRepository(db.transactionDao())
        allCategories = categoryRepository.allCategories
    }

    suspend fun getCategoryById(id: Int): Category? {
        return allCategories.firstOrNull()?.find { it.id == id }
    }

    // --- UPDATED: Add pre-check and user feedback for duplicates ---
    fun addCategory(name: String, iconKey: String, colorKey: String) =
        viewModelScope.launch {
            // Check if a category with this name already exists
            val existingCategory = categoryDao.findByName(name)
            if (existingCategory != null) {
                _uiEvent.send("A category named '$name' already exists.")
                return@launch
            }

            val usedColorKeys = allCategories.firstOrNull()?.map { it.colorKey } ?: emptyList()
            val finalIconKey = if (iconKey == "category") "letter_default" else iconKey
            val finalColorKey = if (colorKey == "gray_light") {
                CategoryIconHelper.getNextAvailableColor(usedColorKeys)
            } else {
                colorKey
            }

            categoryRepository.insert(Category(name = name, iconKey = finalIconKey, colorKey = finalColorKey))
            _uiEvent.send("Category '$name' created.")
        }

    fun updateCategory(category: Category) =
        viewModelScope.launch {
            categoryRepository.update(category)
        }

    fun deleteCategory(category: Category) =
        viewModelScope.launch {
            val transactionCount = transactionRepository.countTransactionsForCategory(category.id)
            if (transactionCount == 0) {
                categoryRepository.delete(category)
                _uiEvent.send("Category '${category.name}' deleted.")
            } else {
                _uiEvent.send("Cannot delete '${category.name}'. It's used by $transactionCount transaction(s).")
            }
        }
}-e 


================== FILE: ./app/src/main/java/CategorySpending.kt ==================
package io.pm.finlight

/**
 * A simple data class to hold the results of a GROUP BY query,
 * containing the name of a category, its visual identifiers, and the total amount spent in it.
 */
data class CategorySpending(
    val categoryName: String,
    val totalAmount: Double,
    val colorKey: String?,
    val iconKey: String?
)
-e 


================== FILE: ./app/src/main/java/Category.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/Category.kt
// REASON: REFACTOR - The index on the 'name' column has been updated with
// `collate = NOCASE`. This makes the uniqueness constraint case-insensitive at
// the database level, preventing duplicate categories like "Food" and "food".
// =================================================================================
package io.pm.finlight

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.Index
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

@Serializable
@Entity(
    tableName = "categories",
    // --- UPDATED: Ensure the unique index on 'name' is case-insensitive ---
    indices = [Index(value = ["name"], unique = true, name = "index_categories_name_nocase")],
)
data class Category(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    // --- UPDATED: Added COLLATE NOCASE to the column definition for robustness ---
    @ColumnInfo(name = "name", collate = ColumnInfo.NOCASE)
    val name: String,
    // A key to identify the Material Icon for the category
    @ColumnInfo(name = "iconKey")
    val iconKey: String = "category", // Default icon
    // A key to identify the icon's background color
    @ColumnInfo(name = "colorKey")
    val colorKey: String = "gray" // Default color
)-e 


================== FILE: ./app/src/main/java/ReminderManager.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ReminderManager.kt
// REASON: Added the cancelMonthlySummary function to allow disabling of the
// monthly report worker, completing the scheduling lifecycle.
// REASON: FEATURE - Added `scheduleRecurringTransactionWorker` to schedule the new
// worker to run daily. This is the core scheduling component for the automated
// recurring transactions feature.
// =================================================================================
package io.pm.finlight

import android.content.Context
import android.util.Log
import androidx.work.*
import java.util.Calendar
import java.util.concurrent.TimeUnit

object ReminderManager {
    private const val DAILY_EXPENSE_REPORT_WORK_TAG = "daily_expense_report_work"
    private const val WEEKLY_SUMMARY_WORK_TAG = "weekly_summary_work"
    private const val MONTHLY_SUMMARY_WORK_TAG = "monthly_summary_work"
    private const val RECURRING_TRANSACTION_WORK_TAG = "recurring_transaction_work" // --- NEW

    // --- NEW: Function to schedule the recurring transaction worker ---
    fun scheduleRecurringTransactionWorker(context: Context) {
        val now = Calendar.getInstance()
        val nextRun = Calendar.getInstance().apply {
            // Schedule to run early in the morning, e.g., 2 AM
            add(Calendar.DAY_OF_YEAR, 1)
            set(Calendar.HOUR_OF_DAY, 2)
            set(Calendar.MINUTE, 0)
            set(Calendar.SECOND, 0)
        }

        val initialDelay = nextRun.timeInMillis - now.timeInMillis

        val recurringRequest = OneTimeWorkRequestBuilder<RecurringTransactionWorker>()
            .setInitialDelay(initialDelay, TimeUnit.MILLISECONDS)
            .build()

        WorkManager.getInstance(context).enqueueUniqueWork(
            RECURRING_TRANSACTION_WORK_TAG,
            ExistingWorkPolicy.REPLACE,
            recurringRequest
        )
        Log.d("ReminderManager", "Recurring transaction worker scheduled for ${nextRun.time}")
    }


    fun scheduleDailyReport(context: Context) {
        val prefs = context.getSharedPreferences("finance_app_settings", Context.MODE_PRIVATE)
        val hour = prefs.getInt("daily_report_hour", 9)
        val minute = prefs.getInt("daily_report_minute", 0)

        val now = Calendar.getInstance()
        val nextRun = Calendar.getInstance().apply {
            set(Calendar.HOUR_OF_DAY, hour)
            set(Calendar.MINUTE, minute)
            set(Calendar.SECOND, 0)
        }

        if (nextRun.before(now)) {
            nextRun.add(Calendar.DAY_OF_YEAR, 1)
        }

        val initialDelay = nextRun.timeInMillis - now.timeInMillis
        val dailyReportRequest = OneTimeWorkRequestBuilder<DailyReportWorker>()
            .setInitialDelay(initialDelay, TimeUnit.MILLISECONDS)
            .build()

        WorkManager.getInstance(context).enqueueUniqueWork(
            DAILY_EXPENSE_REPORT_WORK_TAG,
            ExistingWorkPolicy.REPLACE,
            dailyReportRequest,
        )
        Log.d("ReminderManager", "Daily report scheduled for ${nextRun.time}")
    }

    fun cancelDailyReport(context: Context) {
        WorkManager.getInstance(context).cancelUniqueWork(DAILY_EXPENSE_REPORT_WORK_TAG)
    }

    fun scheduleWeeklySummary(context: Context) {
        val prefs = context.getSharedPreferences("finance_app_settings", Context.MODE_PRIVATE)
        val dayOfWeek = prefs.getInt("weekly_report_day", Calendar.MONDAY)
        val hour = prefs.getInt("weekly_report_hour", 9)
        val minute = prefs.getInt("weekly_report_minute", 0)

        val now = Calendar.getInstance()
        val nextRun = Calendar.getInstance().apply {
            set(Calendar.DAY_OF_WEEK, dayOfWeek)
            set(Calendar.HOUR_OF_DAY, hour)
            set(Calendar.MINUTE, minute)
            set(Calendar.SECOND, 0)
        }

        if (nextRun.before(now)) {
            nextRun.add(Calendar.WEEK_OF_YEAR, 1)
        }

        val initialDelay = nextRun.timeInMillis - now.timeInMillis
        val weeklyReportRequest = OneTimeWorkRequestBuilder<WeeklySummaryWorker>()
            .setInitialDelay(initialDelay, TimeUnit.MILLISECONDS)
            .build()

        WorkManager.getInstance(context).enqueueUniqueWork(
            WEEKLY_SUMMARY_WORK_TAG,
            ExistingWorkPolicy.REPLACE,
            weeklyReportRequest,
        )
        Log.d("ReminderManager", "Weekly summary scheduled for ${nextRun.time}")
    }


    fun cancelWeeklySummary(context: Context) {
        WorkManager.getInstance(context).cancelUniqueWork(WEEKLY_SUMMARY_WORK_TAG)
    }

    fun scheduleMonthlySummary(context: Context) {
        val prefs = context.getSharedPreferences("finance_app_settings", Context.MODE_PRIVATE)
        val dayOfMonth = prefs.getInt("monthly_report_day", 1)
        val hour = prefs.getInt("monthly_report_hour", 9)
        val minute = prefs.getInt("monthly_report_minute", 0)

        val now = Calendar.getInstance()
        val nextRun = Calendar.getInstance().apply {
            set(Calendar.DAY_OF_MONTH, dayOfMonth)
            set(Calendar.HOUR_OF_DAY, hour)
            set(Calendar.MINUTE, minute)
            set(Calendar.SECOND, 0)
        }

        if (nextRun.before(now)) {
            nextRun.add(Calendar.MONTH, 1)
        }

        val initialDelay = nextRun.timeInMillis - now.timeInMillis
        val monthlyReportRequest = OneTimeWorkRequestBuilder<MonthlySummaryWorker>()
            .setInitialDelay(initialDelay, TimeUnit.MILLISECONDS)
            .build()

        WorkManager.getInstance(context).enqueueUniqueWork(
            MONTHLY_SUMMARY_WORK_TAG,
            ExistingWorkPolicy.REPLACE,
            monthlyReportRequest,
        )
        Log.d("ReminderManager", "Monthly summary scheduled for ${nextRun.time}")
    }

    // --- NEW: Function to cancel the monthly summary worker ---
    fun cancelMonthlySummary(context: Context) {
        WorkManager.getInstance(context).cancelUniqueWork(MONTHLY_SUMMARY_WORK_TAG)
    }
}-e 


================== FILE: ./app/src/main/java/Tag.kt ==================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.Index
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

/**
 * Represents a user-defined Tag (e.g., "Work Trip", "Vacation 2025", "Tax-Deductible").
 * Tags provide a flexible way to organize transactions outside of the rigid category system.
 */
@Serializable
@Entity(
    tableName = "tags",
    indices = [Index(value = ["name"], unique = true)]
)
data class Tag(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val name: String
)-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/LinkRecurringTransactionScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/LinkRecurringTransactionScreen.kt
// REASON: BUG FIX - The navigation logic has been corrected to definitively fix
// the back stack issue. Instead of calling popBackStack() separately, the code
// now uses the popUpTo builder within the navigate call. This atomically
// navigates to the detail screen while simultaneously removing the linking
// screen from the back stack, ensuring a correct and intuitive back navigation
// experience for the user.
// =================================================================================
package io.pm.finlight.ui.screens

import android.app.Application
import android.app.NotificationManager
import android.content.Context
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.google.gson.Gson
import io.pm.finlight.LinkTransactionViewModel
import io.pm.finlight.LinkTransactionViewModelFactory
import io.pm.finlight.PotentialTransaction
import io.pm.finlight.Transaction
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight
import java.net.URLDecoder
import java.text.NumberFormat
import java.text.SimpleDateFormat
import java.util.*

// Helper function to determine if a color is 'dark' based on luminance.
private fun Color.isDark() = (red * 0.299 + green * 0.587 + blue * 0.114) < 0.5

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun LinkRecurringTransactionScreen(
    navController: NavController,
    potentialTransactionJson: String
) {
    val potentialTxn = remember(potentialTransactionJson) {
        Gson().fromJson(URLDecoder.decode(potentialTransactionJson, "UTF-8"), PotentialTransaction::class.java)
    }

    val application = LocalContext.current.applicationContext as Application
    val factory = LinkTransactionViewModelFactory(application, potentialTxn)
    val viewModel: LinkTransactionViewModel = viewModel(factory = factory)

    val candidates by viewModel.linkableTransactions.collectAsState()
    var showConfirmationDialog by remember { mutableStateOf<Transaction?>(null) }
    val context = LocalContext.current

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Confirm Recurring Payment") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back")
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent)
            )
        },
        containerColor = Color.Transparent
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                DuePaymentDetailsCard(viewModel.potentialTransaction)
            }

            item {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    OutlinedButton(
                        onClick = {
                            viewModel.remindTomorrow {
                                val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                                notificationManager.cancel(potentialTxn.sourceSmsId.toInt())
                            }
                            navController.popBackStack()
                        },
                        modifier = Modifier.weight(1f)
                    ) {
                        Text("Remind Tomorrow")
                    }
                    Button(
                        onClick = { navController.navigate("recurring_transactions") },
                        modifier = Modifier.weight(1f)
                    ) {
                        Text("Manage Rules")
                    }
                }
            }

            item {
                Text(
                    "Or, link to a recent transaction:",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }

            if (candidates.isEmpty()) {
                item {
                    GlassPanel {
                        Box(
                            modifier = Modifier.fillMaxWidth().padding(32.dp),
                            contentAlignment = Alignment.Center
                        ) {
                            Text(
                                "No recent matching transactions found.",
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                    }
                }
            } else {
                items(candidates, key = { it.id }) { transaction ->
                    LinkCandidateItem(
                        transaction = transaction,
                        onClick = { showConfirmationDialog = transaction }
                    )
                }
            }
        }
    }

    showConfirmationDialog?.let { transactionToLink ->
        val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
        val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

        AlertDialog(
            onDismissRequest = { showConfirmationDialog = null },
            title = { Text("Confirm Link") },
            text = { Text("Link this payment to the transaction for '${transactionToLink.description}'?") },
            confirmButton = {
                Button(onClick = {
                    showConfirmationDialog = null
                    viewModel.linkTransaction(transactionToLink.id) {
                        val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                        notificationManager.cancel(potentialTxn.sourceSmsId.toInt())
                        // --- FIX: Use popUpTo for a more robust navigation ---
                        navController.navigate("transaction_detail/${transactionToLink.id}") {
                            // Pop the linking screen off the back stack
                            popUpTo("link_recurring_transaction/{potentialTransactionJson}") {
                                inclusive = true
                            }
                        }
                    }
                }) {
                    Text("Confirm")
                }
            },
            dismissButton = {
                TextButton(onClick = { showConfirmationDialog = null }) {
                    Text("Cancel")
                }
            },
            containerColor = popupContainerColor
        )
    }
}

@Composable
private fun DuePaymentDetailsCard(pt: PotentialTransaction) {
    val currencyFormat = remember { NumberFormat.getCurrencyInstance(Locale("en", "IN")) }
    val amountColor = if (pt.transactionType == "expense") {
        MaterialTheme.colorScheme.error
    } else {
        MaterialTheme.colorScheme.primary
    }

    GlassPanel(modifier = Modifier.fillMaxWidth()) {
        Column(
            modifier = Modifier.padding(horizontal = 24.dp, vertical = 16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Text(
                "Payment Due Today",
                style = MaterialTheme.typography.titleLarge,
                color = MaterialTheme.colorScheme.onSurface
            )
            HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    pt.merchantName ?: "Unknown",
                    style = MaterialTheme.typography.bodyLarge,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onSurface
                )
                Text(
                    currencyFormat.format(pt.amount),
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold,
                    color = amountColor
                )
            }
        }
    }
}

@Composable
private fun LinkCandidateItem(transaction: Transaction, onClick: () -> Unit) {
    val dateFormatter = remember { SimpleDateFormat("dd MMM, HH:mm", Locale.getDefault()) }
    val currencyFormat = remember { NumberFormat.getCurrencyInstance(Locale("en", "IN")) }

    GlassPanel(modifier = Modifier.fillMaxWidth().clickable(onClick = onClick)) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    transaction.description,
                    style = MaterialTheme.typography.bodyLarge,
                    fontWeight = FontWeight.SemiBold,
                    color = MaterialTheme.colorScheme.onSurface
                )
                Text(
                    dateFormatter.format(Date(transaction.date)),
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            Text(
                currencyFormat.format(transaction.amount),
                style = MaterialTheme.typography.bodyLarge,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.onSurface
            )
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/TagManagementScreen.kt ==================
// =================================================================================
// FILE: app/src/main/java/io/pm/finlight/ui/screens/TagManagementScreen.kt
// REASON: MAJOR REFACTOR - The screen has been completely redesigned to align
// with the "Project Aurora" vision. All standard components (TextFields,
// Buttons, ListItems, Dialogs) have been replaced with GlassPanel-based
// layouts and styled to ensure a cohesive, modern, and high-contrast user
// experience for managing tags.
// BUG FIX - The AlertDialogs now correctly derive their background color from
// the app's MaterialTheme, ensuring they match the selected theme (e.g.,
// Aurora) instead of defaulting to the system's light/dark mode.
// =================================================================================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import io.pm.finlight.Tag
import io.pm.finlight.TagViewModel
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight

// Helper function to determine if a color is 'dark' based on luminance.
private fun Color.isDark() = (red * 0.299 + green * 0.587 + blue * 0.114) < 0.5

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun TagManagementScreen(viewModel: TagViewModel = viewModel()) {
    val tags by viewModel.allTags.collectAsState()
    var showEditDialog by remember { mutableStateOf(false) }
    var showDeleteDialog by remember { mutableStateOf(false) }
    var selectedTag by remember { mutableStateOf<Tag?>(null) }
    val snackbarHostState = remember { SnackbarHostState() }

    LaunchedEffect(key1 = viewModel.uiEvent) {
        viewModel.uiEvent.collect { message ->
            snackbarHostState.showSnackbar(message)
        }
    }

    Scaffold(
        snackbarHost = { SnackbarHost(snackbarHostState) },
        containerColor = Color.Transparent
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            AddTagInput(onAddTag = viewModel::addTag)

            if (tags.isEmpty()) {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        "No tags created yet. Add one above!",
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            } else {
                LazyColumn(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                    items(tags, key = { it.id }) { tag ->
                        GlassPanel {
                            ListItem(
                                headlineContent = { Text(tag.name, color = MaterialTheme.colorScheme.onSurface) },
                                trailingContent = {
                                    Row {
                                        IconButton(onClick = {
                                            selectedTag = tag
                                            showEditDialog = true
                                        }) {
                                            Icon(
                                                Icons.Default.Edit,
                                                contentDescription = "Edit Tag",
                                                tint = MaterialTheme.colorScheme.onSurfaceVariant
                                            )
                                        }
                                        IconButton(onClick = {
                                            selectedTag = tag
                                            showDeleteDialog = true
                                        }) {
                                            Icon(
                                                Icons.Default.Delete,
                                                contentDescription = "Delete Tag",
                                                tint = MaterialTheme.colorScheme.error
                                            )
                                        }
                                    }
                                },
                                colors = ListItemDefaults.colors(containerColor = Color.Transparent)
                            )
                        }
                    }
                }
            }
        }
    }

    if (showEditDialog && selectedTag != null) {
        EditTagDialog(
            tag = selectedTag!!,
            onDismiss = { showEditDialog = false },
            onConfirm = { updatedTag ->
                viewModel.updateTag(updatedTag)
                showEditDialog = false
            }
        )
    }

    if (showDeleteDialog && selectedTag != null) {
        DeleteTagDialog(
            tag = selectedTag!!,
            onDismiss = { showDeleteDialog = false },
            onConfirm = {
                viewModel.deleteTag(it)
                showDeleteDialog = false
            }
        )
    }
}

@Composable
private fun AddTagInput(onAddTag: (String) -> Unit) {
    var newTagName by remember { mutableStateOf("") }
    GlassPanel {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp, vertical = 8.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            OutlinedTextField(
                value = newTagName,
                onValueChange = { newTagName = it },
                label = { Text("New Tag Name") },
                modifier = Modifier.weight(1f),
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = MaterialTheme.colorScheme.primary,
                    unfocusedBorderColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f),
                    focusedLabelColor = MaterialTheme.colorScheme.primary,
                    unfocusedLabelColor = MaterialTheme.colorScheme.onSurfaceVariant,
                    cursorColor = MaterialTheme.colorScheme.primary,
                    focusedTextColor = MaterialTheme.colorScheme.onSurface,
                    unfocusedTextColor = MaterialTheme.colorScheme.onSurface,
                    focusedContainerColor = Color.Transparent,
                    unfocusedContainerColor = Color.Transparent,
                )
            )
            Button(
                onClick = {
                    onAddTag(newTagName)
                    newTagName = ""
                },
                enabled = newTagName.isNotBlank()
            ) {
                Icon(Icons.Default.Add, contentDescription = "Add Tag")
            }
        }
    }
}

@Composable
private fun EditTagDialog(
    tag: Tag,
    onDismiss: () -> Unit,
    onConfirm: (Tag) -> Unit
) {
    var tagName by remember(tag) { mutableStateOf(tag.name) }
    val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
    val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Edit Tag") },
        text = {
            OutlinedTextField(
                value = tagName,
                onValueChange = { tagName = it },
                label = { Text("Tag Name") },
                modifier = Modifier.fillMaxWidth()
            )
        },
        confirmButton = {
            Button(
                onClick = { onConfirm(tag.copy(name = tagName)) },
                enabled = tagName.isNotBlank()
            ) {
                Text("Save")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) { Text("Cancel") }
        },
        containerColor = popupContainerColor
    )
}

@Composable
private fun DeleteTagDialog(
    tag: Tag,
    onDismiss: () -> Unit,
    onConfirm: (Tag) -> Unit
) {
    val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
    val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Delete Tag?") },
        text = { Text("Are you sure you want to delete the tag '${tag.name}'?") },
        confirmButton = {
            Button(
                onClick = { onConfirm(tag) },
                colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
            ) {
                Text("Delete")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) { Text("Cancel") }
        },
        containerColor = popupContainerColor
    )
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/AddRecurringTransactionScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/AddRecurringTransactionScreen.kt
// REASON: FEATURE - The screen now supports both "add" and "edit" modes. It
// accepts an optional ruleId, loads the existing rule's data if provided,
// and calls the appropriate ViewModel function (insert or update) upon saving.
// =================================================================================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import io.pm.finlight.Account
import io.pm.finlight.Category
import io.pm.finlight.RecurringTransactionViewModel
import io.pm.finlight.TransactionViewModel
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.theme.GlassPanelBorder
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddRecurringTransactionScreen(
    navController: NavController,
    ruleId: Int?
) {
    val recurringViewModel: RecurringTransactionViewModel = viewModel()
    val transactionViewModel: TransactionViewModel = viewModel()

    val isEditMode = ruleId != null
    val titleText = if (isEditMode) "Edit Recurring Rule" else "Add Recurring Rule"

    var description by remember { mutableStateOf("") }
    var amount by remember { mutableStateOf("") }
    var transactionType by remember { mutableStateOf("expense") }

    val recurrenceIntervals = listOf("Daily", "Weekly", "Monthly", "Yearly")
    var selectedInterval by remember { mutableStateOf(recurrenceIntervals[2]) }
    var intervalExpanded by remember { mutableStateOf(false) }

    val accounts by transactionViewModel.allAccounts.collectAsState(initial = emptyList())
    var selectedAccount by remember { mutableStateOf<Account?>(null) }
    var accountExpanded by remember { mutableStateOf(false) }

    val categories by transactionViewModel.allCategories.collectAsState(initial = emptyList())
    var selectedCategory by remember { mutableStateOf<Category?>(null) }
    var categoryExpanded by remember { mutableStateOf(false) }

    val ruleToEdit by if (isEditMode) {
        recurringViewModel.getRuleById(ruleId!!).collectAsState(initial = null)
    } else {
        remember { mutableStateOf(null) }
    }

    LaunchedEffect(ruleToEdit, accounts, categories) {
        if (isEditMode) {
            ruleToEdit?.let { rule ->
                description = rule.description
                amount = rule.amount.toString()
                transactionType = rule.transactionType
                selectedInterval = rule.recurrenceInterval
                selectedAccount = accounts.find { it.id == rule.accountId }
                selectedCategory = categories.find { it.id == rule.categoryId }
            }
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(titleText) },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back")
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent)
            )
        },
        containerColor = Color.Transparent
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp),
        ) {
            item {
                TransactionTypeToggle(
                    selectedType = transactionType,
                    onTypeSelected = { transactionType = it }
                )
            }

            item {
                GlassPanel {
                    Column(Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        OutlinedTextField(
                            value = description,
                            onValueChange = { description = it },
                            label = { Text("Description") },
                            modifier = Modifier.fillMaxWidth(),
                            colors = auroraTextFieldColors()
                        )
                        OutlinedTextField(
                            value = amount,
                            onValueChange = { amount = it },
                            label = { Text("Amount") },
                            modifier = Modifier.fillMaxWidth(),
                            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                            leadingIcon = { Text("") },
                            colors = auroraTextFieldColors()
                        )
                    }
                }
            }

            item {
                GlassPanel {
                    Column(Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        ExposedDropdownMenuBox(expanded = intervalExpanded, onExpandedChange = { intervalExpanded = !intervalExpanded }) {
                            OutlinedTextField(
                                value = selectedInterval,
                                onValueChange = {},
                                readOnly = true,
                                label = { Text("Repeats") },
                                trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = intervalExpanded) },
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .menuAnchor(),
                                colors = auroraTextFieldColors()
                            )
                            ExposedDropdownMenu(
                                expanded = intervalExpanded,
                                onDismissRequest = { intervalExpanded = false },
                                modifier = Modifier.background(if (isSystemInDarkTheme()) PopupSurfaceDark else PopupSurfaceLight)
                            ) {
                                recurrenceIntervals.forEach { interval ->
                                    DropdownMenuItem(text = { Text(interval) }, onClick = {
                                        selectedInterval = interval
                                        intervalExpanded = false
                                    })
                                }
                            }
                        }

                        ExposedDropdownMenuBox(expanded = accountExpanded, onExpandedChange = { accountExpanded = !accountExpanded }) {
                            OutlinedTextField(
                                value = selectedAccount?.name ?: "Select Account",
                                onValueChange = {},
                                readOnly = true,
                                label = { Text("Account") },
                                trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = accountExpanded) },
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .menuAnchor(),
                                colors = auroraTextFieldColors()
                            )
                            ExposedDropdownMenu(
                                expanded = accountExpanded,
                                onDismissRequest = { accountExpanded = false },
                                modifier = Modifier.background(if (isSystemInDarkTheme()) PopupSurfaceDark else PopupSurfaceLight)
                            ) {
                                accounts.forEach { account ->
                                    DropdownMenuItem(text = { Text(account.name) }, onClick = {
                                        selectedAccount = account
                                        accountExpanded = false
                                    })
                                }
                            }
                        }

                        ExposedDropdownMenuBox(expanded = categoryExpanded, onExpandedChange = { categoryExpanded = !categoryExpanded }) {
                            OutlinedTextField(
                                value = selectedCategory?.name ?: "Select Category",
                                onValueChange = {},
                                readOnly = true,
                                label = { Text("Category") },
                                trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = categoryExpanded) },
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .menuAnchor(),
                                colors = auroraTextFieldColors()
                            )
                            ExposedDropdownMenu(
                                expanded = categoryExpanded,
                                onDismissRequest = { categoryExpanded = false },
                                modifier = Modifier.background(if (isSystemInDarkTheme()) PopupSurfaceDark else PopupSurfaceLight)
                            ) {
                                categories.forEach { category ->
                                    DropdownMenuItem(text = { Text(category.name) }, onClick = {
                                        selectedCategory = category
                                        categoryExpanded = false
                                    })
                                }
                            }
                        }
                    }
                }
            }

            item {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(top = 8.dp),
                    horizontalArrangement = Arrangement.spacedBy(16.dp),
                ) {
                    OutlinedButton(onClick = { navController.popBackStack() }, modifier = Modifier.weight(1f)) {
                        Text("Cancel")
                    }
                    Button(
                        onClick = {
                            val amountDouble = amount.toDoubleOrNull()
                            if (amountDouble != null && selectedAccount != null) {
                                recurringViewModel.saveRule(
                                    ruleId = ruleId,
                                    description = description,
                                    amount = amountDouble,
                                    transactionType = transactionType,
                                    recurrenceInterval = selectedInterval,
                                    startDate = ruleToEdit?.startDate ?: System.currentTimeMillis(),
                                    accountId = selectedAccount!!.id,
                                    categoryId = selectedCategory?.id,
                                    lastRunDate = ruleToEdit?.lastRunDate
                                )
                                navController.popBackStack()
                            }
                        },
                        modifier = Modifier.weight(1f),
                        enabled = description.isNotBlank() && amount.isNotBlank() && selectedAccount != null && selectedCategory != null,
                    ) {
                        Text(if (isEditMode) "Update Rule" else "Save Rule")
                    }
                }
            }
        }
    }
}

@Composable
private fun TransactionTypeToggle(
    selectedType: String,
    onTypeSelected: (String) -> Unit
) {
    val glassFillColor = if (isSystemInDarkTheme()) {
        Color.White.copy(alpha = 0.08f)
    } else {
        Color.Black.copy(alpha = 0.04f)
    }

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clip(CircleShape)
            .background(glassFillColor)
            .border(1.dp, GlassPanelBorder, CircleShape)
            .padding(4.dp),
        horizontalArrangement = Arrangement.Center,
        verticalAlignment = Alignment.CenterVertically
    ) {
        val expenseSelected = selectedType == "expense"
        val incomeSelected = selectedType == "income"

        Button(
            onClick = { onTypeSelected("expense") },
            modifier = Modifier
                .weight(1f)
                .height(48.dp),
            shape = CircleShape,
            colors = ButtonDefaults.buttonColors(
                containerColor = if (expenseSelected) MaterialTheme.colorScheme.primary else Color.Transparent,
                contentColor = if (expenseSelected) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurface
            ),
            elevation = null
        ) {
            Text("Expense", fontWeight = FontWeight.Bold)
        }

        Button(
            onClick = { onTypeSelected("income") },
            modifier = Modifier
                .weight(1f)
                .height(48.dp),
            shape = CircleShape,
            colors = ButtonDefaults.buttonColors(
                containerColor = if (incomeSelected) MaterialTheme.colorScheme.primary else Color.Transparent,
                contentColor = if (incomeSelected) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurface
            ),
            elevation = null
        ) {
            Text("Income", fontWeight = FontWeight.Bold)
        }
    }
}

@Composable
private fun auroraTextFieldColors() = OutlinedTextFieldDefaults.colors(
    focusedBorderColor = MaterialTheme.colorScheme.primary,
    unfocusedBorderColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f),
    focusedLabelColor = MaterialTheme.colorScheme.primary,
    unfocusedLabelColor = MaterialTheme.colorScheme.onSurfaceVariant,
    cursorColor = MaterialTheme.colorScheme.primary,
    focusedTextColor = MaterialTheme.colorScheme.onSurface,
    unfocusedTextColor = MaterialTheme.colorScheme.onSurface,
    focusedContainerColor = Color.Transparent,
    unfocusedContainerColor = Color.Transparent,
    focusedLeadingIconColor = MaterialTheme.colorScheme.primary,
    unfocusedLeadingIconColor = MaterialTheme.colorScheme.onSurfaceVariant,
    focusedTrailingIconColor = MaterialTheme.colorScheme.primary,
    unfocusedTrailingIconColor = MaterialTheme.colorScheme.onSurfaceVariant
)
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/OnboardingPages.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/OnboardingPages.kt
// REASON: MAJOR REFACTOR - The entire onboarding flow has been redesigned to
// align with the "Project Aurora" vision. All form elements and action buttons
// are now contained within `GlassPanel` components, and all text colors are
// theme-aware, ensuring a cohesive, high-contrast, and modern user experience
// from the moment the app is first launched.
// =================================================================================
package io.pm.finlight.ui.screens

import android.Manifest
import android.os.Build
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.pager.PagerState
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.Message
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardCapitalization
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.unit.dp
import io.pm.finlight.OnboardingViewModel
import io.pm.finlight.ui.components.GlassPanel

@Composable
fun WelcomePage() {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center,
        modifier = Modifier
            .fillMaxSize()
            .padding(32.dp)
    ) {
        Icon(
            imageVector = Icons.Default.PrivacyTip,
            contentDescription = "Privacy Icon",
            modifier = Modifier.size(80.dp),
            tint = MaterialTheme.colorScheme.primary
        )
        Spacer(modifier = Modifier.height(24.dp))
        Text(
            text = "Welcome to Finlight",
            style = MaterialTheme.typography.headlineMedium,
            textAlign = TextAlign.Center,
            color = MaterialTheme.colorScheme.onSurface
        )
        Spacer(modifier = Modifier.height(16.dp))
        Text(
            buildAnnotatedString {
                withStyle(style = SpanStyle(color = MaterialTheme.colorScheme.onSurfaceVariant)) {
                    append("Your ")
                    withStyle(style = SpanStyle(fontWeight = FontWeight.Bold, color = MaterialTheme.colorScheme.primary)) {
                        append("PRIVACY")
                    }
                    append(" is our ")
                    withStyle(style = SpanStyle(fontWeight = FontWeight.Bold, color = MaterialTheme.colorScheme.primary)) {
                        append("PRIORITY")
                    }
                    append(". All your data is ")
                    withStyle(style = SpanStyle(fontWeight = FontWeight.Bold, color = MaterialTheme.colorScheme.onSurface)) {
                        append("STORED SECURELY")
                    }
                    append(" and ")
                    withStyle(style = SpanStyle(fontWeight = FontWeight.Bold, color = MaterialTheme.colorScheme.onSurface)) {
                        append("ONLY ON YOUR DEVICE")
                    }
                    append(". Let's get you set up.")
                }
            },
            style = MaterialTheme.typography.bodyLarge,
            textAlign = TextAlign.Center
        )
    }
}

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun UserNamePage(viewModel: OnboardingViewModel, pagerState: PagerState) {
    val name by viewModel.userName.collectAsState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Icon(
            imageVector = Icons.Default.AccountCircle,
            contentDescription = "User Icon",
            modifier = Modifier.size(80.dp),
            tint = MaterialTheme.colorScheme.primary
        )
        Spacer(Modifier.height(24.dp))
        Text("What should we call you?", style = MaterialTheme.typography.headlineSmall, textAlign = TextAlign.Center, color = MaterialTheme.colorScheme.onSurface)
        Text(
            "This will be used to personalize your experience.",
            style = MaterialTheme.typography.bodyMedium,
            textAlign = TextAlign.Center,
            modifier = Modifier.padding(top = 8.dp),
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        Spacer(Modifier.height(24.dp))
        GlassPanel {
            OutlinedTextField(
                value = name,
                onValueChange = { viewModel.onNameChanged(it) },
                label = { Text("Your Name") },
                keyboardOptions = KeyboardOptions(
                    keyboardType = KeyboardType.Text,
                    capitalization = KeyboardCapitalization.Words
                ),
                singleLine = true,
                modifier = Modifier.fillMaxWidth().padding(16.dp),
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = MaterialTheme.colorScheme.primary,
                    unfocusedBorderColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f),
                    focusedLabelColor = MaterialTheme.colorScheme.primary,
                    unfocusedLabelColor = MaterialTheme.colorScheme.onSurfaceVariant,
                    cursorColor = MaterialTheme.colorScheme.primary,
                    focusedTextColor = MaterialTheme.colorScheme.onSurface,
                    unfocusedTextColor = MaterialTheme.colorScheme.onSurface,
                    focusedContainerColor = Color.Transparent,
                    unfocusedContainerColor = Color.Transparent,
                )
            )
        }
    }
}

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun BudgetSetupPage(viewModel: OnboardingViewModel, pagerState: PagerState) {
    val budget by viewModel.monthlyBudget.collectAsState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Icon(
            imageVector = Icons.Default.Savings,
            contentDescription = "Budget Icon",
            modifier = Modifier.size(80.dp),
            tint = MaterialTheme.colorScheme.primary
        )
        Spacer(Modifier.height(24.dp))
        Text("Set a Monthly Budget", style = MaterialTheme.typography.headlineSmall, textAlign = TextAlign.Center, color = MaterialTheme.colorScheme.onSurface)
        Text(
            "Give yourself a spending target for the month.",
            style = MaterialTheme.typography.bodyMedium,
            textAlign = TextAlign.Center,
            modifier = Modifier.padding(top = 8.dp),
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        Text(
            "This can be changed any time in Settings.",
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        Spacer(Modifier.height(24.dp))
        GlassPanel {
            OutlinedTextField(
                value = budget,
                onValueChange = { viewModel.onBudgetChanged(it) },
                label = { Text("Total Monthly Budget") },
                leadingIcon = { Text("", color = MaterialTheme.colorScheme.onSurfaceVariant) },
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                modifier = Modifier.fillMaxWidth().padding(16.dp),
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = MaterialTheme.colorScheme.primary,
                    unfocusedBorderColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f),
                    focusedLabelColor = MaterialTheme.colorScheme.primary,
                    unfocusedLabelColor = MaterialTheme.colorScheme.onSurfaceVariant,
                    cursorColor = MaterialTheme.colorScheme.primary,
                    focusedTextColor = MaterialTheme.colorScheme.onSurface,
                    unfocusedTextColor = MaterialTheme.colorScheme.onSurface,
                    focusedContainerColor = Color.Transparent,
                    unfocusedContainerColor = Color.Transparent,
                )
            )
        }
    }
}

@Composable
fun SmsPermissionPage(onPermissionResult: () -> Unit) {
    val context = LocalContext.current
    val permissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestMultiplePermissions()
    ) { perms ->
        if (perms.values.any { !it }) {
            Toast.makeText(context, "Permissions denied. You can enable them later in settings.", Toast.LENGTH_LONG).show()
        } else {
            Toast.makeText(context, "SMS Scanning Enabled!", Toast.LENGTH_SHORT).show()
        }
        onPermissionResult()
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Icon(Icons.AutoMirrored.Filled.Message, contentDescription = "SMS Icon", modifier = Modifier.size(80.dp), tint = MaterialTheme.colorScheme.primary)
        Spacer(Modifier.height(24.dp))
        Text("Automate Your Tracking", style = MaterialTheme.typography.headlineMedium, textAlign = TextAlign.Center, color = MaterialTheme.colorScheme.onSurface)
        Spacer(Modifier.height(16.dp))
        Text(
            "Consider allowing Finlight to read your SMS inbox to automatically detect and import new transactions. This is a huge time-saver!",
            style = MaterialTheme.typography.bodyLarge,
            textAlign = TextAlign.Center,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        Spacer(Modifier.height(24.dp))
        Button(onClick = {
            permissionLauncher.launch(arrayOf(Manifest.permission.READ_SMS, Manifest.permission.RECEIVE_SMS))
        }) {
            Text("Enable SMS Scanning")
        }
    }
}

@Composable
fun SmsScanningInfoPage() {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Icon(
            imageVector = Icons.Default.AutoAwesome,
            contentDescription = "Magic Wand Icon",
            modifier = Modifier.size(80.dp),
            tint = MaterialTheme.colorScheme.primary
        )
        Spacer(Modifier.height(24.dp))
        Text("Supercharge Your Setup", style = MaterialTheme.typography.headlineMedium, textAlign = TextAlign.Center, color = MaterialTheme.colorScheme.onSurface)
        Spacer(Modifier.height(16.dp))
        Text(
            buildAnnotatedString {
                withStyle(style = SpanStyle(color = MaterialTheme.colorScheme.onSurfaceVariant)) {
                    append("After setup, you can visit the ")
                    withStyle(style = SpanStyle(fontWeight = FontWeight.Bold, color = MaterialTheme.colorScheme.onSurface)) {
                        append("Settings")
                    }
                    append(" screen at any time to import existing transactions from your SMS inbox.\n\nYou'll have two options:\n\n")
                    withStyle(style = SpanStyle(fontWeight = FontWeight.Bold, color = MaterialTheme.colorScheme.onSurface)) {
                        append(" Quick Scan:")
                    }
                    append(" A fast scan of recent messages. This defaults to the last 30 days, but you can pick any start date you like!\n\n")
                    withStyle(style = SpanStyle(fontWeight = FontWeight.Bold, color = MaterialTheme.colorScheme.onSurface)) {
                        append(" Full Scan:")
                    }
                    append(" A complete scan of your entire inbox.")
                }
            },
            style = MaterialTheme.typography.bodyLarge,
            textAlign = TextAlign.Center
        )
    }
}


@Composable
fun NotificationPermissionPage(onPermissionResult: () -> Unit) {
    val context = LocalContext.current
    val permissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestPermission()
    ) { isGranted ->
        if (isGranted) {
            Toast.makeText(context, "Notifications enabled!", Toast.LENGTH_SHORT).show()
        } else {
            Toast.makeText(context, "You can enable notifications later in settings.", Toast.LENGTH_LONG).show()
        }
        onPermissionResult()
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Icon(Icons.Default.NotificationsActive, contentDescription = "Notification Icon", modifier = Modifier.size(80.dp), tint = MaterialTheme.colorScheme.primary)
        Spacer(Modifier.height(24.dp))
        Text("Stay Updated", style = MaterialTheme.typography.headlineMedium, color = MaterialTheme.colorScheme.onSurface)
        Spacer(Modifier.height(16.dp))
        Text(
            "Get notified about new transactions and receive daily, weekly and monthly summaries by enabling notifications.",
            style = MaterialTheme.typography.bodyLarge,
            textAlign = TextAlign.Center,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        Spacer(Modifier.height(24.dp))

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            Button(onClick = {
                permissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
            }) {
                Text("Enable Notifications")
            }
            Spacer(Modifier.height(16.dp))
        } else {
            LaunchedEffect(Unit) {
                onPermissionResult()
            }
        }
    }
}

@Composable
fun CompletionPage() {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Icon(
            imageVector = Icons.Default.CheckCircle,
            contentDescription = "Success Icon",
            modifier = Modifier.size(100.dp),
            tint = MaterialTheme.colorScheme.primary
        )
        Spacer(modifier = Modifier.height(24.dp))
        Text(
            text = "You're All Set!",
            style = MaterialTheme.typography.headlineMedium,
            textAlign = TextAlign.Center,
            color = MaterialTheme.colorScheme.onSurface
        )
        Spacer(modifier = Modifier.height(16.dp))
        Text(
            text = "Your accounts and preferences have been saved. You can now start tracking your finances.",
            style = MaterialTheme.typography.bodyLarge,
            textAlign = TextAlign.Center,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/CategoryListScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/CategoryListScreen.kt
// REASON: UX REFINEMENT - The screen's layout is now wrapped in a Scaffold that
// includes a SnackbarHost. This allows the screen to display feedback messages
// from the ViewModel, such as "Category already exists," which was previously
// failing silently.
// =================================================================================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import io.pm.finlight.Category
import io.pm.finlight.CategoryIconHelper
import io.pm.finlight.CategoryViewModel
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight

// Helper function to determine if a color is 'dark' based on luminance.
private fun Color.isDark() = (red * 0.299 + green * 0.587 + blue * 0.114) < 0.5

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CategoryListScreen(
    navController: NavController,
    viewModel: CategoryViewModel,
) {
    val categories by viewModel.allCategories.collectAsState(initial = emptyList())
    var showEditDialog by remember { mutableStateOf(false) }
    var showDeleteDialog by remember { mutableStateOf(false) }
    var selectedCategory by remember { mutableStateOf<Category?>(null) }
    val snackbarHostState = remember { SnackbarHostState() }

    LaunchedEffect(key1 = viewModel.uiEvent) {
        viewModel.uiEvent.collect { message ->
            snackbarHostState.showSnackbar(message)
        }
    }

    // --- NEW: Added Scaffold to host the Snackbar ---
    Scaffold(
        snackbarHost = { SnackbarHost(snackbarHostState) },
        containerColor = Color.Transparent
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Button(
                onClick = {
                    selectedCategory = null
                    showEditDialog = true
                },
                modifier = Modifier.fillMaxWidth()
            ) {
                Icon(imageVector = Icons.Default.Add, contentDescription = "Add")
                Spacer(modifier = Modifier.width(8.dp))
                Text("Add New Category")
            }

            LazyColumn(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                items(categories, key = { it.id }) { category ->
                    GlassPanel {
                        Row(
                            modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Box(
                                modifier = Modifier
                                    .size(40.dp)
                                    .clip(CircleShape)
                                    .background(CategoryIconHelper.getIconBackgroundColor(category.colorKey)),
                                contentAlignment = Alignment.Center
                            ) {
                                if (category.iconKey == "letter_default") {
                                    Text(
                                        text = category.name.firstOrNull()?.uppercase() ?: "?",
                                        fontWeight = FontWeight.Bold,
                                        fontSize = 18.sp,
                                        color = Color.Black
                                    )
                                } else {
                                    Icon(
                                        imageVector = CategoryIconHelper.getIcon(category.iconKey),
                                        contentDescription = category.name,
                                        tint = Color.Black,
                                        modifier = Modifier.size(22.dp)
                                    )
                                }
                            }
                            Spacer(Modifier.width(16.dp))
                            Text(
                                text = category.name,
                                modifier = Modifier.weight(1f),
                                color = MaterialTheme.colorScheme.onSurface
                            )
                            Row {
                                IconButton(onClick = {
                                    selectedCategory = category
                                    showEditDialog = true
                                }) {
                                    Icon(
                                        imageVector = Icons.Default.Edit,
                                        contentDescription = "Edit Category",
                                        tint = MaterialTheme.colorScheme.onSurfaceVariant
                                    )
                                }
                                IconButton(onClick = {
                                    selectedCategory = category
                                    showDeleteDialog = true
                                }) {
                                    Icon(
                                        imageVector = Icons.Default.Delete,
                                        contentDescription = "Delete Category",
                                        tint = MaterialTheme.colorScheme.error,
                                    )
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if (showEditDialog) {
        EditCategoryDialog(
            category = selectedCategory,
            onDismiss = { showEditDialog = false },
            onConfirm = { name, iconKey, colorKey ->
                if (selectedCategory == null) {
                    viewModel.addCategory(name, iconKey, colorKey)
                } else {
                    viewModel.updateCategory(selectedCategory!!.copy(name = name, iconKey = iconKey, colorKey = colorKey))
                }
                showEditDialog = false
            },
        )
    }

    if (showDeleteDialog && selectedCategory != null) {
        val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
        val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

        DeleteCategoryDialog(
            category = selectedCategory!!,
            onDismiss = { showDeleteDialog = false },
            onConfirm = {
                viewModel.deleteCategory(selectedCategory!!)
                showDeleteDialog = false
            },
            containerColor = popupContainerColor
        )
    }
}


@Composable
fun EditCategoryDialog(
    category: Category?,
    onDismiss: () -> Unit,
    onConfirm: (String, String, String) -> Unit,
) {
    var name by remember { mutableStateOf(category?.name ?: "") }
    var selectedIconKey by remember { mutableStateOf(category?.iconKey ?: "category") }
    var selectedColorKey by remember { mutableStateOf(category?.colorKey ?: "gray_light") }
    val allIcons = remember { CategoryIconHelper.getAllIcons().entries.toList() }
    val allColors = remember { CategoryIconHelper.getAllIconColors().entries.toList() }

    val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
    val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text(if (category == null) "Add Category" else "Edit Category") },
        text = {
            Column {
                OutlinedTextField(
                    value = name,
                    onValueChange = { name = it },
                    label = { Text("Category Name") },
                    modifier = Modifier.fillMaxWidth()
                )
                Spacer(Modifier.height(16.dp))
                Text("Select Icon", style = MaterialTheme.typography.titleMedium)
                LazyVerticalGrid(
                    columns = GridCells.Adaptive(minSize = 48.dp),
                    modifier = Modifier.heightIn(max = 150.dp)
                ) {
                    items(allIcons) { (key, icon) ->
                        IconButton(
                            onClick = { selectedIconKey = key },
                            modifier = Modifier
                                .padding(4.dp)
                                .border(
                                    width = 1.dp,
                                    color = if (selectedIconKey == key) MaterialTheme.colorScheme.primary else Color.Transparent,
                                    shape = MaterialTheme.shapes.medium
                                )
                        ) {
                            Icon(imageVector = icon, contentDescription = key)
                        }
                    }
                }
                Spacer(Modifier.height(16.dp))
                Text("Select Color", style = MaterialTheme.typography.titleMedium)
                LazyVerticalGrid(
                    columns = GridCells.Adaptive(minSize = 48.dp),
                    modifier = Modifier.heightIn(max = 100.dp)
                ) {
                    items(allColors) { (key, color) ->
                        Box(
                            modifier = Modifier
                                .padding(6.dp)
                                .size(32.dp)
                                .clip(CircleShape)
                                .background(color)
                                .clickable { selectedColorKey = key }
                                .border(
                                    width = 2.dp,
                                    color = if (selectedColorKey == key) MaterialTheme.colorScheme.outline else Color.Transparent,
                                    shape = CircleShape
                                )
                        )
                    }
                }
            }
        },
        confirmButton = {
            Button(
                onClick = {
                    if (name.isNotBlank()) {
                        onConfirm(name, selectedIconKey, selectedColorKey)
                    }
                },
                enabled = name.isNotBlank(),
            ) {
                Text(if (category == null) "Add" else "Update")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        },
        containerColor = popupContainerColor
    )
}

@Composable
fun DeleteCategoryDialog(
    category: Category,
    onDismiss: () -> Unit,
    onConfirm: () -> Unit,
    containerColor: Color
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Delete Category") },
        text = { Text("Are you sure you want to delete the category '${category.name}'? This cannot be undone.") },
        confirmButton = {
            Button(
                onClick = onConfirm,
                colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error),
            ) {
                Text("Delete")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        },
        containerColor = containerColor
    )
}-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/GoalScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/GoalScreen.kt
// REASON: NEW FILE - Implements the UI for the Savings Goals feature. It follows
// the "Project Aurora" design system, using GlassPanel components to display
// each goal with a progress bar and summary details. It includes dialogs for
// adding, editing, and deleting goals.
// FIX: Refactored the dialog management to be sequential. The main screen now
// controls the visibility of the Add/Edit dialog and the Date Picker dialog
// separately to prevent window conflicts, ensuring the Date Picker appears correctly.
// ANIMATION - Added `animateItemPlacement()` to the GoalItem in the LazyColumn.
// This makes the list fluidly animate changes when goals are added or removed.
// ANIMATION - The duration of the `tween` animation for the goal progress bar
// has been reduced from 1000ms to a much snappier 400ms.
// =================================================================================
package io.pm.finlight.ui.screens

import androidx.compose.animation.core.EaseOutCubic
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.tween
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.DateRange
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import io.pm.finlight.*
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight
import java.text.NumberFormat
import java.text.SimpleDateFormat
import java.util.*
import kotlin.math.roundToInt

private fun Color.isDark() = (red * 0.299 + green * 0.587 + blue * 0.114) < 0.5

@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class)
@Composable
fun GoalScreen(
    navController: NavController,
    goalViewModel: GoalViewModel = viewModel(),
    transactionViewModel: TransactionViewModel = viewModel()
) {
    val goals by goalViewModel.allGoals.collectAsState()
    val accounts by transactionViewModel.allAccounts.collectAsState()

    var showAddEditDialog by remember { mutableStateOf(false) }
    var showDeleteDialog by remember { mutableStateOf(false) }
    var showDatePicker by remember { mutableStateOf(false) }

    // --- STATE HOISTING: All state for the dialog is now managed here ---
    var goalToEdit by remember { mutableStateOf<GoalWithAccountName?>(null) }
    var goalName by remember { mutableStateOf("") }
    var targetAmount by remember { mutableStateOf("") }
    var savedAmount by remember { mutableStateOf("") }
    var selectedAccount by remember { mutableStateOf<Account?>(null) }
    var targetDate by remember { mutableStateOf<Long?>(null) }
    // --- END STATE HOISTING ---

    fun openDialogForNew() {
        goalToEdit = null
        goalName = ""
        targetAmount = ""
        savedAmount = ""
        selectedAccount = accounts.firstOrNull()
        targetDate = null
        showAddEditDialog = true
    }

    fun openDialogForEdit(goal: GoalWithAccountName) {
        goalToEdit = goal
        goalName = goal.name
        targetAmount = goal.targetAmount.toString()
        savedAmount = goal.savedAmount.toString()
        selectedAccount = accounts.find { it.id == goal.accountId }
        targetDate = goal.targetDate
        showAddEditDialog = true
    }

    Scaffold(
        floatingActionButton = {
            FloatingActionButton(onClick = { openDialogForNew() }) {
                Icon(Icons.Default.Add, contentDescription = "Add Goal")
            }
        },
        containerColor = Color.Transparent
    ) { innerPadding ->
        if (goals.isEmpty()) {
            Box(
                modifier = Modifier.fillMaxSize().padding(innerPadding),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    "No savings goals yet. Tap '+' to add one!",
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    textAlign = TextAlign.Center
                )
            }
        } else {
            LazyColumn(
                modifier = Modifier.padding(innerPadding),
                contentPadding = PaddingValues(16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                items(goals, key = { it.id }) { goal ->
                    GoalItem(
                        modifier = Modifier.animateItemPlacement(),
                        goal = goal,
                        onEdit = { openDialogForEdit(goal) },
                        onDelete = {
                            goalToEdit = goal
                            showDeleteDialog = true
                        }
                    )
                }
            }
        }
    }

    if (showAddEditDialog) {
        AddEditGoalDialog(
            goalName = goalName,
            onGoalNameChange = { goalName = it },
            targetAmount = targetAmount,
            onTargetAmountChange = { targetAmount = it },
            savedAmount = savedAmount,
            onSavedAmountChange = { savedAmount = it },
            selectedAccount = selectedAccount,
            onAccountSelected = { selectedAccount = it },
            accounts = accounts,
            targetDate = targetDate,
            onDismiss = { showAddEditDialog = false },
            onConfirm = {
                val target = targetAmount.toDoubleOrNull()
                val saved = savedAmount.toDoubleOrNull() ?: 0.0
                if (goalName.isNotBlank() && target != null && selectedAccount != null) {
                    goalViewModel.saveGoal(goalToEdit?.id, goalName, target, saved, targetDate, selectedAccount!!.id)
                    showAddEditDialog = false
                }
            },
            onLaunchDatePicker = {
                showAddEditDialog = false
                showDatePicker = true
            }
        )
    }

    if (showDatePicker) {
        GoalDatePickerDialog(
            initialDate = targetDate,
            onDismiss = {
                showDatePicker = false
                showAddEditDialog = true // Re-show the goal dialog
            },
            onDateSelected = { newDate ->
                targetDate = newDate
                showDatePicker = false
                showAddEditDialog = true // Re-show the goal dialog
            }
        )
    }

    if (showDeleteDialog && goalToEdit != null) {
        DeleteGoalDialog(
            goalName = goalToEdit!!.name,
            onDismiss = { showDeleteDialog = false },
            onConfirm = {
                goalViewModel.deleteGoal(
                    Goal(
                        id = goalToEdit!!.id,
                        name = goalToEdit!!.name,
                        targetAmount = goalToEdit!!.targetAmount,
                        savedAmount = goalToEdit!!.savedAmount,
                        targetDate = goalToEdit!!.targetDate,
                        accountId = goalToEdit!!.accountId
                    )
                )
                showDeleteDialog = false
            }
        )
    }
}

@Composable
private fun GoalItem(
    modifier: Modifier = Modifier,
    goal: GoalWithAccountName,
    onEdit: () -> Unit,
    onDelete: () -> Unit
) {
    val progress = (goal.savedAmount / goal.targetAmount).toFloat().coerceIn(0f, 1f)
    val animatedProgress by animateFloatAsState(
        targetValue = progress,
        animationSpec = tween(durationMillis = 400, easing = EaseOutCubic),
        label = "GoalProgress"
    )
    val currencyFormat = remember { NumberFormat.getCurrencyInstance(Locale("en", "IN")) }
    val dateFormat = remember { SimpleDateFormat("dd MMM, yyyy", Locale.getDefault()) }

    GlassPanel(modifier = modifier) {
        Column(modifier = Modifier.padding(16.dp)) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = goal.name,
                        style = MaterialTheme.typography.titleLarge,
                        color = MaterialTheme.colorScheme.onSurface
                    )
                    Text(
                        text = "Linked to: ${goal.accountName}",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
                IconButton(onClick = onEdit) {
                    Icon(Icons.Default.Edit, contentDescription = "Edit Goal", tint = MaterialTheme.colorScheme.onSurfaceVariant)
                }
                IconButton(onClick = onDelete) {
                    Icon(Icons.Default.Delete, contentDescription = "Delete Goal", tint = MaterialTheme.colorScheme.error)
                }
            }
            Spacer(Modifier.height(16.dp))
            LinearProgressIndicator(
                progress = { animatedProgress },
                modifier = Modifier.fillMaxWidth().height(8.dp).clip(CircleShape),
                color = MaterialTheme.colorScheme.primary,
                trackColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f),
                strokeCap = StrokeCap.Round
            )
            Spacer(Modifier.height(8.dp))
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = "${(progress * 100).roundToInt()}% Complete",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
                Text(
                    text = "${currencyFormat.format(goal.savedAmount)} / ${currencyFormat.format(goal.targetAmount)}",
                    style = MaterialTheme.typography.bodySmall,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onSurface
                )
            }
            goal.targetDate?.let {
                Spacer(Modifier.height(4.dp))
                Text(
                    text = "Target Date: ${dateFormat.format(Date(it))}",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun AddEditGoalDialog(
    goalName: String,
    onGoalNameChange: (String) -> Unit,
    targetAmount: String,
    onTargetAmountChange: (String) -> Unit,
    savedAmount: String,
    onSavedAmountChange: (String) -> Unit,
    selectedAccount: Account?,
    onAccountSelected: (Account) -> Unit,
    accounts: List<Account>,
    targetDate: Long?,
    onDismiss: () -> Unit,
    onConfirm: () -> Unit,
    onLaunchDatePicker: () -> Unit
) {
    var accountExpanded by remember { mutableStateOf(false) }
    val dateFormat = remember { SimpleDateFormat("dd/MM/yyyy", Locale.getDefault()) }
    val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
    val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

    Dialog(onDismissRequest = onDismiss) {
        Surface(
            shape = RoundedCornerShape(28.dp),
            color = popupContainerColor,
            tonalElevation = 6.dp
        ) {
            Column(
                modifier = Modifier.padding(24.dp),
            ) {
                Text(
                    text = if (goalName.isBlank()) "New Savings Goal" else "Edit Savings Goal",
                    style = MaterialTheme.typography.headlineSmall,
                    color = MaterialTheme.colorScheme.onSurface,
                    modifier = Modifier.padding(bottom = 16.dp)
                )

                Box(modifier = Modifier.heightIn(max = 400.dp)) {
                    LazyColumn {
                        item {
                            Column(verticalArrangement = Arrangement.spacedBy(16.dp)) {
                                OutlinedTextField(
                                    value = goalName,
                                    onValueChange = onGoalNameChange,
                                    label = { Text("Goal Name (e.g., New Phone)") },
                                    modifier = Modifier.fillMaxWidth()
                                )
                                OutlinedTextField(
                                    value = targetAmount,
                                    onValueChange = { onTargetAmountChange(it.filter { c -> c.isDigit() || c == '.' }) },
                                    label = { Text("Target Amount") },
                                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                                    leadingIcon = { Text("") },
                                    modifier = Modifier.fillMaxWidth()
                                )
                                OutlinedTextField(
                                    value = savedAmount,
                                    onValueChange = { onSavedAmountChange(it.filter { c -> c.isDigit() || c == '.' }) },
                                    label = { Text("Already Saved (Optional)") },
                                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                                    leadingIcon = { Text("") },
                                    modifier = Modifier.fillMaxWidth()
                                )

                                ExposedDropdownMenuBox(expanded = accountExpanded, onExpandedChange = { accountExpanded = !accountExpanded }) {
                                    OutlinedTextField(
                                        value = selectedAccount?.name ?: "Select Account",
                                        onValueChange = {},
                                        readOnly = true,
                                        label = { Text("Link to Account") },
                                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = accountExpanded) },
                                        modifier = Modifier.fillMaxWidth().menuAnchor()
                                    )
                                    ExposedDropdownMenu(
                                        expanded = accountExpanded,
                                        onDismissRequest = { accountExpanded = false },
                                        modifier = Modifier.background(if (isSystemInDarkTheme()) PopupSurfaceDark else PopupSurfaceLight)
                                    ) {
                                        accounts.forEach { account ->
                                            DropdownMenuItem(
                                                text = { Text(account.name) },
                                                onClick = {
                                                    onAccountSelected(account)
                                                    accountExpanded = false
                                                }
                                            )
                                        }
                                    }
                                }

                                OutlinedTextField(
                                    value = targetDate?.let { dateFormat.format(Date(it)) } ?: "",
                                    onValueChange = {},
                                    readOnly = true,
                                    label = { Text("Target Date (Optional)") },
                                    modifier = Modifier.fillMaxWidth().clickable { onLaunchDatePicker() },
                                    trailingIcon = { Icon(Icons.Default.DateRange, "Select Date") }
                                )
                            }
                        }
                    }
                }

                Spacer(Modifier.height(24.dp))
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    TextButton(onClick = onDismiss) { Text("Cancel") }
                    Spacer(Modifier.width(8.dp))
                    Button(
                        onClick = onConfirm,
                        enabled = goalName.isNotBlank() && targetAmount.isNotBlank() && selectedAccount != null
                    ) { Text(if (goalName.isBlank()) "Create" else "Save") }
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun GoalDatePickerDialog(
    initialDate: Long?,
    onDismiss: () -> Unit,
    onDateSelected: (Long?) -> Unit
) {
    val datePickerState = rememberDatePickerState(initialSelectedDateMillis = initialDate ?: System.currentTimeMillis())
    DatePickerDialog(
        onDismissRequest = onDismiss,
        confirmButton = {
            TextButton(onClick = {
                onDateSelected(datePickerState.selectedDateMillis)
            }) { Text("OK") }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) { Text("Cancel") }
        }
    ) {
        DatePicker(state = datePickerState)
    }
}


@Composable
private fun DeleteGoalDialog(
    goalName: String,
    onDismiss: () -> Unit,
    onConfirm: () -> Unit
) {
    val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
    val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

    AlertDialog(
        onDismissRequest = onDismiss,
        containerColor = popupContainerColor,
        title = { Text("Delete Goal?") },
        text = { Text("Are you sure you want to delete the goal '$goalName'?") },
        confirmButton = {
            Button(
                onClick = onConfirm,
                colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
            ) { Text("Delete") }
        },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } }
    )
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/MerchantSpendingScreen.kt ==================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import io.pm.finlight.MerchantSpendingSummary
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.theme.ExpenseRedDark

@Composable
fun MerchantSpendingScreen(merchantList: List<MerchantSpendingSummary>) {
    if (merchantList.isEmpty()) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Text("No merchant data for this month.")
        }
        return
    }

    LazyColumn(
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        items(merchantList) { merchant ->
            MerchantSpendingCard(merchant = merchant)
        }
    }
}

@Composable
fun MerchantSpendingCard(merchant: MerchantSpendingSummary) {
    GlassPanel(
        modifier = Modifier.fillMaxWidth()
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    merchant.merchantName,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onSurface
                )
                val visitText = if (merchant.transactionCount == 1) "1 visit" else "${merchant.transactionCount} visits"
                Text(
                    visitText,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            Text(
                "${"%,.2f".format(merchant.totalAmount)}",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold,
                color = ExpenseRedDark
            )
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/AddEditBudgetScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/AddEditBudgetScreen.kt
// REASON: REFACTOR - The dialog has been updated to use GlassPanel components
// and align with the Project Aurora aesthetic, ensuring a consistent and modern
// look for adding and editing budgets.
// =================================================================================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.background
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import io.pm.finlight.Budget
import io.pm.finlight.BudgetViewModel
import io.pm.finlight.Category
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddEditBudgetScreen(
    navController: NavController,
    viewModel: BudgetViewModel,
    budgetId: Int?,
) {
    val isEditMode = budgetId != null
    val buttonText = if (isEditMode) "Update Budget" else "Save Budget"
    val titleText = if (isEditMode) "Edit Budget" else "Add Budget"

    var amount by remember { mutableStateOf("") }
    val availableCategories by viewModel.availableCategoriesForNewBudget.collectAsState(initial = emptyList())
    val allCategories by viewModel.allCategories.collectAsState(initial = emptyList())
    var selectedCategory by remember { mutableStateOf<Category?>(null) }
    var isCategoryDropdownExpanded by remember { mutableStateOf(false) }

    val budgetToEdit by if (isEditMode) {
        viewModel.getBudgetById(budgetId!!).collectAsState(initial = null)
    } else {
        remember { mutableStateOf<Budget?>(null) }
    }

    LaunchedEffect(budgetToEdit, allCategories) {
        if (isEditMode) {
            budgetToEdit?.let { budget ->
                amount = "%.0f".format(budget.amount)
                selectedCategory = allCategories.find { it.name == budget.categoryName }
            }
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp),
    ) {
        Text(titleText, style = MaterialTheme.typography.headlineSmall, color = MaterialTheme.colorScheme.onSurface)

        GlassPanel {
            Column(Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                val isDropdownEnabled = !isEditMode && availableCategories.isNotEmpty()

                ExposedDropdownMenuBox(
                    expanded = isCategoryDropdownExpanded && isDropdownEnabled,
                    onExpandedChange = { if (isDropdownEnabled) isCategoryDropdownExpanded = !isCategoryDropdownExpanded },
                ) {
                    OutlinedTextField(
                        value = selectedCategory?.name ?: "Select Category",
                        onValueChange = {},
                        readOnly = true,
                        label = { Text("Category") },
                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = isCategoryDropdownExpanded && isDropdownEnabled) },
                        modifier = Modifier
                            .fillMaxWidth()
                            .menuAnchor(),
                        enabled = isDropdownEnabled,
                    )
                    ExposedDropdownMenu(
                        expanded = isCategoryDropdownExpanded && isDropdownEnabled,
                        onDismissRequest = { isCategoryDropdownExpanded = false },
                        modifier = Modifier.background(if (isSystemInDarkTheme()) PopupSurfaceDark else PopupSurfaceLight)
                    ) {
                        availableCategories.forEach { category ->
                            DropdownMenuItem(
                                text = { Text(category.name) },
                                onClick = {
                                    selectedCategory = category
                                    isCategoryDropdownExpanded = false
                                },
                            )
                        }
                    }
                }

                if (availableCategories.isEmpty() && !isEditMode) {
                    Text(
                        text = "All categories already have a budget for this month. You can edit existing budgets from the previous screen.",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant,
                    )
                }

                OutlinedTextField(
                    value = amount,
                    onValueChange = { amount = it },
                    label = { Text("Budget Amount") },
                    modifier = Modifier.fillMaxWidth(),
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                    leadingIcon = { Text("") },
                )
            }
        }
        Spacer(modifier = Modifier.weight(1f))
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(16.dp),
        ) {
            OutlinedButton(onClick = { navController.popBackStack() }, modifier = Modifier.weight(1f)) {
                Text("Cancel")
            }
            Button(
                onClick = {
                    val amountDouble = amount.toDoubleOrNull()
                    if (selectedCategory != null && amountDouble != null && amountDouble > 0) {
                        if (isEditMode) {
                            budgetToEdit?.let { currentBudget ->
                                viewModel.updateBudget(currentBudget.copy(amount = amountDouble))
                            }
                        } else {
                            viewModel.addCategoryBudget(selectedCategory!!.name, amount)
                        }
                        navController.popBackStack()
                    }
                },
                modifier = Modifier.weight(1f),
                enabled = selectedCategory != null && amount.isNotBlank(),
            ) {
                Text(buttonText)
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/ManageIgnoreRulesScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/ManageIgnoreRulesScreen.kt
// REASON: MAJOR REFACTOR - The screen has been fully redesigned to align with the
// "Project Aurora" vision. All list items and input fields are now housed in
// GlassPanel components.
// BUG FIX: All text and component colors have been explicitly set using
// MaterialTheme.colorScheme to ensure high contrast and legibility in dark
// mode, resolving the visibility issues.
// BUG FIX - The AlertDialog now correctly derives its background color from
// the app's MaterialTheme, ensuring it matches the selected theme (e.g.,
// Aurora) instead of defaulting to the system's light/dark mode.
// ANIMATION - Added `animateItemPlacement()` to the ListItems in the
// LazyColumn. This makes the lists fluidly animate changes when ignore rules
// are added, deleted, or toggled.
// =================================================================================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import io.pm.finlight.IgnoreRule
import io.pm.finlight.ManageIgnoreRulesViewModel
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight

// Helper function to determine if a color is 'dark' based on luminance.
private fun Color.isDark() = (red * 0.299 + green * 0.587 + blue * 0.114) < 0.5

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun ManageIgnoreRulesScreen(
    viewModel: ManageIgnoreRulesViewModel = viewModel()
) {
    val rules by viewModel.allRules.collectAsState()
    var newPhrase by remember { mutableStateOf("") }
    var ruleToDelete by remember { mutableStateOf<IgnoreRule?>(null) }

    val (defaultRules, customRules) = rules.partition { it.isDefault }

    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        item {
            Column {
                Text(
                    "Manage Ignore Phrases",
                    style = MaterialTheme.typography.headlineSmall,
                    color = MaterialTheme.colorScheme.onSurface,
                    fontWeight = FontWeight.Bold
                )
                Spacer(Modifier.height(4.dp))
                Text(
                    "Add phrases to ignore messages from the SMS parser. You can also toggle the app's default rules.",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }

        item {
            GlassPanel {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 16.dp, vertical = 8.dp),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    OutlinedTextField(
                        value = newPhrase,
                        onValueChange = { newPhrase = it },
                        label = { Text("Add custom phrase") },
                        modifier = Modifier.weight(1f),
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedBorderColor = MaterialTheme.colorScheme.primary,
                            unfocusedBorderColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f),
                            focusedLabelColor = MaterialTheme.colorScheme.primary,
                            unfocusedLabelColor = MaterialTheme.colorScheme.onSurfaceVariant,
                            cursorColor = MaterialTheme.colorScheme.primary,
                            focusedTextColor = MaterialTheme.colorScheme.onSurface,
                            unfocusedTextColor = MaterialTheme.colorScheme.onSurface,
                            focusedContainerColor = Color.Transparent,
                            unfocusedContainerColor = Color.Transparent,
                        )
                    )
                    Button(
                        onClick = {
                            viewModel.addIgnoreRule(newPhrase)
                            newPhrase = "" // Clear input
                        },
                        enabled = newPhrase.isNotBlank()
                    ) {
                        Icon(Icons.Default.Add, contentDescription = "Add Phrase")
                    }
                }
            }
        }

        if (customRules.isNotEmpty()) {
            item {
                Text(
                    "Your Custom Rules",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.padding(top = 8.dp)
                )
            }
            items(customRules, key = { "custom-${it.id}" }) { rule ->
                GlassPanel(modifier = Modifier.animateItemPlacement()) {
                    ListItem(
                        headlineContent = { Text(rule.phrase, color = MaterialTheme.colorScheme.onSurface) },
                        trailingContent = {
                            IconButton(onClick = { ruleToDelete = rule }) {
                                Icon(
                                    Icons.Default.Delete,
                                    contentDescription = "Delete rule",
                                    tint = MaterialTheme.colorScheme.error
                                )
                            }
                        },
                        colors = ListItemDefaults.colors(containerColor = Color.Transparent)
                    )
                }
            }
        }

        if (defaultRules.isNotEmpty()) {
            item {
                Text(
                    "Default App Rules",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.padding(top = 8.dp)
                )
            }
            items(defaultRules, key = { "default-${it.id}" }) { rule ->
                GlassPanel(modifier = Modifier.animateItemPlacement()) {
                    ListItem(
                        headlineContent = { Text(rule.phrase, color = MaterialTheme.colorScheme.onSurface) },
                        trailingContent = {
                            Switch(
                                checked = rule.isEnabled,
                                onCheckedChange = { isEnabled ->
                                    viewModel.updateIgnoreRule(rule.copy(isEnabled = isEnabled))
                                }
                            )
                        },
                        colors = ListItemDefaults.colors(containerColor = Color.Transparent)
                    )
                }
            }
        }
    }

    if (ruleToDelete != null) {
        val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
        val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

        AlertDialog(
            onDismissRequest = { ruleToDelete = null },
            title = { Text("Delete Ignore Phrase?") },
            text = { Text("Are you sure you want to delete the phrase \"${ruleToDelete!!.phrase}\"?") },
            confirmButton = {
                Button(
                    onClick = {
                        viewModel.deleteIgnoreRule(ruleToDelete!!)
                        ruleToDelete = null
                    },
                    colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
                ) { Text("Delete") }
            },
            dismissButton = {
                TextButton(onClick = { ruleToDelete = null }) { Text("Cancel") }
            },
            containerColor = popupContainerColor
        )
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/SmsWorkflowScreens.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/SmsWorkflowScreens.kt
// REASON: BUG FIX - Corrected the navigation call for the `onCreateRule` action.
// The route is now constructed with a proper query parameter
// (`?potentialTransactionJson=...`) to match the NavHost definition, resolving
// the `IllegalArgumentException` crash.
// =================================================================================
package io.pm.finlight.ui.screens

import android.Manifest
import android.content.pm.PackageManager
import android.util.Log
import android.widget.Toast
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.Notes
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.livedata.observeAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.core.app.NotificationManagerCompat
import androidx.core.content.ContextCompat
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.google.gson.Gson
import io.pm.finlight.*
import kotlinx.coroutines.launch
import java.net.URLEncoder

private sealed class ApproveSheetContent {
    object Category : ApproveSheetContent()
    object Tags : ApproveSheetContent()
}


@Composable
fun ReviewSmsScreen(
    navController: NavController,
    viewModel: SettingsViewModel,
) {
    val potentialTransactions by viewModel.potentialTransactions.collectAsState()
    val isScanning by viewModel.isScanning.collectAsState()

    var hasLoadedOnce by remember { mutableStateOf(false) }

    val linkedSmsIdState = navController.currentBackStackEntry
        ?.savedStateHandle
        ?.getLiveData<Long>("linked_sms_id")
        ?.observeAsState()
    val linkedSmsId = linkedSmsIdState?.value

    LaunchedEffect(linkedSmsId) {
        linkedSmsId?.let {
            viewModel.onTransactionLinked(it)
            navController.currentBackStackEntry?.savedStateHandle?.set("linked_sms_id", null)
        }
    }

    LaunchedEffect(isScanning, potentialTransactions) {
        if (!isScanning) {
            hasLoadedOnce = true
        }
        if (hasLoadedOnce && potentialTransactions.isEmpty()) {
            navController.popBackStack()
        }
    }

    if (isScanning && !hasLoadedOnce) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center,
        ) {
            Column(horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.spacedBy(8.dp)) {
                Text("Scanning for transactions...", style = MaterialTheme.typography.titleMedium)
                CircularProgressIndicator(modifier = Modifier.padding(top = 16.dp))
            }
        }
    } else {
        LazyColumn(
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp),
        ) {
            item {
                Text(
                    "${potentialTransactions.size} potential transactions found.",
                    style = MaterialTheme.typography.labelLarge,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                )
            }
            items(potentialTransactions, key = { it.sourceSmsId }) { pt ->
                PotentialTransactionItem(
                    transaction = pt,
                    onDismiss = { viewModel.dismissPotentialTransaction(it) },
                    onApprove = { transaction ->
                        val encodedPotentialTxn = URLEncoder.encode(Gson().toJson(transaction), "UTF-8")
                        val route = "approve_transaction_screen?potentialTxnJson=$encodedPotentialTxn"
                        navController.navigate(route)
                    },
                    onCreateRule = { transaction ->
                        val json = Gson().toJson(transaction)
                        val encodedJson = URLEncoder.encode(json, "UTF-8")
                        // --- FIX: Use query parameter format ---
                        navController.navigate("rule_creation_screen?potentialTransactionJson=$encodedJson")
                    },
                    onLink = { transaction ->
                        val json = Gson().toJson(transaction)
                        val encodedJson = URLEncoder.encode(json, "UTF-8")
                        navController.navigate("link_transaction_screen/$encodedJson")
                    }
                )
            }
        }
    }
}

@Composable
fun PotentialTransactionItem(
    transaction: PotentialTransaction,
    onDismiss: (PotentialTransaction) -> Unit,
    onApprove: (PotentialTransaction) -> Unit,
    onCreateRule: (PotentialTransaction) -> Unit,
    onLink: (PotentialTransaction) -> Unit
) {
    Card(modifier = Modifier.fillMaxWidth(), elevation = CardDefaults.cardElevation(2.dp)) {
        Column(modifier = Modifier.padding(16.dp)) {
            val amountColor = if (transaction.transactionType == "expense") MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary

            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(
                    text = transaction.merchantName ?: "Unknown Merchant",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    modifier = Modifier.weight(1f),
                )
                Text(
                    text = "${"%.2f".format(transaction.amount)}",
                    style = MaterialTheme.typography.titleLarge,
                    color = amountColor,
                    fontWeight = FontWeight.Bold,
                )
            }
            transaction.potentialAccount?.let {
                Text(
                    text = "Account: ${it.formattedName} (${it.accountType})",
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.SemiBold,
                    color = MaterialTheme.colorScheme.secondary
                )
            }
            Spacer(Modifier.height(4.dp))
            Text(
                text = "Type: ${transaction.transactionType.replaceFirstChar { it.uppercase() }}",
                style = MaterialTheme.typography.bodyMedium,
            )
            Spacer(Modifier.height(8.dp))
            Text(
                text = "Original Message: ${transaction.originalMessage}",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                maxLines = 2,
                overflow = TextOverflow.Ellipsis,
            )
            Spacer(Modifier.height(16.dp))
            Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                TextButton(onClick = { onLink(transaction) }) {
                    Text("Link to Existing")
                }
                Spacer(Modifier.width(8.dp))
                OutlinedButton(onClick = { onDismiss(transaction) }) { Text("Dismiss") }
                Spacer(Modifier.width(8.dp))
                Button(onClick = { onApprove(transaction) }) { Text("Approve") }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)
@Composable
fun ApproveTransactionScreen(
    navController: NavController,
    transactionViewModel: TransactionViewModel,
    settingsViewModel: SettingsViewModel,
    potentialTxn: PotentialTransaction,
) {
    var description by remember { mutableStateOf(potentialTxn.merchantName ?: "") }
    var notes by remember { mutableStateOf("") }
    var selectedTransactionType by remember(potentialTxn.transactionType) { mutableStateOf(potentialTxn.transactionType) }
    val scope = rememberCoroutineScope()
    val context = LocalContext.current

    val categories by transactionViewModel.allCategories.collectAsState(initial = emptyList())
    var selectedCategory by remember { mutableStateOf<Category?>(null) }

    val allTags by transactionViewModel.allTags.collectAsState()
    val selectedTags by transactionViewModel.selectedTags.collectAsState()

    var activeSheetContent by remember { mutableStateOf<ApproveSheetContent?>(null) }
    val sheetState = rememberModalBottomSheetState()


    val isSaveEnabled = description.isNotBlank() && selectedCategory != null

    DisposableEffect(Unit) {
        onDispose {
            transactionViewModel.clearSelectedTags()
        }
    }

    Scaffold { innerPadding ->
        LazyColumn(
            modifier = Modifier
                .padding(innerPadding)
                .fillMaxSize(),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                Card(elevation = CardDefaults.cardElevation(2.dp)) {
                    Column(Modifier.padding(16.dp)) {
                        Text(
                            "${"%,.2f".format(potentialTxn.amount)}",
                            style = MaterialTheme.typography.displaySmall,
                            modifier = Modifier.fillMaxWidth(),
                            textAlign = TextAlign.End,
                            fontWeight = FontWeight.Bold
                        )
                        HorizontalDivider(modifier = Modifier.padding(vertical = 12.dp))
                        OutlinedTextField(
                            value = description,
                            onValueChange = { description = it },
                            label = { Text("Description / Merchant") },
                            modifier = Modifier.fillMaxWidth(),
                            colors = OutlinedTextFieldDefaults.colors(
                                unfocusedBorderColor = Color.Transparent,
                                focusedBorderColor = Color.Transparent
                            ),
                            placeholder = { Text("What was this for?") }
                        )
                    }
                }
            }
            item {
                TabRow(selectedTabIndex = if (selectedTransactionType == "expense") 0 else 1) {
                    listOf("Expense", "Income").forEachIndexed { index, title ->
                        Tab(selected = (if (selectedTransactionType == "expense") 0 else 1) == index, onClick = {
                            selectedTransactionType = if (index == 0) "expense" else "income"
                        }, text = { Text(title) })
                    }
                }
            }

            item {
                Card(elevation = CardDefaults.cardElevation(2.dp)) {
                    Column {
                        DetailRow(
                            icon = Icons.Default.AccountBalanceWallet,
                            label = "Account",
                            value = potentialTxn.potentialAccount?.formattedName ?: "Unknown Account",
                            onClick = null // Not editable
                        )
                        HorizontalDivider()
                        DetailRow(
                            icon = Icons.Default.Category,
                            label = "Category",
                            value = selectedCategory?.name ?: "Select category",
                            onClick = { activeSheetContent = ApproveSheetContent.Category },
                            valueColor = if (selectedCategory == null) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.onSurface,
                            leadingIcon = { selectedCategory?.let { CategoryIcon(it, Modifier.size(24.dp)) } }
                        )
                        HorizontalDivider()
                        DetailRow(
                            icon = Icons.Default.NewLabel,
                            label = "Tags",
                            value = if (selectedTags.isEmpty()) "Add tags" else selectedTags.joinToString { it.name },
                            onClick = { activeSheetContent = ApproveSheetContent.Tags }
                        )
                        HorizontalDivider()
                        OutlinedTextField(
                            value = notes,
                            onValueChange = { notes = it },
                            modifier = Modifier.fillMaxWidth(),
                            placeholder = { Text("Add notes...") },
                            leadingIcon = { Icon(Icons.AutoMirrored.Filled.Notes, contentDescription = "Notes") },
                            colors = OutlinedTextFieldDefaults.colors(
                                unfocusedBorderColor = Color.Transparent,
                                focusedBorderColor = Color.Transparent,
                            )
                        )
                    }
                }
            }
            item {
                Row(modifier = Modifier.fillMaxWidth().padding(top = 8.dp), horizontalArrangement = Arrangement.spacedBy(16.dp)) {
                    OutlinedButton(onClick = { navController.popBackStack() }, modifier = Modifier.weight(1f)) {
                        Text("Cancel")
                    }
                    Button(
                        onClick = {
                            scope.launch {
                                val success = transactionViewModel.approveSmsTransaction(
                                    potentialTxn = potentialTxn,
                                    description = description,
                                    categoryId = selectedCategory?.id,
                                    notes = notes.takeIf { it.isNotBlank() },
                                    tags = selectedTags
                                )
                                if (success) {
                                    settingsViewModel.onTransactionApproved(potentialTxn.sourceSmsId)
                                    potentialTxn.merchantName?.let { originalName ->
                                        settingsViewModel.saveMerchantRenameRule(originalName, description)
                                    }
                                    val notificationManager = NotificationManagerCompat.from(context)
                                    notificationManager.cancel(potentialTxn.sourceSmsId.toInt())
                                    navController.popBackStack()
                                }
                            }
                        },
                        modifier = Modifier.weight(1f),
                        enabled = isSaveEnabled,
                    ) { Text("Save Transaction") }
                }
            }
        }
    }

    if (activeSheetContent != null) {
        ModalBottomSheet(
            onDismissRequest = { activeSheetContent = null },
            sheetState = sheetState
        ) {
            when (activeSheetContent) {
                is ApproveSheetContent.Category -> ApproveCategoryPickerSheet(
                    items = categories,
                    onItemSelected = { selectedCategory = it; activeSheetContent = null }
                )
                is ApproveSheetContent.Tags -> ApproveTagPickerSheet(
                    allTags = allTags,
                    selectedTags = selectedTags,
                    onTagSelected = transactionViewModel::onTagSelected,
                    onAddNewTag = transactionViewModel::addTagOnTheGo,
                    onConfirm = { activeSheetContent = null }
                )
                else -> {}
            }
        }
    }
}

@Composable
private fun DetailRow(
    icon: ImageVector,
    label: String,
    value: String,
    onClick: (() -> Unit)?,
    valueColor: Color = MaterialTheme.colorScheme.onSurface,
    leadingIcon: (@Composable () -> Unit)? = null
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .then(if (onClick != null) Modifier.clickable(onClick = onClick) else Modifier)
            .padding(16.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        if (leadingIcon != null) {
            leadingIcon()
        } else {
            Icon(icon, contentDescription = label)
        }
        Spacer(Modifier.width(16.dp))
        Text(label, modifier = Modifier.weight(1f))
        Text(value, color = valueColor, fontWeight = FontWeight.SemiBold)
        if (onClick != null) {
            Icon(Icons.Default.ChevronRight, contentDescription = null, tint = MaterialTheme.colorScheme.onSurfaceVariant)
        }
    }
}

@Composable
private fun ApproveCategoryPickerSheet(
    items: List<Category>,
    onItemSelected: (Category) -> Unit
) {
    Column(modifier = Modifier.navigationBarsPadding()) {
        Text(
            "Select Category",
            style = MaterialTheme.typography.titleLarge,
            modifier = Modifier.padding(16.dp)
        )
        LazyVerticalGrid(
            columns = GridCells.Adaptive(minSize = 100.dp),
            contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp),
            horizontalArrangement = Arrangement.spacedBy(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            items(items) { category ->
                Column(
                    modifier = Modifier
                        .clip(RoundedCornerShape(12.dp))
                        .clickable { onItemSelected(category) }
                        .padding(vertical = 12.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    CategoryIcon(category, Modifier.size(48.dp))
                    Text(category.name, style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center)
                }
            }
        }
        Spacer(Modifier.height(16.dp))
    }
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
private fun ApproveTagPickerSheet(
    allTags: List<Tag>,
    selectedTags: Set<Tag>,
    onTagSelected: (Tag) -> Unit,
    onAddNewTag: (String) -> Unit,
    onConfirm: () -> Unit
) {
    var newTagName by remember { mutableStateOf("") }

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
            .navigationBarsPadding(),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("Manage Tags", style = MaterialTheme.typography.titleLarge)
        FlowRow(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(8.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            allTags.forEach { tag ->
                FilterChip(
                    selected = tag in selectedTags,
                    onClick = { onTagSelected(tag) },
                    label = { Text(tag.name) }
                )
            }
        }
        HorizontalDivider()
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            OutlinedTextField(
                value = newTagName,
                onValueChange = { newTagName = it },
                label = { Text("New Tag Name") },
                modifier = Modifier.weight(1f)
            )
            IconButton(
                onClick = {
                    onAddNewTag(newTagName)
                    newTagName = ""
                },
                enabled = newTagName.isNotBlank()
            ) {
                Icon(Icons.Default.Add, contentDescription = "Add New Tag")
            }
        }
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.End,
            verticalAlignment = Alignment.CenterVertically
        ) {
            TextButton(onClick = onConfirm) { Text("Cancel") }
            Spacer(modifier = Modifier.width(8.dp))
            Button(onClick = {
                if (newTagName.isNotBlank()) {
                    onAddNewTag(newTagName)
                }
                onConfirm()
            }) { Text("Done") }
        }
    }
}

@Composable
private fun CategoryIcon(category: Category, modifier: Modifier = Modifier) {
    Box(
        modifier = modifier
            .clip(CircleShape)
            .background(CategoryIconHelper.getIconBackgroundColor(category.colorKey)),
        contentAlignment = Alignment.Center
    ) {
        if (category.iconKey == "letter_default") {
            Text(
                text = category.name.firstOrNull()?.uppercase() ?: "?",
                fontWeight = FontWeight.Bold,
                color = Color.Black,
                fontSize = 22.sp
            )
        } else {
            Icon(
                imageVector = CategoryIconHelper.getIcon(category.iconKey),
                contentDescription = null,
                tint = Color.Black,
                modifier = Modifier.padding(12.dp)
            )
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/TimePeriodReportScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/TimePeriodReportScreen.kt
// REASON: BUG FIX - The duplicated ViewModel and Factory code has been removed
// from this file to resolve the "Redeclaration" compilation errors. This screen
// now correctly uses the ViewModel from its dedicated file.
// REASON: REFACTOR - The `ReportHeader` subtitle is now dynamic and reflects
// the rolling time period (e.g., "Since Jul 8, 10:00 PM"). This provides a
// clearer and more accurate description of the data being displayed, matching
// the user's requirement.
// REASON: FEATURE - The UI has been enhanced by splitting the header into a
// "Hero" card and a new "Insights" card. The Hero card now has a more prominent
// design with a background icon, and the Insights card displays the percentage
// change and top spending category for the period.
// REASON: FEATURE - The "Total Spent" amount in the hero card now uses a
// subtle gradient text effect for added visual flair, completing the
// implementation of "Idea 3".
// FEATURE: The hero card has been redesigned to show both "Total Income" and
// "Total Spent" side-by-side, providing a more comprehensive financial overview
// for the selected period.
// =================================================================================
package io.pm.finlight.ui.screens

import android.app.Application
import android.graphics.Typeface
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectHorizontalDragGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.core.app.NotificationManagerCompat
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.github.mikephil.charting.charts.BarChart
import com.github.mikephil.charting.components.XAxis
import com.github.mikephil.charting.data.BarData
import com.github.mikephil.charting.data.BarDataSet
import com.github.mikephil.charting.formatter.IndexAxisValueFormatter
import io.pm.finlight.*
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.components.TransactionItem
import java.text.NumberFormat
import java.text.SimpleDateFormat
import java.util.*
import kotlin.math.abs

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun TimePeriodReportScreen(
    navController: NavController,
    timePeriod: TimePeriod,
    initialDateMillis: Long? = null // Allow null for default
) {
    val application = LocalContext.current.applicationContext as Application
    val factory = TimePeriodReportViewModelFactory(application, timePeriod, initialDateMillis)
    val viewModel: TimePeriodReportViewModel = viewModel(factory = factory)

    val selectedDate by viewModel.selectedDate.collectAsState()
    val transactions by viewModel.transactionsForPeriod.collectAsState()
    val chartDataPair by viewModel.chartData.collectAsState()
    val insights by viewModel.insights.collectAsState()

    val totalSpent = transactions.filter { it.transaction.transactionType == "expense" && !it.transaction.isExcluded }.sumOf { it.transaction.amount }
    val totalIncome by viewModel.totalIncome.collectAsState()

    val context = LocalContext.current
    LaunchedEffect(Unit) {
        if (timePeriod == TimePeriod.DAILY) {
            NotificationManagerCompat.from(context).cancel(2) // Daily Report Notification ID
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        text = when (timePeriod) {
                            TimePeriod.DAILY -> "Daily Report"
                            TimePeriod.WEEKLY -> "Weekly Report"
                            TimePeriod.MONTHLY -> "Monthly Report"
                        }
                    )
                },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent)
            )
        },
        containerColor = Color.Transparent // Make scaffold background transparent
    ) { innerPadding ->
        var dragAmount by remember { mutableStateOf(0f) }

        Column(
            modifier = Modifier
                .padding(innerPadding)
                .fillMaxSize()
                .pointerInput(Unit) {
                    detectHorizontalDragGestures(
                        onDragStart = { },
                        onDragEnd = {
                            if (dragAmount > 150) { // Swipe Right
                                viewModel.selectPreviousPeriod()
                            } else if (dragAmount < -150) { // Swipe Left
                                viewModel.selectNextPeriod()
                            }
                            dragAmount = 0f
                        },
                        onDragCancel = { dragAmount = 0f }
                    ) { change, horizontalDragAmount ->
                        dragAmount += horizontalDragAmount
                        change.consume()
                    }
                }
        ) {
            LazyColumn(
                modifier = Modifier.fillMaxSize(),
                contentPadding = PaddingValues(16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                item {
                    ReportHeader(
                        totalSpent = totalSpent,
                        totalIncome = totalIncome,
                        timePeriod = timePeriod,
                        selectedDate = selectedDate.time
                    )
                }

                item {
                    ReportInsightsCard(insights = insights)
                }

                item {
                    GlassPanel {
                        Column(
                            modifier = Modifier.padding(16.dp),
                            horizontalAlignment = Alignment.CenterHorizontally
                        ) {
                            Text(
                                "Spending Chart",
                                style = MaterialTheme.typography.titleLarge,
                                color = MaterialTheme.colorScheme.onSurface
                            )
                            Spacer(Modifier.height(16.dp))
                            if (chartDataPair != null) {
                                SpendingBarChart(
                                    chartData = chartDataPair!!
                                )
                            } else {
                                Box(
                                    modifier = Modifier
                                        .fillMaxWidth()
                                        .height(200.dp),
                                    contentAlignment = Alignment.Center
                                ) {
                                    Text(
                                        "No chart data for this period.",
                                        color = MaterialTheme.colorScheme.onSurfaceVariant
                                    )
                                }
                            }
                        }
                    }
                }

                if (transactions.isNotEmpty()) {
                    item {
                        Text(
                            "Transactions in this Period",
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                    items(transactions, key = { it.transaction.id }) { transaction ->
                        TransactionItem(
                            transactionDetails = transaction,
                            onClick = { navController.navigate("transaction_detail/${transaction.transaction.id}") }
                        )
                    }
                } else {
                    item {
                        GlassPanel {
                            Row(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(16.dp),
                                verticalAlignment = Alignment.CenterVertically,
                                horizontalArrangement = Arrangement.spacedBy(16.dp)
                            ) {
                                Icon(
                                    Icons.Default.Info,
                                    contentDescription = "Info",
                                    tint = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                                Text(
                                    "No transactions recorded for this period.",
                                    color = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun ReportHeader(totalSpent: Double, totalIncome: Double, timePeriod: TimePeriod, selectedDate: Date) {
    val subtitle = when (timePeriod) {
        TimePeriod.DAILY -> {
            val format = SimpleDateFormat("MMM d, h:mm a", Locale.getDefault())
            val startCal = Calendar.getInstance().apply {
                time = selectedDate
                add(Calendar.HOUR_OF_DAY, -24)
            }
            "Since ${format.format(startCal.time)}"
        }
        TimePeriod.WEEKLY -> {
            val format = SimpleDateFormat("MMM d", Locale.getDefault())
            val startCal = Calendar.getInstance().apply {
                time = selectedDate
                add(Calendar.DAY_OF_YEAR, -7)
            }
            "Since ${format.format(startCal.time)}"
        }
        TimePeriod.MONTHLY -> {
            val format = SimpleDateFormat("MMM d", Locale.getDefault())
            val startCal = Calendar.getInstance().apply {
                time = selectedDate
                add(Calendar.DAY_OF_YEAR, -30)
            }
            "Since ${format.format(startCal.time)}"
        }
    }

    val backgroundIcon = when (timePeriod) {
        TimePeriod.DAILY -> Icons.Default.CalendarViewDay
        TimePeriod.WEEKLY -> Icons.Default.CalendarViewWeek
        TimePeriod.MONTHLY -> Icons.Default.CalendarViewMonth
    }

    GlassPanel {
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .height(240.dp), // Increased height
            contentAlignment = Alignment.Center
        ) {
            Icon(
                imageVector = backgroundIcon,
                contentDescription = null,
                modifier = Modifier.size(180.dp), // Slightly larger icon
                tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.05f)
            )
            Column(
                modifier = Modifier.fillMaxSize(),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.SpaceEvenly
            ) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceAround,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text(
                            text = "Total Income",
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Text(
                            text = "${NumberFormat.getCurrencyInstance(Locale("en", "IN")).format(totalIncome).drop(1)}",
                            style = MaterialTheme.typography.headlineLarge,
                            fontWeight = FontWeight.Bold,
                            color = MaterialTheme.colorScheme.primary
                        )
                    }
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text(
                            text = "Total Spent",
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Text(
                            text = "${NumberFormat.getCurrencyInstance(Locale("en", "IN")).format(totalSpent).drop(1)}",
                            style = MaterialTheme.typography.headlineLarge,
                            fontWeight = FontWeight.Bold,
                            color = MaterialTheme.colorScheme.error
                        )
                    }
                }
                Text(
                    text = subtitle,
                    style = MaterialTheme.typography.bodyLarge,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

@Composable
private fun ReportInsightsCard(insights: ReportInsights?) {
    if (insights == null) return

    GlassPanel {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 24.dp, vertical = 16.dp),
            horizontalArrangement = Arrangement.SpaceAround,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                Text("Change", style = MaterialTheme.typography.labelLarge, color = MaterialTheme.colorScheme.onSurfaceVariant)
                val (text, color) = when {
                    insights.percentageChange == null -> "--" to MaterialTheme.colorScheme.onSurface
                    insights.percentageChange > 0 -> " ${insights.percentageChange}%" to MaterialTheme.colorScheme.error
                    insights.percentageChange < 0 -> " ${abs(insights.percentageChange)}%" to MaterialTheme.colorScheme.primary
                    else -> "No Change" to MaterialTheme.colorScheme.onSurface
                }
                Text(text, style = MaterialTheme.typography.headlineSmall, fontWeight = FontWeight.Bold, color = color)
                Text("vs. previous period", style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant)
            }

            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                Text("Top Spend", style = MaterialTheme.typography.labelLarge, color = MaterialTheme.colorScheme.onSurfaceVariant)
                if (insights.topCategory != null) {
                    Icon(
                        imageVector = CategoryIconHelper.getIcon(insights.topCategory.iconKey ?: "category"),
                        contentDescription = insights.topCategory.categoryName,
                        modifier = Modifier
                            .size(36.dp)
                            .clip(CircleShape)
                            .background(CategoryIconHelper.getIconBackgroundColor(insights.topCategory.colorKey ?: "gray_light"))
                            .padding(8.dp),
                        tint = Color.Black
                    )
                    Text(insights.topCategory.categoryName, style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant)
                } else {
                    Text("--", style = MaterialTheme.typography.headlineSmall, fontWeight = FontWeight.Bold, color = MaterialTheme.colorScheme.onSurface)
                }
            }
        }
    }
}


@Composable
private fun SpendingBarChart(chartData: Pair<BarData, List<String>>) {
    val (barData, labels) = chartData
    val selectedIndex = labels.size - 1

    val highlightColor = MaterialTheme.colorScheme.primary.toArgb()
    val defaultColor = MaterialTheme.colorScheme.surfaceVariant.toArgb()
    val axisTextColor = MaterialTheme.colorScheme.onSurface.toArgb()
    val valueTextColor = MaterialTheme.colorScheme.onSurfaceVariant.toArgb()

    val colors = labels.indices.map { if (it == selectedIndex) highlightColor else defaultColor }
    (barData.dataSets.first() as BarDataSet).colors = colors

    AndroidView(
        factory = { context ->
            BarChart(context).apply {
                description.isEnabled = false
                legend.isEnabled = false
                setDrawGridBackground(false)
                setDrawValueAboveBar(true)
                setTouchEnabled(false)

                xAxis.apply {
                    position = XAxis.XAxisPosition.BOTTOM
                    setDrawGridLines(false)
                    setDrawAxisLine(false)
                    granularity = 1f
                    valueFormatter = IndexAxisValueFormatter(labels)
                    textColor = axisTextColor
                    textSize = 12f
                    typeface = Typeface.DEFAULT_BOLD
                }
                axisLeft.apply {
                    setDrawGridLines(true)
                    gridColor = axisTextColor and 0x22FFFFFF // Transparent grid lines
                    setDrawLabels(false)
                    setDrawAxisLine(false)
                    axisMinimum = 0f
                }
                axisRight.isEnabled = false
            }
        },
        update = { chart ->
            chart.data = barData
            (chart.data.dataSets.first() as BarDataSet).valueTextColor = valueTextColor
            chart.invalidate()
        },
        modifier = Modifier
            .fillMaxWidth()
            .height(200.dp)
    )
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/SettingsSubScreens.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/SettingsSubScreens.kt
// REASON: UX REFINEMENT - The informational text within the `CsvInfoDialog` has
// been updated to include the new "Tags" column. This ensures the user is
// shown the correct, up-to-date format required for CSV imports, including
// instructions on how to format multiple tags.
// =================================================================================
package io.pm.finlight.ui.screens

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.automirrored.filled.ManageSearch
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.core.content.ContextCompat
import androidx.navigation.NavController
import io.pm.finlight.DataExportService
import io.pm.finlight.ScanResult
import io.pm.finlight.SettingsViewModel
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.components.MonthlyReportTimePicker
import io.pm.finlight.ui.components.SettingsActionItem
import io.pm.finlight.ui.components.SettingsToggleItem
import io.pm.finlight.ui.components.WeeklyReportTimePicker
import io.pm.finlight.ui.theme.AppTheme
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*
import androidx.compose.ui.unit.dp

private fun Color.isDark() = (red * 0.299 + green * 0.587 + blue * 0.114) < 0.5

private fun hasSmsPermission(context: Context): Boolean {
    return ContextCompat.checkSelfPermission(context, Manifest.permission.READ_SMS) == PackageManager.PERMISSION_GRANTED
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AppearanceSettingsScreen(navController: NavController, settingsViewModel: SettingsViewModel) {
    val selectedTheme by settingsViewModel.selectedTheme.collectAsState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Theme & Appearance") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back")
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent)
            )
        },
        containerColor = Color.Transparent
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier.fillMaxSize().padding(innerPadding),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                GlassPanel {
                    Column(modifier = Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
                        Text(
                            text = "Theme",
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.onSurface
                        )
                        Text(
                            text = "Select the app's color palette.",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Spacer(Modifier.height(8.dp))
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceAround
                        ) {
                            AppTheme.entries.forEach { theme ->
                                ThemePickerItem(
                                    theme = theme,
                                    isSelected = selectedTheme == theme,
                                    onClick = { settingsViewModel.saveSelectedTheme(theme) }
                                )
                            }
                        }
                    }
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AutomationSettingsScreen(navController: NavController, settingsViewModel: SettingsViewModel) {
    val context = LocalContext.current
    val isScanning by settingsViewModel.isScanning.collectAsState()
    var showDatePickerDialog by remember { mutableStateOf(false) }
    val smsScanStartDate by settingsViewModel.smsScanStartDate.collectAsState()
    val dateFormatter = remember { SimpleDateFormat("dd MMMM, yyyy", Locale.getDefault()) }
    val isUnknownTransactionPopupEnabled by settingsViewModel.unknownTransactionPopupEnabled.collectAsState()

    val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
    val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Automation") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back")
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent)
            )
        },
        containerColor = Color.Transparent
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier.fillMaxSize().padding(innerPadding),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                GlassPanel {
                    Column {
                        SettingsActionItem(
                            text = "Scan Full Inbox",
                            subtitle = "Scan all messages to find transactions",
                            icon = Icons.AutoMirrored.Filled.ManageSearch,
                            onClick = {
                                if (hasSmsPermission(context)) {
                                    if (!isScanning) settingsViewModel.rescanSmsForReview(null)
                                } else {
                                    Toast.makeText(context, "SMS permission is required.", Toast.LENGTH_SHORT).show()
                                }
                            },
                        )
                        HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                        ListItem(
                            colors = ListItemDefaults.colors(containerColor = Color.Transparent),
                            headlineContent = { Text("Scan from specific date", color = MaterialTheme.colorScheme.onSurface) },
                            supportingContent = {
                                Text(
                                    text = "Start date: ${dateFormatter.format(Date(smsScanStartDate))}",
                                    modifier = Modifier.clickable { showDatePickerDialog = true },
                                    color = MaterialTheme.colorScheme.primary,
                                    style = MaterialTheme.typography.bodySmall
                                )
                            },
                            leadingContent = { Icon(Icons.Default.Event, "Scan from date", tint = MaterialTheme.colorScheme.primary) },
                            trailingContent = {
                                Button(
                                    onClick = {
                                        if (hasSmsPermission(context)) {
                                            if (!isScanning) settingsViewModel.rescanSmsForReview(smsScanStartDate)
                                        } else {
                                            Toast.makeText(context, "SMS permission is required.", Toast.LENGTH_SHORT).show()
                                        }
                                    },
                                    enabled = !isScanning
                                ) { Text("Scan") }
                            }
                        )
                        HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                        SettingsActionItem(
                            text = "Manage Custom Parse Rules",
                            subtitle = "View or delete your SMS parsing rules",
                            icon = Icons.Default.Rule,
                            onClick = { navController.navigate("manage_parse_rules") },
                        )
                        HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                        SettingsActionItem(
                            text = "Manage Parser Ignore List",
                            subtitle = "Add or remove phrases to ignore",
                            icon = Icons.Default.Block,
                            onClick = { navController.navigate("manage_ignore_rules") },
                        )
                        HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                        SettingsToggleItem(
                            title = "Popup for Unknown Transactions",
                            subtitle = "Show notification for new merchants",
                            icon = Icons.Default.HelpOutline,
                            checked = isUnknownTransactionPopupEnabled,
                            onCheckedChange = { settingsViewModel.setUnknownTransactionPopupEnabled(it) },
                        )
                    }
                }
            }
        }
    }

    if (showDatePickerDialog) {
        val datePickerState = rememberDatePickerState(initialSelectedDateMillis = smsScanStartDate)
        DatePickerDialog(
            onDismissRequest = { showDatePickerDialog = false },
            confirmButton = {
                TextButton(
                    onClick = {
                        datePickerState.selectedDateMillis?.let {
                            settingsViewModel.saveSmsScanStartDate(it)
                        }
                        showDatePickerDialog = false
                    }
                ) { Text("OK") }
            },
            dismissButton = {
                TextButton(onClick = { showDatePickerDialog = false }) { Text("Cancel") }
            },
            colors = DatePickerDefaults.colors(containerColor = popupContainerColor)
        ) {
            DatePicker(state = datePickerState)
        }
    }

    if (isScanning) {
        Surface(
            modifier = Modifier.fillMaxSize(),
            color = MaterialTheme.colorScheme.scrim.copy(alpha = 0.5f),
        ) {
            Box(contentAlignment = Alignment.Center) {
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    CircularProgressIndicator()
                    Spacer(Modifier.height(16.dp))
                    Text("Scanning SMS Inbox...", style = MaterialTheme.typography.titleMedium, color = Color.White)
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun NotificationSettingsScreen(navController: NavController, settingsViewModel: SettingsViewModel) {
    val isWeeklySummaryEnabled by settingsViewModel.weeklySummaryEnabled.collectAsState()
    val isDailyReportEnabled by settingsViewModel.dailyReportEnabled.collectAsState()
    val isMonthlySummaryEnabled by settingsViewModel.monthlySummaryEnabled.collectAsState()
    val dailyReportTime by settingsViewModel.dailyReportTime.collectAsState()
    var showDailyTimePicker by remember { mutableStateOf(false) }
    val weeklyReportTime by settingsViewModel.weeklyReportTime.collectAsState()
    var showWeeklyTimePicker by remember { mutableStateOf(false) }
    val monthlyReportTime by settingsViewModel.monthlyReportTime.collectAsState()
    var showMonthlyTimePicker by remember { mutableStateOf(false) }

    val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
    val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Notifications") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back")
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent)
            )
        },
        containerColor = Color.Transparent
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier.fillMaxSize().padding(innerPadding),
            contentPadding = PaddingValues(16.dp),
        ) {
            item {
                GlassPanel {
                    Column {
                        SettingsToggleItem(
                            title = "Daily Summary",
                            subtitle = "Report of yesterday's spending",
                            icon = Icons.Default.Notifications,
                            checked = isDailyReportEnabled,
                            onCheckedChange = { settingsViewModel.setDailyReportEnabled(it) },
                        )
                        SettingsActionItem(
                            text = "Daily Report Time",
                            subtitle = "Current: ${String.format("%02d:%02d", dailyReportTime.first, dailyReportTime.second)}",
                            icon = Icons.Default.Schedule,
                            onClick = { showDailyTimePicker = true },
                            enabled = isDailyReportEnabled
                        )
                        HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                        SettingsToggleItem(
                            title = "Weekly Summary",
                            subtitle = "Summary of your finances every week",
                            icon = Icons.Default.CalendarViewWeek,
                            checked = isWeeklySummaryEnabled,
                            onCheckedChange = { settingsViewModel.setWeeklySummaryEnabled(it) },
                        )
                        SettingsActionItem(
                            text = "Weekly Report Time",
                            subtitle = "Current: ${SimpleDateFormat("EEEE", Locale.getDefault()).format(
                                Calendar.getInstance().apply { set(Calendar.DAY_OF_WEEK, weeklyReportTime.first) }.time
                            )} at ${String.format("%02d:%02d", weeklyReportTime.second, weeklyReportTime.third)}",
                            icon = Icons.Default.Schedule,
                            onClick = { showWeeklyTimePicker = true },
                            enabled = isWeeklySummaryEnabled
                        )
                        HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                        SettingsToggleItem(
                            title = "Monthly Summary",
                            subtitle = "Summary of last month's finances",
                            icon = Icons.Default.CalendarViewMonth,
                            checked = isMonthlySummaryEnabled,
                            onCheckedChange = { settingsViewModel.setMonthlySummaryEnabled(it) },
                        )
                        SettingsActionItem(
                            text = "Monthly Report Time",
                            subtitle = "Current: Day ${monthlyReportTime.first} at ${String.format("%02d:%02d", monthlyReportTime.second, monthlyReportTime.third)}",
                            icon = Icons.Default.Schedule,
                            onClick = { showMonthlyTimePicker = true },
                            enabled = isMonthlySummaryEnabled
                        )
                    }
                }
            }
        }
    }

    if (showDailyTimePicker) {
        val timePickerState = rememberTimePickerState(
            initialHour = dailyReportTime.first,
            initialMinute = dailyReportTime.second,
            is24Hour = false
        )
        AlertDialog(
            onDismissRequest = { showDailyTimePicker = false },
            title = { Text("Select Daily Report Time") },
            text = {
                Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                    TimePicker(state = timePickerState)
                }
            },
            confirmButton = {
                TextButton(
                    onClick = {
                        settingsViewModel.saveDailyReportTime(timePickerState.hour, timePickerState.minute)
                        showDailyTimePicker = false
                    }
                ) { Text("OK") }
            },
            dismissButton = {
                TextButton(onClick = { showDailyTimePicker = false }) { Text("Cancel") }
            },
            containerColor = popupContainerColor
        )
    }

    if (showWeeklyTimePicker) {
        WeeklyReportTimePicker(
            initialDay = weeklyReportTime.first,
            initialHour = weeklyReportTime.second,
            initialMinute = weeklyReportTime.third,
            onDismiss = { showWeeklyTimePicker = false },
            onConfirm = { day, hour, minute ->
                settingsViewModel.saveWeeklyReportTime(day, hour, minute)
                showWeeklyTimePicker = false
            }
        )
    }

    if (showMonthlyTimePicker) {
        MonthlyReportTimePicker(
            initialDay = monthlyReportTime.first,
            initialHour = monthlyReportTime.second,
            initialMinute = monthlyReportTime.third,
            onDismiss = { showMonthlyTimePicker = false },
            onConfirm = { day, hour, minute ->
                settingsViewModel.saveMonthlyReportTime(day, hour, minute)
                showMonthlyTimePicker = false
            }
        )
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DataSettingsScreen(navController: NavController, settingsViewModel: SettingsViewModel) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val isAppLockEnabled by settingsViewModel.appLockEnabled.collectAsState()
    var showImportJsonDialog by remember { mutableStateOf(false) }
    var showCsvInfoDialog by remember { mutableStateOf(false) }
    val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
    val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

    val jsonFileSaverLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.CreateDocument("application/json"),
        onResult = { uri ->
            uri?.let {
                scope.launch {
                    val jsonString = DataExportService.exportToJsonString(context)
                    if (jsonString != null) {
                        try {
                            context.contentResolver.openOutputStream(it)?.use { outputStream ->
                                outputStream.write(jsonString.toByteArray())
                            }
                            Toast.makeText(context, "Data exported successfully!", Toast.LENGTH_LONG).show()
                        } catch (e: Exception) {
                            Toast.makeText(context, "Error saving file.", Toast.LENGTH_LONG).show()
                        }
                    } else {
                        Toast.makeText(context, "Error exporting data.", Toast.LENGTH_LONG).show()
                    }
                }
            }
        }
    )

    val csvFileSaverLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.CreateDocument("text/csv"),
        onResult = { uri ->
            uri?.let {
                scope.launch {
                    val csvString = DataExportService.exportToCsvString(context)
                    if (csvString != null) {
                        try {
                            context.contentResolver.openOutputStream(it)?.use { outputStream ->
                                outputStream.write(csvString.toByteArray())
                            }
                            Toast.makeText(context, "CSV exported successfully!", Toast.LENGTH_LONG).show()
                        } catch (e: Exception) {
                            Toast.makeText(context, "Error saving CSV file.", Toast.LENGTH_LONG).show()
                        }
                    } else {
                        Toast.makeText(context, "Error exporting CSV data.", Toast.LENGTH_LONG).show()
                    }
                }
            }
        }
    )

    val csvTemplateSaverLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.CreateDocument("text/csv"),
        onResult = { uri ->
            uri?.let {
                scope.launch {
                    try {
                        context.contentResolver.openOutputStream(it)?.use { outputStream ->
                            outputStream.write(DataExportService.getCsvTemplateString().toByteArray())
                        }
                        Toast.makeText(context, "Template saved!", Toast.LENGTH_SHORT).show()
                    } catch (e: Exception) {
                        Toast.makeText(context, "Error saving template.", Toast.LENGTH_SHORT).show()
                    }
                }
            }
        }
    )

    val csvImportLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.OpenDocument(),
        onResult = { uri ->
            uri?.let {
                settingsViewModel.validateCsvFile(it)
                navController.navigate("csv_validation_screen")
            }
        }
    )

    val jsonImportLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.OpenDocument(),
        onResult = { uri ->
            uri?.let {
                scope.launch {
                    if (DataExportService.importDataFromJson(context, it)) {
                        Toast.makeText(context, "Data imported successfully! Please restart the app.", Toast.LENGTH_LONG).show()
                    } else {
                        Toast.makeText(context, "Failed to import data.", Toast.LENGTH_LONG).show()
                    }
                }
            }
        }
    )

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Security & Data") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back")
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent)
            )
        },
        containerColor = Color.Transparent
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier.fillMaxSize().padding(innerPadding),
            contentPadding = PaddingValues(16.dp),
        ) {
            item {
                GlassPanel {
                    Column {
                        SettingsToggleItem(
                            title = "Enable App Lock",
                            subtitle = "Use biometrics to secure the app",
                            icon = Icons.Default.Fingerprint,
                            checked = isAppLockEnabled,
                            onCheckedChange = { settingsViewModel.setAppLockEnabled(it) },
                        )
                        HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                        SettingsActionItem(
                            text = "Export Data (JSON)",
                            subtitle = "Create a full backup of all your data",
                            icon = Icons.Default.DataObject,
                            onClick = {
                                val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
                                val fileName = "Finlight_Backup_${sdf.format(Date())}.json"
                                jsonFileSaverLauncher.launch(fileName)
                            },
                        )
                        HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                        SettingsActionItem(
                            text = "Export Transactions (CSV)",
                            subtitle = "Save transactions in a spreadsheet format",
                            icon = Icons.Default.GridOn,
                            onClick = {
                                val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
                                val fileName = "Finlight_Transactions_${sdf.format(Date())}.csv"
                                csvFileSaverLauncher.launch(fileName)
                            },
                        )
                        HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                        SettingsActionItem(
                            text = "Import from JSON",
                            subtitle = "Restore data from a backup file",
                            icon = Icons.Default.Download,
                            onClick = { showImportJsonDialog = true },
                        )
                        HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                        SettingsActionItem(
                            text = "Import from CSV",
                            subtitle = "Add new transactions from a CSV file",
                            icon = Icons.Default.PostAdd,
                            onClick = { showCsvInfoDialog = true },
                        )
                    }
                }
            }
        }
    }

    if (showCsvInfoDialog) {
        CsvInfoDialog(
            onDismiss = { showCsvInfoDialog = false },
            onExportTemplate = {
                val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
                val fileName = "Finlight_Import_Template_${sdf.format(Date())}.csv"
                csvTemplateSaverLauncher.launch(fileName)
            },
            onProceed = {
                showCsvInfoDialog = false
                csvImportLauncher.launch(arrayOf("text/csv", "text/comma-separated-values"))
            }
        )
    }

    if (showImportJsonDialog) {
        AlertDialog(
            onDismissRequest = { showImportJsonDialog = false },
            title = { Text("Import from JSON?") },
            text = { Text("WARNING: This will DELETE all current data and replace it. This cannot be undone.") },
            confirmButton = {
                Button(
                    onClick = {
                        showImportJsonDialog = false
                        jsonImportLauncher.launch(arrayOf("application/json"))
                    },
                    colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
                ) { Text("Wipe and Import") }
            },
            dismissButton = { TextButton(onClick = { showImportJsonDialog = false }) { Text("Cancel") } },
            containerColor = popupContainerColor
        )
    }
}

@Composable
private fun ThemePickerItem(
    theme: AppTheme,
    isSelected: Boolean,
    onClick: () -> Unit
) {
    val isDark = isSystemInDarkTheme()
    val borderColor = if (isSelected) MaterialTheme.colorScheme.primary else Color.Transparent

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(8.dp),
        modifier = Modifier.clickable(onClick = onClick)
    ) {
        Box(
            modifier = Modifier
                .size(56.dp)
                .clip(CircleShape)
                .border(2.dp, borderColor, CircleShape)
                .padding(4.dp)
        ) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .clip(CircleShape)
                    .background(
                        brush = Brush.horizontalGradient(
                            colors = listOf(
                                if (isDark) theme.darkColor else theme.lightColor,
                                if (isDark) theme.darkColor.copy(alpha = 0.7f) else theme.lightColor.copy(alpha = 0.7f)
                            )
                        )
                    ),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = theme.icon,
                    contentDescription = theme.displayName,
                    tint = if (isDark) Color.White.copy(alpha = 0.8f) else Color.Black.copy(alpha = 0.8f),
                    modifier = Modifier.size(28.dp)
                )
            }
        }
        Text(
            text = theme.displayName,
            style = MaterialTheme.typography.labelMedium,
            color = if (isSelected) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurfaceVariant
        )
    }
}

@Composable
private fun CsvInfoDialog(
    onDismiss: () -> Unit,
    onExportTemplate: () -> Unit,
    onProceed: () -> Unit
) {
    val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
    val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

    AlertDialog(
        onDismissRequest = onDismiss,
        containerColor = popupContainerColor,
        title = { Text("CSV Import Format") },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                Text("Please ensure your CSV file has the following columns in this exact order:")
                // --- UPDATED: Added "Tags" to the format string ---
                Text(
                    text = "Date,Description,Amount,Type,Category,Account,Notes,IsExcluded,Tags",
                    fontFamily = FontFamily.Monospace,
                    fontWeight = FontWeight.Bold,
                    style = MaterialTheme.typography.bodyMedium
                )
                Text(" Date format must be: yyyy-MM-dd HH:mm:ss")
                Text(" Type must be 'income' or 'expense'.")
                Text(" isExcluded must be 'true' or 'false'.")
                // --- NEW: Added instruction for tags ---
                Text(" Multiple tags should be separated by a pipe character (e.g., \"Work|Travel\").")
                Spacer(Modifier.height(16.dp))
                TextButton(onClick = onExportTemplate, modifier = Modifier.fillMaxWidth()) {
                    Text("Export Template File")
                }
            }
        },
        confirmButton = {
            Button(onClick = onProceed) {
                Text("Proceed to Import")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        }
    )
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/AddTransactionScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/AddTransactionScreen.kt
// REASON: FEATURE - Added a segmented button to allow toggling between "Expense"
// and "Income" transaction types, completing the core functionality of the
// Transaction Composer. The control is styled to match the "Project Aurora"
// glassmorphism aesthetic.
// BUG FIX - Replaced direct use of `GlassPanelFill` with the `GlassPanel`
// composable to ensure the component is theme-aware and to resolve the
// "Unresolved reference" build error.
// =================================================================================
package io.pm.finlight.ui.screens

import android.net.Uri
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.animation.*
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.tween
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.interaction.collectIsPressedAsState
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.automirrored.filled.Backspace
import androidx.compose.material.icons.automirrored.filled.Notes
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Paint
import androidx.compose.ui.graphics.drawscope.drawIntoCanvas
import androidx.compose.ui.graphics.nativeCanvas
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardCapitalization
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import io.pm.finlight.*
import io.pm.finlight.ui.components.*
import io.pm.finlight.ui.theme.AuroraNumpadHighlight
import io.pm.finlight.ui.theme.GlassPanelBorder
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight
import kotlinx.coroutines.launch
import java.net.URLDecoder
import java.text.SimpleDateFormat
import java.util.*

private sealed class ComposerSheet {
    object Category : ComposerSheet()
    object Account : ComposerSheet()
    object Tags : ComposerSheet()
    object Description : ComposerSheet()
    object Notes : ComposerSheet()
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddTransactionScreen(
    navController: NavController,
    viewModel: TransactionViewModel,
    isCsvEdit: Boolean = false,
    csvLineNumber: Int = -1,
    initialDataJson: String? = null
) {
    // region State Variables
    val context = LocalContext.current
    val scope = rememberCoroutineScope()

    var amount by remember { mutableStateOf("") }
    var description by remember { mutableStateOf("") }
    var transactionType by remember { mutableStateOf("expense") } // Default to expense
    var notes by remember { mutableStateOf("") }
    var attachedImageUris by remember { mutableStateOf<List<Uri>>(emptyList()) }

    val imagePickerLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetMultipleContents()
    ) { uris: List<Uri> ->
        attachedImageUris = attachedImageUris + uris
    }

    val accounts by viewModel.allAccounts.collectAsState(initial = emptyList())
    val categories by viewModel.allCategories.collectAsState(initial = emptyList())
    val allTags by viewModel.allTags.collectAsState()
    val selectedTags by viewModel.selectedTags.collectAsState()
    val defaultAccount by viewModel.defaultAccount.collectAsState()
    val validationError by viewModel.validationError.collectAsState()

    var selectedAccount by remember { mutableStateOf<Account?>(null) }
    var selectedCategory by remember { mutableStateOf<Category?>(null) }
    val selectedDateTime by remember { mutableStateOf(Calendar.getInstance()) }

    var showDatePicker by remember { mutableStateOf(false) }
    var showTimePicker by remember { mutableStateOf(false) }

    var activeSheet by remember { mutableStateOf<ComposerSheet?>(null) }
    val sheetState = rememberModalBottomSheetState(skipPartiallyExpanded = true)

    var showCreateAccountDialog by remember { mutableStateOf(false) }
    var showCreateCategoryDialog by remember { mutableStateOf(false) }

    val isSaveEnabled = amount.isNotBlank() && description.isNotBlank() && selectedAccount != null && selectedCategory != null
    // endregion

    // region Helper Functions & Effects
    fun resetAllState() {
        amount = ""
        description = ""
        transactionType = "expense"
        notes = ""
        attachedImageUris = emptyList()
        selectedCategory = null
        selectedDateTime.timeInMillis = System.currentTimeMillis()
        viewModel.clearAddTransactionState()
    }

    LaunchedEffect(Unit) {
        viewModel.clearAddTransactionState()
    }

    LaunchedEffect(defaultAccount) {
        if (!isCsvEdit && selectedAccount == null) {
            selectedAccount = defaultAccount
        }
    }

    LaunchedEffect(initialDataJson, accounts, categories) {
        if (isCsvEdit && initialDataJson != null) {
            try {
                val gson = Gson()
                val initialData: List<String> = gson.fromJson(URLDecoder.decode(initialDataJson, "UTF-8"), object : TypeToken<List<String>>() {}.type)
                val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())

                initialData.getOrNull(0)?.let {
                    try {
                        selectedDateTime.time = dateFormat.parse(it) ?: Date()
                    } catch (e: Exception) { /* Keep default date on parse error */ }
                }
                description = initialData.getOrElse(1) { "" }
                amount = initialData.getOrElse(2) { "" }.replace(".0", "")
                transactionType = initialData.getOrElse(3) { "expense" }
                val categoryName = initialData.getOrElse(4) { "" }
                val accountName = initialData.getOrElse(5) { "" }
                notes = initialData.getOrElse(6) { "" }

                selectedCategory = categories.find { it.name.equals(categoryName, ignoreCase = true) }
                selectedAccount = accounts.find { it.name.equals(accountName, ignoreCase = true) }

            } catch (e: Exception) {
                Toast.makeText(context, "Error loading row data", Toast.LENGTH_SHORT).show()
            }
        }
    }

    LaunchedEffect(validationError) {
        validationError?.let {
            Toast.makeText(context, it, Toast.LENGTH_LONG).show()
            viewModel.clearError()
        }
    }
    // endregion

    val categoryColor by remember(selectedCategory) {
        derivedStateOf {
            selectedCategory?.let { CategoryIconHelper.getIconBackgroundColor(it.colorKey) }
        }
    }

    val animatedCategoryColor by animateColorAsState(
        targetValue = categoryColor ?: Color.Transparent,
        animationSpec = tween(durationMillis = 500),
        label = "CategoryColorAnimation"
    )

    Box(modifier = Modifier.fillMaxSize()) {
        SpotlightBackground(color = animatedCategoryColor)

        Scaffold(
            topBar = {
                TopAppBar(
                    title = { Text("Compose Transaction") },
                    navigationIcon = {
                        IconButton(onClick = { navController.popBackStack() }) {
                            Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                        }
                    },
                    colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent)
                )
            },
            containerColor = Color.Transparent
        ) { innerPadding ->
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(innerPadding)
                    .padding(horizontal = 16.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Spacer(Modifier.weight(0.5f))
                AmountComposer(
                    amount = amount,
                    description = description,
                    onDescriptionClick = { activeSheet = ComposerSheet.Description }
                )
                Spacer(Modifier.height(24.dp))

                TransactionTypeToggle(
                    selectedType = transactionType,
                    onTypeSelected = { transactionType = it }
                )

                Spacer(Modifier.height(24.dp))
                OrbitalChips(
                    selectedCategory = selectedCategory,
                    selectedAccount = selectedAccount,
                    selectedDateTime = selectedDateTime.time,
                    onCategoryClick = { activeSheet = ComposerSheet.Category },
                    onAccountClick = { activeSheet = ComposerSheet.Account },
                    onDateClick = { showDatePicker = true }
                )
                Spacer(Modifier.weight(1f))

                ActionRow(
                    notes = notes,
                    tags = selectedTags,
                    imageCount = attachedImageUris.size,
                    onNotesClick = { activeSheet = ComposerSheet.Notes },
                    onTagsClick = { activeSheet = ComposerSheet.Tags },
                    onAttachmentClick = { imagePickerLauncher.launch("image/*") }
                )

                GlassmorphicNumpad(
                    onDigitClick = { digit -> if (amount.length < 9) amount += digit },
                    onBackspaceClick = { if (amount.isNotEmpty()) amount = amount.dropLast(1) },
                    onConfirm = {
                        scope.launch {
                            val success = viewModel.addTransaction(
                                description = description,
                                categoryId = selectedCategory?.id,
                                amountStr = amount,
                                accountId = selectedAccount!!.id,
                                notes = notes.takeIf { it.isNotBlank() },
                                date = selectedDateTime.timeInMillis,
                                transactionType = transactionType,
                                imageUris = attachedImageUris
                            )
                            if (success) {
                                navController.popBackStack()
                            }
                        }
                    },
                    isConfirmEnabled = isSaveEnabled
                )
                Spacer(Modifier.height(16.dp))
            }
        }
    }

    // region Modals and Dialogs
    if (activeSheet != null) {
        ModalBottomSheet(
            onDismissRequest = { activeSheet = null },
            sheetState = sheetState,
            containerColor = if (isSystemInDarkTheme()) PopupSurfaceDark else PopupSurfaceLight
        ) {
            when (val sheet = activeSheet) {
                is ComposerSheet.Account -> PickerSheet(
                    title = "Select Account",
                    items = accounts,
                    onItemSelected = { selectedAccount = it; activeSheet = null },
                    onAddNew = { showCreateAccountDialog = true; activeSheet = null },
                    itemContent = { account ->
                        Text(account.name, color = MaterialTheme.colorScheme.onSurface)
                    }
                )
                is ComposerSheet.Category -> PickerSheet(
                    title = "Select Category",
                    items = categories,
                    onItemSelected = { selectedCategory = it; activeSheet = null },
                    onAddNew = { showCreateCategoryDialog = true; activeSheet = null },
                    itemContent = { category ->
                        CategoryPickerItem(category)
                    }
                )
                is ComposerSheet.Tags -> TagPickerSheet(
                    allTags = allTags,
                    selectedTags = selectedTags,
                    onTagSelected = viewModel::onTagSelected,
                    onAddNewTag = viewModel::addTagOnTheGo,
                    onConfirm = { activeSheet = null }
                )
                is ComposerSheet.Description -> TextInputSheet(
                    title = "Paid to",
                    initialValue = description,
                    onConfirm = {
                        description = it
                        activeSheet = null
                    }
                )
                is ComposerSheet.Notes -> TextInputSheet(
                    title = "Add Notes",
                    initialValue = notes,
                    onConfirm = {
                        notes = it
                        activeSheet = null
                    }
                )
                null -> {}
            }
        }
    }

    if (showDatePicker) {
        val datePickerState = rememberDatePickerState(initialSelectedDateMillis = selectedDateTime.timeInMillis)
        DatePickerDialog(
            onDismissRequest = { showDatePicker = false },
            confirmButton = {
                TextButton(onClick = {
                    datePickerState.selectedDateMillis?.let {
                        val cal = Calendar.getInstance().apply { timeInMillis = it }
                        selectedDateTime.set(Calendar.YEAR, cal.get(Calendar.YEAR))
                        selectedDateTime.set(Calendar.MONTH, cal.get(Calendar.MONTH))
                        selectedDateTime.set(Calendar.DAY_OF_MONTH, cal.get(Calendar.DAY_OF_MONTH))
                    }
                    showDatePicker = false
                    showTimePicker = true
                }) { Text("OK") }
            },
            dismissButton = { TextButton(onClick = { showDatePicker = false }) { Text("Cancel") } }
        ) { DatePicker(state = datePickerState) }
    }

    if (showTimePicker) {
        val timePickerState = rememberTimePickerState(
            initialHour = selectedDateTime.get(Calendar.HOUR_OF_DAY),
            initialMinute = selectedDateTime.get(Calendar.MINUTE)
        )
        TimePickerDialog(
            onDismissRequest = { showTimePicker = false },
            onConfirm = {
                selectedDateTime.set(Calendar.HOUR_OF_DAY, timePickerState.hour)
                selectedDateTime.set(Calendar.MINUTE, timePickerState.minute)
                showTimePicker = false
            }
        ) { TimePicker(state = timePickerState) }
    }

    if (showCreateAccountDialog) {
        CreateAccountDialog(
            onDismiss = { showCreateAccountDialog = false },
            onConfirm = { name, type ->
                viewModel.createAccount(name, type) { newAccount ->
                    selectedAccount = newAccount
                }
                showCreateAccountDialog = false
            }
        )
    }

    if (showCreateCategoryDialog) {
        CreateCategoryDialog(
            onDismiss = { showCreateCategoryDialog = false },
            onConfirm = { name, iconKey, colorKey ->
                viewModel.createCategory(name, iconKey, colorKey) { newCategory ->
                    selectedCategory = newCategory
                }
                showCreateCategoryDialog = false
            }
        )
    }
    // endregion
}

// region New UI Components for Composer
@Composable
private fun SpotlightBackground(color: Color) {
    val animatedAlpha by animateFloatAsState(
        targetValue = if (color == Color.Transparent) 0f else 0.3f,
        animationSpec = tween(500),
        label = "SpotlightAlpha"
    )

    Canvas(modifier = Modifier.fillMaxSize()) {
        drawIntoCanvas {
            val paint = Paint().asFrameworkPaint()
            val radius = size.width * 1.2f
            paint.color = android.graphics.Color.TRANSPARENT
            paint.setShadowLayer(
                radius,
                0f,
                0f,
                color
                    .copy(alpha = animatedAlpha)
                    .toArgb()
            )
            it.nativeCanvas.drawCircle(center.x, center.y, radius / 2, paint)
        }
    }
}

@Composable
private fun AmountComposer(
    amount: String,
    description: String,
    onDescriptionClick: () -> Unit
) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.clickable(onClick = onDescriptionClick)
    ) {
        Text(
            text = description.ifBlank { "Paid to..." },
            style = MaterialTheme.typography.titleLarge,
            color = MaterialTheme.colorScheme.onSurface,
            maxLines = 1,
            overflow = TextOverflow.Ellipsis
        )
        Spacer(Modifier.height(8.dp))
        Row(verticalAlignment = Alignment.CenterVertically) {
            Text(
                text = "",
                style = MaterialTheme.typography.headlineLarge,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                modifier = Modifier.align(Alignment.Top)
            )
            Text(
                text = if (amount.isEmpty()) "0" else amount,
                style = MaterialTheme.typography.displayLarge,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.onSurface,
                maxLines = 1
            )
        }
    }
}

@Composable
private fun OrbitalChips(
    selectedCategory: Category?,
    selectedAccount: Account?,
    selectedDateTime: Date,
    onCategoryClick: () -> Unit,
    onAccountClick: () -> Unit,
    onDateClick: () -> Unit
) {
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.spacedBy(12.dp, Alignment.CenterHorizontally),
        verticalAlignment = Alignment.CenterVertically
    ) {
        DetailChip(
            icon = selectedCategory?.let { CategoryIconHelper.getIcon(it.iconKey) } ?: Icons.Default.Category,
            text = selectedCategory?.name ?: "Category",
            onClick = onCategoryClick
        )
        DetailChip(
            icon = Icons.Default.AccountBalanceWallet,
            text = selectedAccount?.name ?: "Account",
            onClick = onAccountClick
        )
        DetailChip(
            icon = Icons.Default.CalendarToday,
            text = SimpleDateFormat("dd MMM", Locale.getDefault()).format(selectedDateTime),
            onClick = onDateClick
        )
    }
}

@Composable
private fun DetailChip(icon: ImageVector, text: String, onClick: () -> Unit) {
    GlassPanel(
        modifier = Modifier.clickable(onClick = onClick)
    ) {
        Row(
            modifier = Modifier.padding(horizontal = 16.dp, vertical = 10.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Icon(
                imageVector = icon,
                contentDescription = text,
                modifier = Modifier.size(20.dp),
                tint = MaterialTheme.colorScheme.onSurface
            )
            Text(
                text = text,
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurface,
                maxLines = 1,
                overflow = TextOverflow.Ellipsis
            )
        }
    }
}

@Composable
private fun ActionRow(
    notes: String,
    tags: Set<Tag>,
    imageCount: Int,
    onNotesClick: () -> Unit,
    onTagsClick: () -> Unit,
    onAttachmentClick: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 16.dp),
        horizontalArrangement = Arrangement.spacedBy(24.dp, Alignment.CenterHorizontally)
    ) {
        ActionIcon(
            icon = Icons.AutoMirrored.Filled.Notes,
            text = "Notes",
            isHighlighted = notes.isNotBlank(),
            onClick = onNotesClick
        )
        ActionIcon(
            icon = Icons.Default.NewLabel,
            text = "Tags",
            isHighlighted = tags.isNotEmpty(),
            onClick = onTagsClick
        )
        ActionIcon(
            icon = Icons.Default.Attachment,
            text = "Attach",
            isHighlighted = imageCount > 0,
            badgeCount = imageCount,
            onClick = onAttachmentClick
        )
    }
}

@Composable
private fun ActionIcon(
    icon: ImageVector,
    text: String,
    isHighlighted: Boolean,
    onClick: () -> Unit,
    badgeCount: Int = 0
) {
    val color = if (isHighlighted) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurfaceVariant
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.clickable(onClick = onClick)
    ) {
        BadgedBox(badge = {
            if (badgeCount > 0) {
                Badge(
                    containerColor = MaterialTheme.colorScheme.primary,
                    contentColor = MaterialTheme.colorScheme.onPrimary
                ) { Text("$badgeCount") }
            }
        }) {
            Icon(
                imageVector = icon,
                contentDescription = text,
                tint = color,
                modifier = Modifier.size(28.dp)
            )
        }
        Spacer(Modifier.height(4.dp))
        Text(text, style = MaterialTheme.typography.bodySmall, color = color)
    }
}

@Composable
private fun GlassmorphicNumpad(
    onDigitClick: (String) -> Unit,
    onBackspaceClick: () -> Unit,
    onConfirm: () -> Unit,
    isConfirmEnabled: Boolean
) {
    val buttons = listOf(
        "1", "2", "3",
        "4", "5", "6",
        "7", "8", "9",
        ".", "0"
    )

    GlassPanel(
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp)
    ) {
        Column(
            modifier = Modifier.padding(8.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            buttons.chunked(3).forEach { row ->
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(4.dp)
                ) {
                    row.forEach { digit ->
                        NumpadButton(text = digit, modifier = Modifier.weight(1f)) {
                            onDigitClick(digit)
                        }
                    }
                }
            }
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                NumpadButton(icon = Icons.AutoMirrored.Filled.Backspace, modifier = Modifier.weight(1f)) {
                    onBackspaceClick()
                }
                Button(
                    onClick = onConfirm,
                    enabled = isConfirmEnabled,
                    modifier = Modifier
                        .weight(2f)
                        .height(64.dp),
                    shape = RoundedCornerShape(16.dp),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.primary,
                        contentColor = MaterialTheme.colorScheme.onPrimary
                    )
                ) {
                    Icon(Icons.Default.Check, contentDescription = "Confirm", modifier = Modifier.size(32.dp))
                }
            }
        }
    }
}

@Composable
private fun NumpadButton(
    modifier: Modifier = Modifier,
    text: String? = null,
    icon: ImageVector? = null,
    onClick: () -> Unit
) {
    val interactionSource = remember { MutableInteractionSource() }
    val isPressed by interactionSource.collectIsPressedAsState()
    val backgroundColor = if (isPressed) AuroraNumpadHighlight else Color.Transparent

    Surface(
        onClick = onClick,
        modifier = modifier.height(64.dp),
        shape = RoundedCornerShape(16.dp),
        color = backgroundColor,
        interactionSource = interactionSource
    ) {
        Box(contentAlignment = Alignment.Center) {
            if (text != null) {
                Text(
                    text = text,
                    style = MaterialTheme.typography.headlineLarge,
                    color = MaterialTheme.colorScheme.onSurface
                )
            }
            if (icon != null) {
                Icon(
                    imageVector = icon,
                    contentDescription = null,
                    modifier = Modifier.size(32.dp),
                    tint = MaterialTheme.colorScheme.onSurface
                )
            }
        }
    }
}

@Composable
private fun <T> PickerSheet(
    title: String,
    items: List<T>,
    onItemSelected: (T) -> Unit,
    onAddNew: (() -> Unit)? = null,
    itemContent: @Composable (T) -> Unit
) {
    Column(modifier = Modifier.navigationBarsPadding()) {
        Text(
            title,
            style = MaterialTheme.typography.titleLarge,
            modifier = Modifier.padding(16.dp),
            color = MaterialTheme.colorScheme.onSurface
        )
        LazyVerticalGrid(
            columns = GridCells.Adaptive(minSize = 100.dp),
            contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp),
            horizontalArrangement = Arrangement.spacedBy(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            items(items) { item ->
                Column(
                    modifier = Modifier
                        .clip(RoundedCornerShape(12.dp))
                        .clickable { onItemSelected(item) }
                        .padding(vertical = 12.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    itemContent(item)
                }
            }
            if (onAddNew != null) {
                item {
                    Column(
                        modifier = Modifier
                            .clip(RoundedCornerShape(12.dp))
                            .clickable(onClick = onAddNew)
                            .padding(vertical = 12.dp)
                            .height(76.dp),
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.Center
                    ) {
                        Icon(
                            Icons.Default.AddCircleOutline,
                            contentDescription = "Create New",
                            modifier = Modifier.size(48.dp),
                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Text(
                            "New",
                            style = MaterialTheme.typography.bodyMedium,
                            textAlign = TextAlign.Center,
                            color = MaterialTheme.colorScheme.onSurface
                        )
                    }
                }
            }
        }
        Spacer(Modifier.height(16.dp))
    }
}

@Composable
private fun CategoryPickerItem(category: Category) {
    Box(
        modifier = Modifier
            .size(48.dp)
            .clip(CircleShape)
            .background(CategoryIconHelper.getIconBackgroundColor(category.colorKey)),
        contentAlignment = Alignment.Center
    ) {
        if (category.iconKey == "letter_default") {
            Text(
                text = category.name.firstOrNull()?.uppercase() ?: "?",
                fontWeight = FontWeight.Bold,
                color = Color.Black,
                fontSize = 22.sp
            )
        } else {
            Icon(
                imageVector = CategoryIconHelper.getIcon(category.iconKey),
                contentDescription = null,
                tint = Color.Black,
                modifier = Modifier.padding(12.dp)
            )
        }
    }
    Text(
        category.name,
        style = MaterialTheme.typography.bodyMedium,
        textAlign = TextAlign.Center,
        maxLines = 1,
        overflow = TextOverflow.Ellipsis,
        color = MaterialTheme.colorScheme.onSurface
    )
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
private fun TagPickerSheet(
    allTags: List<Tag>,
    selectedTags: Set<Tag>,
    onTagSelected: (Tag) -> Unit,
    onAddNewTag: (String) -> Unit,
    onConfirm: () -> Unit
) {
    var newTagName by remember { mutableStateOf("") }

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
            .navigationBarsPadding(),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("Manage Tags", style = MaterialTheme.typography.titleLarge, color = MaterialTheme.colorScheme.onSurface)
        FlowRow(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(8.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            allTags.forEach { tag ->
                FilterChip(
                    selected = tag in selectedTags,
                    onClick = { onTagSelected(tag) },
                    label = { Text(tag.name) }
                )
            }
        }
        HorizontalDivider(color = GlassPanelBorder)
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            OutlinedTextField(
                value = newTagName,
                onValueChange = { newTagName = it },
                label = { Text("New Tag Name") },
                modifier = Modifier.weight(1f)
            )
            IconButton(
                onClick = {
                    onAddNewTag(newTagName)
                    newTagName = ""
                },
                enabled = newTagName.isNotBlank()
            ) {
                Icon(Icons.Default.Add, contentDescription = "Add New Tag")
            }
        }
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.End
        ) {
            Button(onClick = {
                if (newTagName.isNotBlank()) {
                    onAddNewTag(newTagName)
                }
                onConfirm()
            }) { Text("Done") }
        }
    }
}

@Composable
fun TextInputSheet(
    title: String,
    initialValue: String,
    onConfirm: (String) -> Unit
) {
    var text by remember { mutableStateOf(initialValue) }
    val focusRequester = remember { FocusRequester() }

    LaunchedEffect(Unit) {
        focusRequester.requestFocus()
    }

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
            .navigationBarsPadding(),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text(title, style = MaterialTheme.typography.titleLarge, color = MaterialTheme.colorScheme.onSurface)
        OutlinedTextField(
            value = text,
            onValueChange = { text = it },
            label = { Text("Value") },
            keyboardOptions = KeyboardOptions(capitalization = KeyboardCapitalization.Sentences),
            modifier = Modifier
                .fillMaxWidth()
                .focusRequester(focusRequester)
        )
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.End,
            verticalAlignment = Alignment.CenterVertically
        ) {
            TextButton(onClick = { onConfirm(initialValue) }) { Text("Cancel") } // Revert on cancel
            Spacer(modifier = Modifier.width(8.dp))
            Button(onClick = { onConfirm(text) }) { Text("Done") }
        }
    }
}

@Composable
private fun TransactionTypeToggle(
    selectedType: String,
    onTypeSelected: (String) -> Unit
) {
    val glassFillColor = if (isSystemInDarkTheme()) {
        Color.White.copy(alpha = 0.08f)
    } else {
        Color.Black.copy(alpha = 0.04f)
    }

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clip(CircleShape)
            .background(glassFillColor)
            .border(1.dp, GlassPanelBorder, CircleShape)
            .padding(4.dp),
        horizontalArrangement = Arrangement.Center,
        verticalAlignment = Alignment.CenterVertically
    ) {
        val expenseSelected = selectedType == "expense"
        val incomeSelected = selectedType == "income"

        Button(
            onClick = { onTypeSelected("expense") },
            modifier = Modifier
                .weight(1f)
                .height(48.dp),
            shape = CircleShape,
            colors = ButtonDefaults.buttonColors(
                containerColor = if (expenseSelected) MaterialTheme.colorScheme.primary else Color.Transparent,
                contentColor = if (expenseSelected) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurface
            ),
            elevation = null
        ) {
            Text("Expense", fontWeight = FontWeight.Bold)
        }

        Button(
            onClick = { onTypeSelected("income") },
            modifier = Modifier
                .weight(1f)
                .height(48.dp),
            shape = CircleShape,
            colors = ButtonDefaults.buttonColors(
                containerColor = if (incomeSelected) MaterialTheme.colorScheme.primary else Color.Transparent,
                contentColor = if (incomeSelected) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurface
            ),
            elevation = null
        ) {
            Text("Income", fontWeight = FontWeight.Bold)
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/AddEditAccountScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/AddEditAccountScreen.kt
// REASON: NEW FILE - This file combines the logic for both adding and editing
// an account into a single, unified screen. It has been completely redesigned
// to align with the "Project Aurora" vision, using GlassPanel components for
// all form elements and ensuring high-contrast, theme-aware text and colors.
// BUG FIX - The AlertDialog now correctly derives its background color from
// the app's MaterialTheme, ensuring it matches the selected theme (e.g.,
// Aurora) instead of defaulting to the system's light/dark mode.
// =================================================================================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import io.pm.finlight.AccountViewModel
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight

// Helper function to determine if a color is 'dark' based on luminance.
private fun Color.isDark() = (red * 0.299 + green * 0.587 + blue * 0.114) < 0.5

@Composable
fun AddEditAccountScreen(
    navController: NavController,
    viewModel: AccountViewModel,
    accountId: Int?,
) {
    val isEditMode = accountId != null
    val titleText = if (isEditMode) "Edit Account" else "Add New Account"

    var accountName by remember { mutableStateOf("") }
    var accountType by remember { mutableStateOf("") }
    var showDeleteDialog by remember { mutableStateOf(false) }

    val accountToEdit by if (isEditMode) {
        viewModel.getAccountById(accountId!!).collectAsState(initial = null)
    } else {
        remember { mutableStateOf(null) }
    }

    LaunchedEffect(accountToEdit) {
        accountToEdit?.let {
            accountName = it.name
            accountType = it.type
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp),
    ) {
        Text(
            text = titleText,
            style = MaterialTheme.typography.headlineSmall,
            color = MaterialTheme.colorScheme.onSurface
        )

        GlassPanel {
            Column(
                modifier = Modifier.padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                OutlinedTextField(
                    value = accountName,
                    onValueChange = { accountName = it },
                    label = { Text("Account Name (e.g., Savings, Credit Card)") },
                    modifier = Modifier.fillMaxWidth(),
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = MaterialTheme.colorScheme.primary,
                        unfocusedBorderColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f),
                        focusedLabelColor = MaterialTheme.colorScheme.primary,
                        unfocusedLabelColor = MaterialTheme.colorScheme.onSurfaceVariant,
                        cursorColor = MaterialTheme.colorScheme.primary,
                        focusedTextColor = MaterialTheme.colorScheme.onSurface,
                        unfocusedTextColor = MaterialTheme.colorScheme.onSurface,
                        focusedContainerColor = Color.Transparent,
                        unfocusedContainerColor = Color.Transparent,
                    )
                )
                OutlinedTextField(
                    value = accountType,
                    onValueChange = { accountType = it },
                    label = { Text("Account Type (e.g., Bank, Wallet)") },
                    modifier = Modifier.fillMaxWidth(),
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = MaterialTheme.colorScheme.primary,
                        unfocusedBorderColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f),
                        focusedLabelColor = MaterialTheme.colorScheme.primary,
                        unfocusedLabelColor = MaterialTheme.colorScheme.onSurfaceVariant,
                        cursorColor = MaterialTheme.colorScheme.primary,
                        focusedTextColor = MaterialTheme.colorScheme.onSurface,
                        unfocusedTextColor = MaterialTheme.colorScheme.onSurface,
                        focusedContainerColor = Color.Transparent,
                        unfocusedContainerColor = Color.Transparent,
                    )
                )
            }
        }
        Spacer(modifier = Modifier.weight(1f))

        if (isEditMode) {
            Button(
                onClick = { showDeleteDialog = true },
                colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error),
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("Delete Account")
            }
        }

        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(16.dp),
        ) {
            OutlinedButton(onClick = { navController.popBackStack() }, modifier = Modifier.weight(1f)) {
                Text("Cancel")
            }
            Button(
                onClick = {
                    if (isEditMode) {
                        accountToEdit?.let {
                            viewModel.updateAccount(it.copy(name = accountName, type = accountType))
                        }
                    } else {
                        viewModel.addAccount(accountName, accountType)
                    }
                    navController.popBackStack()
                },
                modifier = Modifier.weight(1f),
                enabled = accountName.isNotBlank() && accountType.isNotBlank(),
            ) {
                Text(if (isEditMode) "Update" else "Save")
            }
        }
    }

    if (showDeleteDialog && accountToEdit != null) {
        val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
        val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

        AlertDialog(
            onDismissRequest = { showDeleteDialog = false },
            title = { Text("Confirm Deletion") },
            text = { Text("Are you sure you want to delete this account? This will also delete all associated transactions.") },
            confirmButton = {
                Button(
                    onClick = {
                        viewModel.deleteAccount(accountToEdit!!)
                        showDeleteDialog = false
                        navController.popBackStack()
                    },
                    colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
                ) { Text("Delete") }
            },
            dismissButton = {
                TextButton(onClick = { showDeleteDialog = false }) { Text("Cancel") }
            },
            containerColor = popupContainerColor
        )
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/AccountListScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/AccountListScreen.kt
// REASON: UX REFINEMENT - The screen now includes a Scaffold with a SnackbarHost
// and a LaunchedEffect to collect UI events from the AccountViewModel. This
// ensures that feedback, such as the "Account already exists" message, is
// displayed to the user instead of failing silently.
// =================================================================================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import io.pm.finlight.AccountViewModel
import io.pm.finlight.AccountWithBalance
import io.pm.finlight.BankLogoHelper
import io.pm.finlight.ui.components.GlassPanel
import java.text.NumberFormat
import java.util.*

@OptIn(ExperimentalFoundationApi::class, ExperimentalMaterial3Api::class)
@Composable
fun AccountListScreen(
    navController: NavController,
    viewModel: AccountViewModel,
) {
    val accounts by viewModel.accountsWithBalance.collectAsState(initial = emptyList())
    val snackbarHostState = remember { SnackbarHostState() }

    // --- NEW: Collect UI events from the ViewModel to show snackbars ---
    LaunchedEffect(key1 = viewModel.uiEvent) {
        viewModel.uiEvent.collect { message ->
            snackbarHostState.showSnackbar(message)
        }
    }

    // --- NEW: Added Scaffold to host the Snackbar ---
    Scaffold(
        snackbarHost = { SnackbarHost(snackbarHostState) },
        containerColor = Color.Transparent
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier.padding(innerPadding),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            items(accounts, key = { it.account.id }) { accountWithBalance ->
                AccountListItem(
                    modifier = Modifier.animateItemPlacement(),
                    accountWithBalance = accountWithBalance,
                    onClick = { navController.navigate("account_detail/${accountWithBalance.account.id}") },
                    onEditClick = { navController.navigate("edit_account/${accountWithBalance.account.id}") }
                )
            }
        }
    }
}

@Composable
private fun AccountListItem(
    modifier: Modifier = Modifier,
    accountWithBalance: AccountWithBalance,
    onClick: () -> Unit,
    onEditClick: () -> Unit
) {
    val currencyFormat = remember { NumberFormat.getCurrencyInstance(Locale("en", "IN")) }

    GlassPanel(
        modifier = modifier
            .fillMaxWidth()
            .clickable(onClick = onClick)
    ) {
        Row(
            modifier = Modifier.padding(horizontal = 24.dp, vertical = 16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Image(
                painter = painterResource(id = BankLogoHelper.getLogoForAccount(accountWithBalance.account.name)),
                contentDescription = "${accountWithBalance.account.name} Logo",
                modifier = Modifier.size(40.dp)
            )

            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = accountWithBalance.account.name,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onSurface
                )
                Text(
                    text = "Balance: ${currencyFormat.format(accountWithBalance.balance)}",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }

            IconButton(onClick = onEditClick) {
                Icon(
                    Icons.Default.Edit,
                    contentDescription = "Edit Account",
                    tint = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/BudgetScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/BudgetScreen.kt
// REASON: MAJOR REFACTOR - The entire screen has been redesigned to align with
// the "Project Aurora" vision. Standard cards and progress bars have been
// replaced with custom GlassPanel components and more artistic, animated data
// visualizations. The layout is now more dynamic and visually engaging,
// transforming it into a "Budget Hub" while preserving all original
// functionality and ensuring high-contrast legibility.
// FIX: Corrected a @Composable invocation error by reading the theme color
// outside the Canvas draw scope.
// BUG FIX - The AlertDialogs now correctly derive their background color from
// the app's MaterialTheme, ensuring they match the selected theme (e.g.,
// Aurora) instead of defaulting to the system's light/dark mode.
// =================================================================================
package io.pm.finlight.ui.screens

import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.tween
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import io.pm.finlight.Budget
import io.pm.finlight.BudgetViewModel
import io.pm.finlight.BudgetWithSpending
import io.pm.finlight.CategoryIconHelper
import io.pm.finlight.ui.components.GlassPanel
//import io.pm.finlight.ui.theme.AuroraPrimary
//import io.pm.finlight.ui.theme.AuroraSecondary
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight
import java.text.NumberFormat
import java.util.*
import kotlin.math.min

// Helper function to determine if a color is 'dark' based on luminance.
private fun Color.isDark() = (red * 0.299 + green * 0.587 + blue * 0.114) < 0.5

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun BudgetScreen(
    navController: NavController,
    viewModel: BudgetViewModel = viewModel(),
) {
    val categoryBudgets by viewModel.budgetsForCurrentMonth.collectAsState()
    val overallBudget by viewModel.overallBudget.collectAsState()
    val totalSpending by viewModel.totalSpending.collectAsState()
    var showDeleteDialog by remember { mutableStateOf(false) }
    var budgetToDelete by remember { mutableStateOf<Budget?>(null) }
    var showOverallBudgetDialog by remember { mutableStateOf(false) }

    val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
    val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        item {
            OverallBudgetHub(
                totalBudget = overallBudget,
                totalSpent = totalSpending,
                onEditClick = { showOverallBudgetDialog = true }
            )
        }

        item {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    "Category Budgets",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
                IconButton(onClick = { navController.navigate("add_budget") }) {
                    Icon(
                        Icons.Default.Add,
                        contentDescription = "Add Category Budget",
                        tint = MaterialTheme.colorScheme.primary
                    )
                }
            }
        }

        if (categoryBudgets.isEmpty()) {
            item {
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 48.dp),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        "No category budgets set. Tap the '+' icon to add one.",
                        color = MaterialTheme.colorScheme.onSurfaceVariant,
                        textAlign = TextAlign.Center
                    )
                }
            }
        } else {
            items(categoryBudgets, key = { it.budget.id }) { budgetWithSpending ->
                CategoryBudgetItem(
                    budgetWithSpending = budgetWithSpending,
                    onEdit = { navController.navigate("edit_budget/${budgetWithSpending.budget.id}") },
                    onDelete = {
                        budgetToDelete = budgetWithSpending.budget
                        showDeleteDialog = true
                    }
                )
            }
        }
    }

    if (showDeleteDialog && budgetToDelete != null) {
        AlertDialog(
            onDismissRequest = { showDeleteDialog = false },
            title = { Text("Delete Budget?") },
            text = { Text("Are you sure you want to delete the budget for '${budgetToDelete?.categoryName}'?") },
            confirmButton = {
                Button(
                    onClick = {
                        budgetToDelete?.let { viewModel.deleteBudget(it) }
                        showDeleteDialog = false
                    },
                    colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
                ) { Text("Delete") }
            },
            dismissButton = { TextButton(onClick = { showDeleteDialog = false }) { Text("Cancel") } },
            containerColor = popupContainerColor
        )
    }

    if (showOverallBudgetDialog) {
        EditOverallBudgetDialog(
            currentBudget = overallBudget,
            onDismiss = { showOverallBudgetDialog = false },
            onConfirm = { newAmount ->
                viewModel.saveOverallBudget(newAmount)
                showOverallBudgetDialog = false
            }
        )
    }
}

@Composable
private fun OverallBudgetHub(
    totalBudget: Float,
    totalSpent: Double,
    onEditClick: () -> Unit
) {
    val progress = if (totalBudget > 0) (totalSpent.toFloat() / totalBudget) else 0f
    val remaining = totalBudget - totalSpent
    val animatedProgress by animateFloatAsState(
        targetValue = progress.coerceIn(0f, 1f),
        animationSpec = tween(durationMillis = 1500), label = "OverallBudgetProgress"
    )

    GlassPanel(modifier = Modifier.clickable(onClick = onEditClick)) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Text(
                "Overall Monthly Budget",
                style = MaterialTheme.typography.titleLarge,
                color = MaterialTheme.colorScheme.onSurface
            )

            Box(contentAlignment = Alignment.Center, modifier = Modifier.size(180.dp)) {
                OverallBudgetGauge(progress = animatedProgress)
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    Text(
                        "Remaining",
                        style = MaterialTheme.typography.bodyLarge,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Text(
                        "${NumberFormat.getCurrencyInstance(Locale("en", "IN")).format(remaining).drop(1)}",
                        style = MaterialTheme.typography.headlineMedium,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.onSurface
                    )
                }
            }

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    "Spent: ${NumberFormat.getCurrencyInstance(Locale("en", "IN")).format(totalSpent).drop(1)}",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
                Text(
                    "Budget: ${NumberFormat.getCurrencyInstance(Locale("en", "IN")).format(totalBudget).drop(1)}",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

@Composable
private fun OverallBudgetGauge(progress: Float) {
    val progressBrush = Brush.sweepGradient(
        colors = listOf(
            MaterialTheme.colorScheme.primary,
            MaterialTheme.colorScheme.secondary,
            MaterialTheme.colorScheme.primary
        )
    )
    // --- FIX: Read color from theme outside the Canvas scope ---
    val trackColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f)

    Canvas(modifier = Modifier.fillMaxSize()) {
        val strokeWidth = 12.dp.toPx()
        val diameter = min(size.width, size.height) - strokeWidth
        val radius = diameter / 2
        val center = Offset(size.width / 2, size.height / 2)

        drawCircle(
            color = trackColor, // Use the variable here
            style = Stroke(width = strokeWidth),
            radius = radius,
            center = center
        )

        drawArc(
            brush = progressBrush,
            startAngle = -90f,
            sweepAngle = 360 * progress,
            useCenter = false,
            style = Stroke(width = strokeWidth, cap = StrokeCap.Round),
            size = Size(diameter, diameter),
            topLeft = Offset(center.x - radius, center.y - radius)
        )
    }
}

@Composable
private fun CategoryBudgetItem(
    budgetWithSpending: BudgetWithSpending,
    onEdit: () -> Unit,
    onDelete: () -> Unit
) {
    val progress = if (budgetWithSpending.budget.amount > 0) (budgetWithSpending.spent / budgetWithSpending.budget.amount).toFloat() else 0f
    val animatedProgress by animateFloatAsState(
        targetValue = progress.coerceIn(0f, 1f),
        animationSpec = tween(1000),
        label = "CategoryProgress"
    )
    val progressColor = when {
        progress > 1f -> MaterialTheme.colorScheme.error
        progress > 0.8f -> MaterialTheme.colorScheme.secondary
        else -> MaterialTheme.colorScheme.primary
    }

    GlassPanel {
        Column(modifier = Modifier.padding(horizontal = 16.dp, vertical = 12.dp)) {
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                Box(
                    modifier = Modifier
                        .size(40.dp)
                        .clip(CircleShape)
                        .background(
                            CategoryIconHelper.getIconBackgroundColor(
                                budgetWithSpending.colorKey ?: "gray_light"
                            )
                        ),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(
                        imageVector = CategoryIconHelper.getIcon(budgetWithSpending.iconKey ?: "category"),
                        contentDescription = budgetWithSpending.budget.categoryName,
                        tint = Color.Black,
                        modifier = Modifier.size(22.dp)
                    )
                }
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        budgetWithSpending.budget.categoryName,
                        style = MaterialTheme.typography.titleMedium,
                        color = MaterialTheme.colorScheme.onSurface
                    )
                    Text(
                        "${NumberFormat.getCurrencyInstance(Locale("en", "IN")).format(budgetWithSpending.spent).drop(1)} of ${NumberFormat.getCurrencyInstance(Locale("en", "IN")).format(budgetWithSpending.budget.amount).drop(1)}",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
                Row {
                    IconButton(onClick = onEdit) {
                        Icon(Icons.Default.Edit, contentDescription = "Edit Budget", tint = MaterialTheme.colorScheme.onSurfaceVariant)
                    }
                    IconButton(onClick = onDelete) {
                        Icon(Icons.Default.Delete, contentDescription = "Delete Budget", tint = MaterialTheme.colorScheme.error)
                    }
                }
            }
            Spacer(modifier = Modifier.height(8.dp))
            LinearProgressIndicator(
                progress = { animatedProgress },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(8.dp)
                    .clip(CircleShape),
                color = progressColor,
                trackColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f),
                strokeCap = StrokeCap.Round
            )
        }
    }
}

@Composable
fun EditOverallBudgetDialog(
    currentBudget: Float,
    onDismiss: () -> Unit,
    onConfirm: (String) -> Unit
) {
    var budgetInput by remember { mutableStateOf(if (currentBudget > 0) "%.0f".format(currentBudget) else "") }
    val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
    val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Set Overall Budget") },
        text = {
            OutlinedTextField(
                value = budgetInput,
                onValueChange = { budgetInput = it.filter { char -> char.isDigit() } },
                label = { Text("Total Monthly Budget Amount") },
                leadingIcon = { Text("") },
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                singleLine = true
            )
        },
        confirmButton = {
            Button(
                onClick = { onConfirm(budgetInput) },
                enabled = budgetInput.isNotBlank()
            ) { Text("Save") }
        },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
        containerColor = popupContainerColor
    )
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/RuleCreationScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/RuleCreationScreen.kt
// REASON: MAJOR REFACTOR - The screen has been fully redesigned to align with the
// "Project Aurora" vision. All standard Card components have been replaced
// with GlassPanels. Buttons and text fields have been restyled for a cohesive,
// modern look, and all text colors are now theme-aware to ensure high contrast
// and legibility.
// =================================================================================
package io.pm.finlight.ui.screens

import android.app.Application
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.BasicTextField
import androidx.compose.foundation.text.selection.LocalTextSelectionColors
import androidx.compose.foundation.text.selection.TextSelectionColors
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.TextFieldValue
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.google.gson.Gson
import io.pm.finlight.*
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight
import kotlinx.coroutines.flow.firstOrNull
import kotlinx.coroutines.launch
import kotlin.math.max
import kotlin.math.min

class RuleCreationViewModelFactory(private val application: Application) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(RuleCreationViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return RuleCreationViewModel(application) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun RuleCreationScreen(
    navController: NavController,
    potentialTransactionJson: String?,
    ruleId: Int?
) {
    val context = LocalContext.current.applicationContext as Application
    val viewModel: RuleCreationViewModel = viewModel(factory = RuleCreationViewModelFactory(context))

    val uiState by viewModel.uiState.collectAsState()
    var textFieldValue by remember { mutableStateOf(TextFieldValue("")) }
    val scope = rememberCoroutineScope()
    val isEditMode = ruleId != null

    LaunchedEffect(key1 = ruleId, key2 = potentialTransactionJson) {
        if (isEditMode) {
            viewModel.loadRuleForEditing(ruleId!!)
            val rule = AppDatabase.getInstance(context).customSmsRuleDao().getRuleById(ruleId).firstOrNull()
            if (rule != null) {
                textFieldValue = TextFieldValue(rule.sourceSmsBody)
            }
        } else if (potentialTransactionJson != null) {
            val potentialTxn = Gson().fromJson(potentialTransactionJson, PotentialTransaction::class.java)
            viewModel.initializeStateForCreation(potentialTxn)
            textFieldValue = TextFieldValue(potentialTxn.originalMessage)
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(if (isEditMode) "Edit Parsing Rule" else "Create Parsing Rule") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent)
            )
        },
        containerColor = Color.Transparent
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .padding(innerPadding)
                .padding(16.dp)
                .fillMaxSize()
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            GlassPanel {
                Row(
                    modifier = Modifier.padding(16.dp),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    Icon(
                        Icons.Default.Info,
                        contentDescription = "Info",
                        tint = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Text(
                        text = "Long-press text to select it, then tap a 'Mark as...' button below.",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }

            GlassPanel(modifier = Modifier.fillMaxWidth()) {
                Column(modifier = Modifier.padding(16.dp)) {
                    Text(
                        "Full SMS Message",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.onSurface
                    )
                    Spacer(Modifier.height(12.dp))
                    val customTextSelectionColors = TextSelectionColors(
                        handleColor = MaterialTheme.colorScheme.primary,
                        backgroundColor = MaterialTheme.colorScheme.primary.copy(alpha = 0.4f)
                    )
                    CompositionLocalProvider(LocalTextSelectionColors provides customTextSelectionColors) {
                        BasicTextField(
                            value = textFieldValue,
                            onValueChange = { textFieldValue = it },
                            readOnly = true,
                            textStyle = TextStyle(
                                fontFamily = FontFamily.Monospace,
                                color = MaterialTheme.colorScheme.onSurfaceVariant,
                                fontSize = 14.sp,
                                lineHeight = 20.sp
                            ),
                            cursorBrush = SolidColor(MaterialTheme.colorScheme.primary)
                        )
                    }
                }
            }

            val selection = textFieldValue.selection
            val isSelectionActive = !selection.collapsed

            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                Button(
                    onClick = {
                        val start = min(selection.start, selection.end)
                        val end = max(selection.start, selection.end)
                        val selectedText = textFieldValue.text.substring(start, end)
                        viewModel.onMarkAsTrigger(RuleSelection(selectedText, start, end))
                    },
                    enabled = isSelectionActive,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Mark as Trigger Phrase")
                }

                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(12.dp)) {
                    Button(
                        onClick = {
                            val start = min(selection.start, selection.end)
                            val end = max(selection.start, selection.end)
                            val selectedText = textFieldValue.text.substring(start, end)
                            viewModel.onMarkAsMerchant(RuleSelection(selectedText, start, end))
                        },
                        enabled = isSelectionActive,
                        modifier = Modifier.weight(1f),
                        colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.secondary)
                    ) {
                        Text("Mark as Merchant")
                    }
                    Button(
                        onClick = {
                            val start = min(selection.start, selection.end)
                            val end = max(selection.start, selection.end)
                            val selectedText = textFieldValue.text.substring(start, end)
                            viewModel.onMarkAsAmount(RuleSelection(selectedText, start, end))
                        },
                        enabled = isSelectionActive,
                        modifier = Modifier.weight(1f),
                        colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.secondary)
                    ) {
                        Text("Mark as Amount")
                    }
                }
                Button(
                    onClick = {
                        val start = min(selection.start, selection.end)
                        val end = max(selection.start, selection.end)
                        val selectedText = textFieldValue.text.substring(start, end)
                        viewModel.onMarkAsAccount(RuleSelection(selectedText, start, end))
                    },
                    enabled = isSelectionActive,
                    modifier = Modifier.fillMaxWidth(),
                    colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.secondary)
                ) {
                    Text("Mark as Account Info")
                }
            }


            GlassPanel(modifier = Modifier.fillMaxWidth()) {
                Column(modifier = Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(12.dp)) {
                    Text(
                        "Defined Rule",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.onSurface
                    )
                    HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                    RuleSummaryItem(
                        icon = Icons.Default.Flag,
                        label = "Trigger",
                        value = uiState.triggerSelection.selectedText.ifBlank { "Not set (Required)" },
                        isError = uiState.triggerSelection.selectedText.isBlank()
                    )
                    RuleSummaryItem(
                        icon = Icons.Default.Store,
                        label = "Merchant",
                        value = uiState.merchantSelection.selectedText.ifBlank { "Not set" }
                    )
                    RuleSummaryItem(
                        icon = Icons.Default.Paid,
                        label = "Amount",
                        value = uiState.amountSelection.selectedText.ifBlank { "Not set" }
                    )
                    RuleSummaryItem(
                        icon = Icons.Default.AccountBalanceWallet,
                        label = "Account",
                        value = uiState.accountSelection.selectedText.ifBlank { "Not set" }
                    )
                }
            }

            Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(16.dp)) {
                OutlinedButton(onClick = { navController.popBackStack() }, modifier = Modifier.weight(1f)) {
                    Text("Cancel")
                }
                val isSaveEnabled = uiState.triggerSelection.selectedText.isNotBlank() &&
                        (uiState.merchantSelection.selectedText.isNotBlank() || uiState.amountSelection.selectedText.isNotBlank() || uiState.accountSelection.selectedText.isNotBlank())

                Button(
                    onClick = {
                        scope.launch {
                            viewModel.saveRule(textFieldValue.text) {
                                navController.previousBackStackEntry
                                    ?.savedStateHandle
                                    ?.set("reparse_needed", true)
                                navController.popBackStack()
                            }
                        }
                    },
                    enabled = isSaveEnabled,
                    modifier = Modifier.weight(1f)
                ) {
                    Text(if (isEditMode) "Update Rule" else "Save Rule")
                }
            }
        }
    }
}

@Composable
private fun RuleSummaryItem(
    icon: androidx.compose.ui.graphics.vector.ImageVector,
    label: String,
    value: String,
    isError: Boolean = false
) {
    Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(16.dp)) {
        Icon(
            imageVector = icon,
            contentDescription = label,
            tint = if (isError) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary
        )
        Column {
            Text(
                label,
                style = MaterialTheme.typography.labelLarge,
                color = MaterialTheme.colorScheme.onSurface
            )
            Text(
                value,
                style = MaterialTheme.typography.bodyMedium,
                color = if (isError) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.onSurfaceVariant,
                fontWeight = if (isError) FontWeight.Bold else FontWeight.Normal
            )
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/TransactionListScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/TransactionListScreen.kt
// REASON: REFACTOR - The local `Scaffold` and `TopAppBar` have been removed.
// The screen's header, title, and actions are now handled centrally by the
// `TopAppBar` in `MainActivity`, creating a more consistent UI and simplifying
// this screen's logic. The filter state is now collected from the ViewModel to
// drive the bottom sheet.
// FIX: Explicitly set text colors in the MonthlySummaryHeader and BudgetProgress
// composables to ensure proper contrast and legibility in dark mode.
// FIX: Corrected an invalid SimpleDateFormat pattern that was causing a runtime crash.
// UPDATE: Applied the semi-opaque popup surface color to the filter bottom
// sheet to match the style used in the Transaction Detail screen, ensuring
// a consistent UI for all popups.
// ANIMATION - Added `animateItemPlacement()` to the TransactionItem in the
// LazyColumn. This makes the list fluidly animate changes when items are
// added, removed, or reordered due to filtering, enhancing the app's snappy feel.
// ANIMATION - Optimized the AnimatedVisibility for the month scroller by removing
// the fade and using a faster tween spec, making it feel more responsive.
// =================================================================================
package io.pm.finlight.ui.screens

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.tween
import androidx.compose.animation.expandVertically
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.pager.HorizontalPager
import androidx.compose.foundation.pager.rememberPagerState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material.icons.filled.ArrowDropUp
import androidx.compose.material.icons.filled.FilterList
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import io.pm.finlight.MonthlySummaryItem
import io.pm.finlight.TransactionViewModel
import io.pm.finlight.ui.components.FilterBottomSheet
import io.pm.finlight.ui.components.TransactionList
import io.pm.finlight.ui.components.pagerTabIndicatorOffset
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalFoundationApi::class, ExperimentalMaterial3Api::class)
@Composable
fun TransactionListScreen(
    navController: NavController,
    viewModel: TransactionViewModel,
) {
    val tabs = listOf("Transactions", "Categories", "Merchants")
    val pagerState = rememberPagerState { tabs.size }
    val scope = rememberCoroutineScope()

    val transactions by viewModel.transactionsForSelectedMonth.collectAsState()
    val selectedMonth by viewModel.selectedMonth.collectAsState()
    val monthlySummaries by viewModel.monthlySummaries.collectAsState()
    val categorySpending by viewModel.categorySpendingForSelectedMonth.collectAsState()
    val merchantSpending by viewModel.merchantSpendingForSelectedMonth.collectAsState()
    val totalSpent by viewModel.monthlyExpenses.collectAsState()
    val totalIncome by viewModel.monthlyIncome.collectAsState()
    val budget by viewModel.overallMonthlyBudget.collectAsState()

    val filterState by viewModel.filterState.collectAsState()
    val allAccounts by viewModel.allAccounts.collectAsState()
    val allCategories by viewModel.allCategories.collectAsState(initial = emptyList())
    val showFilterSheet by viewModel.showFilterSheet.collectAsState()

    // --- REMOVED: Scaffold and TopAppBar are now handled in MainActivity ---
    Column(
        modifier = Modifier.fillMaxSize()
    ) {
        MonthlySummaryHeader(
            selectedMonth = selectedMonth,
            monthlySummaries = monthlySummaries,
            totalSpent = totalSpent,
            totalIncome = totalIncome,
            budget = budget,
            onMonthSelected = { viewModel.setSelectedMonth(it) }
        )
        TabRow(
            selectedTabIndex = pagerState.currentPage,
            indicator = { tabPositions ->
                TabRowDefaults.SecondaryIndicator(
                    Modifier.pagerTabIndicatorOffset(pagerState, tabPositions)
                )
            }
        ) {
            tabs.forEachIndexed { index, title ->
                Tab(
                    selected = pagerState.currentPage == index,
                    onClick = {
                        scope.launch {
                            pagerState.animateScrollToPage(index)
                        }
                    },
                    text = { Text(title) }
                )
            }
        }

        HorizontalPager(
            state = pagerState,
            modifier = Modifier.weight(1f)
        ) { page ->
            when (page) {
                0 -> TransactionList(transactions = transactions, navController = navController)
                1 -> CategorySpendingScreen(spendingList = categorySpending)
                2 -> MerchantSpendingScreen(merchantList = merchantSpending)
            }
        }
    }


    if (showFilterSheet) {
        // --- UPDATE: Added containerColor to match the Aurora design system for popups ---
        ModalBottomSheet(
            onDismissRequest = { viewModel.onFilterSheetDismiss() },
            containerColor = if (isSystemInDarkTheme()) PopupSurfaceDark else PopupSurfaceLight
        ) {
            FilterBottomSheet(
                filterState = filterState,
                accounts = allAccounts,
                categories = allCategories,
                onKeywordChange = viewModel::updateFilterKeyword,
                onAccountChange = viewModel::updateFilterAccount,
                onCategoryChange = viewModel::updateFilterCategory,
                onClearFilters = viewModel::clearFilters
            )
        }
    }
}

@Composable
fun MonthlySummaryHeader(
    selectedMonth: Calendar,
    monthlySummaries: List<MonthlySummaryItem>,
    totalSpent: Double,
    totalIncome: Double,
    budget: Float,
    onMonthSelected: (Calendar) -> Unit
) {
    val monthFormat = SimpleDateFormat("LLL", Locale.getDefault())
    // --- FIX: Corrected the invalid date format pattern from "LLLL einger" to "LLLL yyyy" ---
    val monthYearFormat = SimpleDateFormat("LLLL yyyy", Locale.getDefault())
    var showMonthScroller by remember { mutableStateOf(false) }

    val selectedTabIndex = monthlySummaries.indexOfFirst {
        it.calendar.get(Calendar.MONTH) == selectedMonth.get(Calendar.MONTH) &&
                it.calendar.get(Calendar.YEAR) == selectedMonth.get(Calendar.YEAR)
    }.coerceAtLeast(0)

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(bottom = 8.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clickable { showMonthScroller = !showMonthScroller }
                .padding(horizontal = 16.dp, vertical = 8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(
                    text = monthYearFormat.format(selectedMonth.time),
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold,
                    // --- FIX: Explicitly set color for dark mode contrast ---
                    color = MaterialTheme.colorScheme.onSurface
                )
                Icon(
                    imageVector = if (showMonthScroller) Icons.Default.ArrowDropUp else Icons.Default.ArrowDropDown,
                    contentDescription = if (showMonthScroller) "Hide month selector" else "Show month selector",
                    tint = MaterialTheme.colorScheme.onSurface
                )
            }
        }

        AnimatedVisibility(
            visible = showMonthScroller,
            enter = expandVertically(animationSpec = tween(200)),
            exit = shrinkVertically(animationSpec = tween(200))
        ) {
            ScrollableTabRow(
                selectedTabIndex = selectedTabIndex,
                edgePadding = 16.dp,
                indicator = {},
                divider = {}
            ) {
                monthlySummaries.forEach { summaryItem ->
                    val isSelected = summaryItem.calendar.get(Calendar.MONTH) == selectedMonth.get(Calendar.MONTH) &&
                            summaryItem.calendar.get(Calendar.YEAR) == selectedMonth.get(Calendar.YEAR)
                    Tab(
                        selected = isSelected,
                        onClick = {
                            onMonthSelected(summaryItem.calendar)
                            showMonthScroller = false
                        },
                        text = {
                            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                                Text(
                                    text = monthFormat.format(summaryItem.calendar.time),
                                    style = if (isSelected) MaterialTheme.typography.titleMedium else MaterialTheme.typography.titleSmall,
                                    fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal
                                )
                                Text(
                                    text = formatAmountInLakhs(summaryItem.totalSpent),
                                    style = MaterialTheme.typography.bodySmall,
                                    color = if (isSelected) MaterialTheme.colorScheme.onSurface else MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }
                        }
                    )
                }
            }
        }


        Spacer(Modifier.height(16.dp))

        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Column(modifier = Modifier.weight(1f)) {
                // --- FIX: Explicitly set color for dark mode contrast ---
                Text("Total Spent", style = MaterialTheme.typography.labelMedium, color = MaterialTheme.colorScheme.onSurfaceVariant)
                Text(
                    "${"%,.2f".format(totalSpent)}",
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.error
                )
            }
            Column(horizontalAlignment = Alignment.End) {
                // --- FIX: Explicitly set color for dark mode contrast ---
                Text("Total Income", style = MaterialTheme.typography.labelMedium, color = MaterialTheme.colorScheme.onSurfaceVariant)
                Text(
                    "${"%,.2f".format(totalIncome)}",
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.primary
                )
            }
        }

        Spacer(Modifier.height(12.dp))

        if (budget > 0) {
            BudgetProgress(
                spent = totalSpent.toFloat(),
                budget = budget,
                modifier = Modifier.padding(horizontal = 16.dp)
            )
        } else {
            Text(
                text = "No budget set for this month.",
                style = MaterialTheme.typography.bodyMedium,
                textAlign = TextAlign.Center,
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp)
            )
        }
    }
}

private fun formatAmountInLakhs(amount: Double): String {
    if (amount < 1000) return "${"%,.0f".format(amount)}"
    if (amount < 100000) return "${"%,.0f".format(amount / 1000)}K"
    return "${"%.2f".format(amount / 100000.0)}L"
}


@Composable
fun BudgetProgress(spent: Float, budget: Float, modifier: Modifier = Modifier) {
    val progress = (spent / budget).coerceIn(0f, 1f)
    val animatedProgress by animateFloatAsState(targetValue = progress, animationSpec = tween(1000), label = "")

    val progressColor = when {
        progress > 1f -> MaterialTheme.colorScheme.error
        progress > 0.8f -> Color(0xFFFBC02D) // Amber
        else -> MaterialTheme.colorScheme.primary
    }

    Column(modifier = modifier.fillMaxWidth()) {
        LinearProgressIndicator(
            progress = { animatedProgress },
            modifier = Modifier
                .fillMaxWidth()
                .height(12.dp)
                .clip(CircleShape),
            color = progressColor,
            trackColor = MaterialTheme.colorScheme.surfaceVariant,
            strokeCap = StrokeCap.Round
        )
        Spacer(modifier = Modifier.height(8.dp))
        Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
            Text(
                text = "Spent: ${"%,.0f".format(spent)}",
                style = MaterialTheme.typography.bodySmall,
                fontWeight = FontWeight.SemiBold,
                // --- FIX: Explicitly set color for dark mode contrast ---
                color = MaterialTheme.colorScheme.onSurface
            )
            Text(
                text = "Budget: ${"%,.0f".format(budget)}",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}


@Composable
fun PlaceholderTabContent(title: String) {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        contentAlignment = Alignment.Center
    ) {
        Text("Content for $title", style = MaterialTheme.typography.headlineMedium)
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/TransactionDetailScreen.kt ==================
package io.pm.finlight.ui.screens

import android.net.Uri
import android.util.Log
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.animation.core.EaseOutCubic
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.tween
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.automirrored.filled.Notes
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.livedata.observeAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.*
import androidx.compose.ui.graphics.drawscope.drawIntoCanvas
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardCapitalization
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import androidx.core.app.NotificationManagerCompat
import androidx.core.net.toUri
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import coil.compose.AsyncImage
import com.google.gson.Gson
import io.pm.finlight.*
import io.pm.finlight.ui.components.CreateAccountDialog
import io.pm.finlight.ui.components.CreateCategoryDialog
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.components.TimePickerDialog
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import java.io.File
import java.net.URLEncoder
import java.text.SimpleDateFormat
import java.util.*
import kotlin.math.pow
import io.pm.finlight.R

private const val TAG = "DetailScreenDebug"

private sealed class SheetContent {
    object Description : SheetContent()
    object Amount : SheetContent()
    object Notes : SheetContent()
    object Account : SheetContent()
    object Category : SheetContent()
    object Tags : SheetContent()
}

private sealed interface DetailScreenState {
    object Loading : DetailScreenState
    data class Success(val details: TransactionDetails) : DetailScreenState
    object Exit : DetailScreenState
}


@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)
@Composable
fun TransactionDetailScreen(
    navController: NavController,
    transactionId: Int,
    viewModel: TransactionViewModel = viewModel(),
    accountViewModel: AccountViewModel = viewModel(),
    onSaveRenameRule: (originalName: String, newName: String) -> Unit
) {
    Log.d(TAG, "Composing TransactionDetailScreen for transactionId: $transactionId")

    val screenState by produceState<DetailScreenState>(initialValue = DetailScreenState.Loading, transactionId) {
        viewModel.findTransactionDetailsById(transactionId).collect { details ->
            value = if (details != null) {
                DetailScreenState.Success(details)
            } else {
                DetailScreenState.Exit
            }
        }
    }

    val reparseResult = navController.currentBackStackEntry
        ?.savedStateHandle
        ?.getLiveData<Boolean>("reparse_needed")
        ?.observeAsState()

    LaunchedEffect(reparseResult?.value) {
        if (reparseResult?.value == true) {
            Log.d("DetailScreen", "Reparse needed signal received for txn ID: $transactionId")
            viewModel.reparseTransactionFromSms(transactionId)
            navController.currentBackStackEntry?.savedStateHandle?.set("reparse_needed", false)
        }
    }


    val accounts by viewModel.allAccounts.collectAsState()
    val categories by viewModel.allCategories.collectAsState(initial = emptyList())
    val allTags by viewModel.allTags.collectAsState()
    val selectedTags by viewModel.selectedTags.collectAsState()
    val attachedImages by viewModel.transactionImages.collectAsState()
    val originalSms by viewModel.originalSmsText.collectAsState()
    val visitCount by viewModel.visitCount.collectAsState()
    val scope = rememberCoroutineScope()
    val retroUpdateSheetState by viewModel.retroUpdateSheetState.collectAsState()


    var showMenu by remember { mutableStateOf(false) }
    var showDeleteDialog by remember { mutableStateOf(false) }
    var showDatePicker by remember { mutableStateOf(false) }
    var showTimePicker by remember { mutableStateOf(false) }
    var showImageViewer by remember { mutableStateOf<Uri?>(null) }
    var showImageDeleteDialog by remember { mutableStateOf<TransactionImage?>(null) }

    var activeSheetContent by remember { mutableStateOf<SheetContent?>(null) }
    val sheetState = rememberModalBottomSheetState(skipPartiallyExpanded = true)

    var showCreateAccountDialog by remember { mutableStateOf(false) }
    var showCreateCategoryDialog by remember { mutableStateOf(false) }


    val imagePickerLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        uri?.let {
            viewModel.attachPhotoToTransaction(transactionId, it)
        }
    }

    val context = LocalContext.current
    LaunchedEffect(transactionId) {
        NotificationManagerCompat.from(context).cancel(transactionId)
        viewModel.loadTagsForTransaction(transactionId)
        viewModel.loadImagesForTransaction(transactionId)
    }

    DisposableEffect(Unit) {
        onDispose {
            viewModel.clearSelectedTags()
            viewModel.clearOriginalSms()
        }
    }

    when (val state = screenState) {
        is DetailScreenState.Loading -> {
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                CircularProgressIndicator()
            }
        }
        is DetailScreenState.Exit -> {
            LaunchedEffect(Unit) {
                navController.popBackStack()
            }
            Box(modifier = Modifier.fillMaxSize().background(MaterialTheme.colorScheme.background))
        }
        is DetailScreenState.Success -> {
            val details = state.details
            val title = when (details.transaction.transactionType) {
                "expense" -> "Debit transaction"
                "income" -> "Credit transaction"
                else -> "Transaction Details"
            }
            val calendar = remember { Calendar.getInstance().apply { timeInMillis = details.transaction.date } }

            fun Color.isDark() = (red * 0.299 + green * 0.587 + blue * 0.114) < 0.5
            val isThemeDark = MaterialTheme.colorScheme.background.isDark()
            val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

            LaunchedEffect(details.transaction.originalDescription, details.transaction.description) {
                viewModel.loadVisitCount(details.transaction.originalDescription, details.transaction.description)
            }

            LaunchedEffect(details.transaction.sourceSmsId) {
                viewModel.loadOriginalSms(details.transaction.sourceSmsId)
            }

            if (retroUpdateSheetState != null) {
                ModalBottomSheet(
                    onDismissRequest = { viewModel.dismissRetroUpdateSheet() },
                    containerColor = popupContainerColor,
                    dragHandle = { BottomSheetDefaults.DragHandle(color = MaterialTheme.colorScheme.onSurfaceVariant) }
                ) {
                    RetrospectiveUpdateSheetContent(
                        state = retroUpdateSheetState!!,
                        onToggleSelection = viewModel::toggleRetroUpdateSelection,
                        onToggleSelectAll = viewModel::toggleRetroUpdateSelectAll,
                        onConfirm = {
                            viewModel.performBatchUpdate()
                        },
                        onDismiss = { viewModel.dismissRetroUpdateSheet() }
                    )
                }
            }

            Box(modifier = Modifier.fillMaxSize()) {
                Scaffold(
                    topBar = {
                        TopAppBar(
                            title = { Text(title) },
                            navigationIcon = {
                                IconButton(onClick = { navController.popBackStack() }) {
                                    Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                                }
                            },
                            actions = {
                                IconButton(onClick = { showMenu = true }) {
                                    Icon(Icons.Default.MoreVert, contentDescription = "More options")
                                }
                                DropdownMenu(
                                    expanded = showMenu,
                                    onDismissRequest = { showMenu = false }
                                ) {
                                    DropdownMenuItem(
                                        text = { Text("Delete") },
                                        onClick = {
                                            showMenu = false
                                            showDeleteDialog = true
                                        },
                                        leadingIcon = { Icon(Icons.Default.Delete, contentDescription = "Delete") }
                                    )
                                }
                            },
                            colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent)
                        )
                    },
                    containerColor = Color.Transparent
                ) { innerPadding ->
                    LazyColumn(
                        modifier = Modifier.padding(innerPadding),
                        verticalArrangement = Arrangement.spacedBy(16.dp),
                        contentPadding = PaddingValues(bottom = 16.dp)
                    ) {
                        item {
                            // --- MODIFIED: Wrap header in a padded Box for a card-like appearance ---
                            Box(modifier = Modifier.padding(horizontal = 16.dp)) {
                                TransactionSpotlightHeader(
                                    details = details,
                                    visitCount = visitCount,
                                    onDescriptionClick = { activeSheetContent = SheetContent.Description },
                                    onAmountClick = { activeSheetContent = SheetContent.Amount },
                                    onCategoryClick = { activeSheetContent = SheetContent.Category },
                                    onDateTimeClick = { showDatePicker = true }
                                )
                            }
                        }

                        item {
                            Box(modifier = Modifier.padding(horizontal = 16.dp)) {
                                AccountCardWithSwitch(
                                    details = details,
                                    onAccountClick = { activeSheetContent = SheetContent.Account },
                                    onExcludeToggled = { isChecked ->
                                        viewModel.updateTransactionExclusion(details.transaction.id, !isChecked)
                                    }
                                )
                            }
                        }

                        item {
                            Box(modifier = Modifier.padding(horizontal = 16.dp)) {
                                GlassPanel {
                                    Column {
                                        NotesRow(
                                            details = details,
                                            onClick = { activeSheetContent = SheetContent.Notes }
                                        )
                                        if (selectedTags.isNotEmpty() || details.transaction.notes?.isNotBlank() == true) {
                                            HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                                        }
                                        TagsRow(
                                            selectedTags = selectedTags,
                                            onClick = { activeSheetContent = SheetContent.Tags }
                                        )
                                    }
                                }
                            }
                        }

                        item {
                            Box(modifier = Modifier.padding(horizontal = 16.dp)) {
                                GlassPanel {
                                    AttachmentRow(
                                        images = attachedImages,
                                        onAddClick = { imagePickerLauncher.launch("image/*") },
                                        onViewClick = { showImageViewer = it },
                                        onDeleteClick = { showImageDeleteDialog = it }
                                    )
                                }
                            }
                        }


                        if (details.transaction.sourceSmsId != null) {
                            item {
                                Box(modifier = Modifier.padding(horizontal = 16.dp)) {
                                    Button(
                                        onClick = {
                                            scope.launch {
                                                val smsMessage = viewModel.getOriginalSmsMessage(details.transaction.sourceSmsId!!)
                                                if (smsMessage != null) {
                                                    val potentialTxn = PotentialTransaction(
                                                        sourceSmsId = smsMessage.id,
                                                        smsSender = smsMessage.sender,
                                                        amount = details.transaction.amount,
                                                        transactionType = details.transaction.transactionType,
                                                        merchantName = details.transaction.description,
                                                        originalMessage = smsMessage.body,
                                                        sourceSmsHash = details.transaction.sourceSmsHash
                                                    )
                                                    val json = Gson().toJson(potentialTxn)
                                                    val encodedJson = URLEncoder.encode(json, "UTF-8")
                                                    navController.navigate("rule_creation_screen?potentialTransactionJson=$encodedJson")
                                                } else {
                                                    Toast.makeText(context, "Original SMS not found.", Toast.LENGTH_SHORT).show()
                                                }
                                            }
                                        },
                                        modifier = Modifier.fillMaxWidth()
                                    ) {
                                        Icon(Icons.Default.Build, contentDescription = null)
                                        Spacer(Modifier.width(8.dp))
                                        Text("Fix Parsing")
                                    }
                                }
                            }
                        }

                        if (!originalSms.isNullOrBlank()) {
                            item {
                                Box(modifier = Modifier.padding(horizontal = 16.dp)) {
                                    GlassPanel(
                                        modifier = Modifier.fillMaxWidth()
                                    ) {
                                        Column(Modifier.padding(16.dp)) {
                                            Row(
                                                verticalAlignment = Alignment.CenterVertically,
                                                horizontalArrangement = Arrangement.spacedBy(16.dp)
                                            ) {
                                                Icon(
                                                    Icons.Default.Message,
                                                    contentDescription = "Original SMS",
                                                    tint = MaterialTheme.colorScheme.onSurfaceVariant
                                                )
                                                Text(
                                                    "Original SMS Message",
                                                    style = MaterialTheme.typography.titleMedium,
                                                    fontWeight = FontWeight.Bold,
                                                    color = MaterialTheme.colorScheme.onSurface
                                                )
                                            }
                                            Spacer(Modifier.height(12.dp))
                                            Text(
                                                text = originalSms!!,
                                                style = MaterialTheme.typography.bodyMedium,
                                                fontFamily = FontFamily.Monospace,
                                                color = MaterialTheme.colorScheme.onSurfaceVariant,
                                                lineHeight = 20.sp
                                            )
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (activeSheetContent != null) {
                        ModalBottomSheet(
                            onDismissRequest = { activeSheetContent = null },
                            sheetState = sheetState,
                            containerColor = popupContainerColor,
                            dragHandle = { BottomSheetDefaults.DragHandle(color = MaterialTheme.colorScheme.onSurfaceVariant) }
                        ) {
                            TransactionEditSheetContent(
                                sheetContent = activeSheetContent!!,
                                details = details,
                                viewModel = viewModel,
                                accountViewModel = accountViewModel,
                                onSaveRenameRule = onSaveRenameRule,
                                accounts = accounts,
                                categories = categories,
                                allTags = allTags,
                                selectedTags = selectedTags,
                                onDismiss = { activeSheetContent = null },
                                onAddNewAccount = {
                                    activeSheetContent = null
                                    showCreateAccountDialog = true
                                },
                                onAddNewCategory = {
                                    activeSheetContent = null
                                    showCreateCategoryDialog = true
                                }
                            )
                        }
                    }

                    if (showCreateAccountDialog) {
                        CreateAccountDialog(
                            onDismiss = { showCreateAccountDialog = false },
                            onConfirm = { name, type ->
                                viewModel.createAccount(name, type) { newAccount ->
                                    viewModel.updateTransactionAccount(transactionId, newAccount.id)
                                }
                                showCreateAccountDialog = false
                            }
                        )
                    }

                    if (showCreateCategoryDialog) {
                        CreateCategoryDialog(
                            onDismiss = { showCreateCategoryDialog = false },
                            onConfirm = { name, iconKey, colorKey ->
                                viewModel.createCategory(name, iconKey, colorKey) { newCategory ->
                                    viewModel.updateTransactionCategory(transactionId, newCategory.id)
                                }
                                showCreateCategoryDialog = false
                            }
                        )
                    }

                    if (showDatePicker) {
                        val datePickerState = rememberDatePickerState(initialSelectedDateMillis = calendar.timeInMillis)
                        DatePickerDialog(
                            onDismissRequest = { showDatePicker = false },
                            confirmButton = {
                                TextButton(onClick = {
                                    datePickerState.selectedDateMillis?.let {
                                        calendar.timeInMillis = it
                                    }
                                    showDatePicker = false
                                    showTimePicker = true
                                }) { Text("OK") }
                            }
                        ) { DatePicker(state = datePickerState) }
                    }
                    if (showTimePicker) {
                        val timePickerState = rememberTimePickerState(initialHour = calendar.get(Calendar.HOUR_OF_DAY), initialMinute = calendar.get(Calendar.MINUTE))
                        TimePickerDialog(
                            onDismissRequest = { showTimePicker = false },
                            onConfirm = {
                                calendar.set(Calendar.HOUR_OF_DAY, timePickerState.hour)
                                calendar.set(Calendar.MINUTE, timePickerState.minute)
                                viewModel.updateTransactionDate(transactionId, calendar.timeInMillis)
                                showTimePicker = false
                            }
                        ) { TimePicker(state = timePickerState) }
                    }

                    if (showDeleteDialog) {
                        AlertDialog(
                            onDismissRequest = { showDeleteDialog = false },
                            containerColor = popupContainerColor,
                            title = { Text("Delete Transaction?", color = MaterialTheme.colorScheme.onSurface) },
                            text = { Text("Are you sure you want to permanently delete this transaction? This action cannot be undone.", color = MaterialTheme.colorScheme.onSurfaceVariant) },
                            confirmButton = {
                                Button(
                                    onClick = {
                                        viewModel.deleteTransaction(details.transaction)
                                        showDeleteDialog = false
                                    },
                                    shape = CircleShape,
                                    colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
                                ) { Text("Delete") }
                            },
                            dismissButton = { TextButton(onClick = { showDeleteDialog = false }) { Text("Cancel") } }
                        )
                    }

                    if (showImageViewer != null) {
                        Dialog(onDismissRequest = { showImageViewer = null }) {
                            AsyncImage(
                                model = showImageViewer,
                                contentDescription = "Full screen image",
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .clip(RoundedCornerShape(16.dp))
                            )
                        }
                    }

                    if (showImageDeleteDialog != null) {
                        AlertDialog(
                            onDismissRequest = { showImageDeleteDialog = null },
                            containerColor = popupContainerColor,
                            title = { Text("Delete Attachment?", color = MaterialTheme.colorScheme.onSurface) },
                            text = { Text("Are you sure you want to delete this attachment? This action cannot be undone.", color = MaterialTheme.colorScheme.onSurfaceVariant) },
                            confirmButton = {
                                Button(
                                    onClick = {
                                        viewModel.deleteTransactionImage(showImageDeleteDialog!!)
                                        showImageDeleteDialog = null
                                    },
                                    shape = CircleShape,
                                    colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
                                ) { Text("Delete") }
                            },
                            dismissButton = {
                                TextButton(onClick = { showImageDeleteDialog = null }) { Text("Cancel") }
                            }
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun DynamicCategoryBackground(category: Category) {
    // --- UPDATED: Show '?' for Uncategorized, otherwise the first letter ---
    val letter = if (category.name == "Uncategorized") "?" else category.name.firstOrNull()?.uppercase() ?: "?"
    val color = CategoryIconHelper.getIconBackgroundColor(category.colorKey)

    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Text(
            text = letter,
            fontSize = 250.sp,
            fontWeight = FontWeight.Bold,
            color = color.copy(alpha = 0.15f)
        )
    }
}

@Composable
private fun TransactionSpotlightHeader(
    details: TransactionDetails,
    visitCount: Int,
    onDescriptionClick: () -> Unit,
    onAmountClick: () -> Unit,
    onCategoryClick: () -> Unit,
    onDateTimeClick: () -> Unit
) {
    val category = details.toCategory()
    val categoryColor = CategoryIconHelper.getIconBackgroundColor(category.colorKey)
    val dateFormatter = remember { SimpleDateFormat("EEE, dd MMMM yy, h:mm a", Locale.getDefault()) }

    val animatedAmount by animateFloatAsState(
        targetValue = details.transaction.amount.toFloat(),
        animationSpec = tween(1500, easing = EaseOutCubic),
        label = "AmountAnimation"
    )

    GlassPanel(
        modifier = Modifier
            .fillMaxWidth()
            .height(350.dp)
    ) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            // --- UPDATED: Conditional background logic ---
            val isPredefined = CategoryIconHelper.getCategoryBackground(category.iconKey) != R.drawable.bg_cat_general
            if (isPredefined) {
                Image(
                    painter = painterResource(id = CategoryIconHelper.getCategoryBackground(category.iconKey)),
                    contentDescription = null,
                    contentScale = ContentScale.Crop,
                    modifier = Modifier.matchParentSize(),
                    alpha = 0.3f
                )
            } else {
                DynamicCategoryBackground(category = category)
            }

            Box(
                modifier = Modifier
                    .matchParentSize()
                    .background(
                        Brush.verticalGradient(
                            colors = listOf(Color.Black.copy(alpha = 0.2f), Color.Black.copy(alpha = 0.6f))
                        )
                    )
            )
            Canvas(modifier = Modifier.matchParentSize()) {
                drawIntoCanvas {
                    val paint = Paint().asFrameworkPaint()
                    val radius = size.width * 0.8f
                    paint.color = android.graphics.Color.TRANSPARENT
                    paint.setShadowLayer(
                        radius,
                        0f,
                        0f,
                        categoryColor
                            .copy(alpha = 0.4f)
                            .toArgb()
                    )
                    it.drawCircle(center, radius / 2, Paint().apply { this.color = Color.Transparent })
                }
            }

            Column(
                modifier = Modifier.fillMaxSize(),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.Center
            ) {
                Spacer(modifier = Modifier.weight(1f))
                Text(
                    text = details.transaction.description,
                    style = MaterialTheme.typography.headlineMedium,
                    color = Color.White,
                    textAlign = TextAlign.Center,
                    modifier = Modifier
                        .clickable(onClick = onDescriptionClick)
                        .padding(horizontal = 16.dp)
                )
                Text(
                    text = "${"%,.2f".format(animatedAmount)}",
                    style = MaterialTheme.typography.displayMedium,
                    fontWeight = FontWeight.Bold,
                    color = Color.White,
                    modifier = Modifier.clickable(onClick = onAmountClick)
                )
                Spacer(modifier = Modifier.height(16.dp))
                ChipWithIcon(
                    text = category.name,
                    onClick = onCategoryClick,
                    category = category
                )
                Spacer(modifier = Modifier.weight(1f))
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 24.dp, vertical = 16.dp),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = dateFormatter.format(Date(details.transaction.date)),
                        style = MaterialTheme.typography.bodyMedium,
                        color = Color.White.copy(alpha = 0.8f),
                        modifier = Modifier.clickable(onClick = onDateTimeClick)
                    )
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(4.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.Info,
                            contentDescription = "Transaction Source",
                            tint = Color.White.copy(alpha = 0.8f),
                            modifier = Modifier.size(16.dp)
                        )
                        Text(
                            text = details.transaction.source,
                            style = MaterialTheme.typography.labelSmall,
                            color = Color.White.copy(alpha = 0.8f)
                        )
                    }
                }
            }

            if (visitCount > 1) {
                AssistChip(
                    modifier = Modifier
                        .align(Alignment.TopEnd)
                        .padding(16.dp),
                    onClick = { /* No action needed */ },
                    label = { Text("$visitCount visits") },
                    leadingIcon = { Icon(Icons.Default.History, contentDescription = null, modifier = Modifier.size(18.dp)) },
                    colors = AssistChipDefaults.assistChipColors(
                        containerColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f),
                        labelColor = MaterialTheme.colorScheme.onSurfaceVariant,
                        leadingIconContentColor = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                )
            }
        }
    }
}


@Composable
private fun AccountCardWithSwitch(
    details: TransactionDetails,
    onAccountClick: () -> Unit,
    onExcludeToggled: (Boolean) -> Unit
) {
    val isExcluded = details.transaction.isExcluded
    val switchLabel = details.transaction.transactionType.replaceFirstChar { it.titlecase(Locale.getDefault()) }

    GlassPanel {
        Row(
            modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(
                modifier = Modifier
                    .weight(0.7f)
                    .clickable(onClick = onAccountClick)
                    .padding(vertical = 8.dp)
            ) {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Icon(
                        Icons.Default.AccountBalanceWallet,
                        contentDescription = "Account",
                        tint = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Spacer(Modifier.width(16.dp))
                    Text(
                        text = "Account",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
                Spacer(Modifier.height(4.dp))
                Text(
                    text = details.accountName ?: "N/A",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.SemiBold,
                    color = MaterialTheme.colorScheme.onSurface,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
            }

            Column(
                modifier = Modifier.weight(0.3f),
                horizontalAlignment = Alignment.End,
                verticalArrangement = Arrangement.Center
            ) {
                Text(
                    text = switchLabel,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurface,
                )
                Spacer(Modifier.height(4.dp))
                Switch(
                    checked = !isExcluded,
                    onCheckedChange = onExcludeToggled
                )
            }
        }
    }
}


@Composable
private fun NotesRow(details: TransactionDetails, onClick: () -> Unit) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick)
            .padding(16.dp),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Icon(Icons.AutoMirrored.Filled.Notes, contentDescription = "Notes", tint = MaterialTheme.colorScheme.onSurfaceVariant)
        Text("Notes", modifier = Modifier.weight(1f), color = MaterialTheme.colorScheme.onSurface)
        Text(
            details.transaction.notes ?: "Tap to add",
            fontWeight = if (details.transaction.notes.isNullOrBlank()) FontWeight.Normal else FontWeight.SemiBold,
            color = if (details.transaction.notes.isNullOrBlank()) MaterialTheme.colorScheme.onSurfaceVariant else MaterialTheme.colorScheme.onSurface,
            maxLines = 1,
            overflow = TextOverflow.Ellipsis
        )
        Icon(Icons.Default.Edit, contentDescription = "Edit Notes", modifier = Modifier.size(16.dp), tint = MaterialTheme.colorScheme.onSurfaceVariant)
    }
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
private fun TagsRow(selectedTags: Set<Tag>, onClick: () -> Unit) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick)
            .padding(16.dp),
        verticalAlignment = Alignment.Top,
        horizontalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Icon(Icons.Default.NewLabel, contentDescription = "Tags", tint = MaterialTheme.colorScheme.onSurfaceVariant)
        Column(modifier = Modifier.weight(1f)) {
            Text("Tags", color = MaterialTheme.colorScheme.onSurface)
            Spacer(Modifier.height(8.dp))
            if(selectedTags.isEmpty()){
                Text("Tap to add", color = MaterialTheme.colorScheme.onSurfaceVariant)
            } else {
                FlowRow(
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    verticalArrangement = Arrangement.spacedBy(4.dp)
                ) {
                    selectedTags.forEach { tag ->
                        AssistChip(onClick = {}, label = { Text(tag.name) })
                    }
                }
            }
        }
        Icon(Icons.Default.Edit, contentDescription = "Edit Tags", modifier = Modifier.size(16.dp), tint = MaterialTheme.colorScheme.onSurfaceVariant)
    }
}

@Composable
private fun AttachmentRow(
    images: List<TransactionImage>,
    onAddClick: () -> Unit,
    onViewClick: (Uri) -> Unit,
    onDeleteClick: (TransactionImage) -> Unit
) {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(Icons.Default.Attachment, contentDescription = "Attachments", tint = MaterialTheme.colorScheme.onSurfaceVariant)
            Spacer(Modifier.width(16.dp))
            Text("Attachments", modifier = Modifier.weight(1f), color = MaterialTheme.colorScheme.onSurface)
            TextButton(onClick = onAddClick) {
                Text("Add")
            }
        }
        if (images.isEmpty()) {
            Text("No photos or receipts attached", color = MaterialTheme.colorScheme.onSurfaceVariant, style = MaterialTheme.typography.bodyMedium)
        } else {
            LazyRow(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                items(images) { image ->
                    Box {
                        AsyncImage(
                            model = File(image.imageUri),
                            contentDescription = "Transaction Attachment",
                            contentScale = ContentScale.Crop,
                            modifier = Modifier
                                .size(80.dp)
                                .clip(RoundedCornerShape(8.dp))
                                .clickable { onViewClick(File(image.imageUri).toUri()) }
                        )
                        IconButton(
                            onClick = { onDeleteClick(image) },
                            modifier = Modifier
                                .align(Alignment.TopEnd)
                                .padding(4.dp)
                                .size(24.dp)
                                .background(Color.Black.copy(alpha = 0.5f), CircleShape)
                        ) {
                            Icon(
                                Icons.Default.Close,
                                contentDescription = "Delete Attachment",
                                tint = Color.White,
                                modifier = Modifier.size(16.dp)
                            )
                        }
                    }
                }
            }
        }
    }
}


@Composable
private fun TransactionEditSheetContent(
    sheetContent: SheetContent,
    details: TransactionDetails,
    viewModel: TransactionViewModel,
    accountViewModel: AccountViewModel,
    onSaveRenameRule: (originalName: String, newName: String) -> Unit,
    accounts: List<Account>,
    categories: List<Category>,
    allTags: List<Tag>,
    selectedTags: Set<Tag>,
    onDismiss: () -> Unit,
    onAddNewAccount: () -> Unit,
    onAddNewCategory: () -> Unit
) {
    val transactionId = details.transaction.id

    when (sheetContent) {
        is SheetContent.Description -> {
            var saveForFuture by remember { mutableStateOf(false) }
            EditTextFieldSheet(
                title = "Edit Description",
                initialValue = details.transaction.description,
                onConfirm = { newDescription ->
                    val originalNameForRule = details.transaction.originalDescription ?: details.transaction.description
                    if (saveForFuture) {
                        if (originalNameForRule.isNotBlank() && newDescription.isNotBlank()) {
                            onSaveRenameRule(originalNameForRule, newDescription)
                        }
                    }
                    viewModel.updateTransactionDescription(transactionId, newDescription)
                    onDismiss()
                },
                onDismiss = onDismiss
            ) {
                val originalNameForRule = details.transaction.originalDescription ?: details.transaction.description
                Row(
                    Modifier
                        .fillMaxWidth()
                        .clickable { saveForFuture = !saveForFuture }
                        .padding(vertical = 8.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = saveForFuture,
                        onCheckedChange = { saveForFuture = it },
                        colors = CheckboxDefaults.colors(
                            checkedColor = MaterialTheme.colorScheme.primary,
                            uncheckedColor = MaterialTheme.colorScheme.onSurfaceVariant,
                            checkmarkColor = MaterialTheme.colorScheme.surface
                        )
                    )
                    Spacer(Modifier.width(8.dp))
                    Text(
                        text = "Always rename '$originalNameForRule' to this",
                        color = MaterialTheme.colorScheme.onSurface
                    )
                }
            }
        }
        is SheetContent.Amount -> {
            EditTextFieldSheet(
                title = "Edit Amount",
                initialValue = "%.2f".format(details.transaction.amount),
                keyboardType = KeyboardType.Number,
                onConfirm = {
                    viewModel.updateTransactionAmount(transactionId, it)
                    onDismiss()
                },
                onDismiss = onDismiss
            )
        }
        is SheetContent.Notes -> {
            EditTextFieldSheet(
                title = "Edit Notes",
                initialValue = details.transaction.notes ?: "",
                onConfirm = {
                    viewModel.updateTransactionNotes(transactionId, it)
                    onDismiss()
                },
                onDismiss = onDismiss
            )
        }
        is SheetContent.Account -> {
            AccountPickerSheet(
                title = "Select Account",
                currentAccountId = details.transaction.accountId,
                items = accounts,
                onItemSelected = {
                    viewModel.updateTransactionAccount(transactionId, it.id)
                    onDismiss()
                },
                onDismiss = onDismiss,
                onAddNew = onAddNewAccount,
                accountViewModel = accountViewModel
            )
        }
        is SheetContent.Category -> {
            CategoryPickerSheet(
                title = "Select Category",
                items = categories,
                onItemSelected = {
                    viewModel.updateTransactionCategory(transactionId, it.id)
                    onDismiss()
                },
                onDismiss = onDismiss,
                onAddNew = onAddNewCategory
            )
        }
        is SheetContent.Tags -> {
            TagPickerSheet(
                allTags = allTags,
                selectedTags = selectedTags,
                onTagSelected = viewModel::onTagSelected,
                onAddNewTag = viewModel::addTagOnTheGo,
                onConfirm = {
                    viewModel.updateTagsForTransaction(transactionId)
                    onDismiss()
                },
                onDismiss = onDismiss
            )
        }
    }
}

@Composable
private fun AccountPickerSheet(
    title: String,
    currentAccountId: Int,
    items: List<Account>,
    onItemSelected: (Account) -> Unit,
    onDismiss: () -> Unit,
    onAddNew: () -> Unit,
    accountViewModel: AccountViewModel
) {
    var editingAccount by remember { mutableStateOf<Account?>(null) }
    var editingName by remember { mutableStateOf("") }

    val currentAccount = items.find { it.id == currentAccountId }
    val otherAccounts = items.filter { it.id != currentAccountId }

    Column(modifier = Modifier.navigationBarsPadding()) {
        Text(
            title,
            style = MaterialTheme.typography.titleLarge,
            modifier = Modifier.padding(16.dp),
            color = MaterialTheme.colorScheme.onSurface
        )

        currentAccount?.let { account ->
            AccountPickerItem(
                account = account,
                isEditing = editingAccount?.id == account.id,
                editingName = editingName,
                onEditingNameChange = { editingName = it },
                onEditClick = {
                    editingAccount = account
                    editingName = account.name
                },
                onSaveClick = {
                    accountViewModel.renameAccount(account.id, editingName)
                    editingAccount = null
                },
                onCancelClick = { editingAccount = null },
                onSelectClick = { onItemSelected(account) },
                isCurrent = true
            )
            HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
        }

        LazyColumn {
            items(otherAccounts) { account ->
                AccountPickerItem(
                    account = account,
                    isEditing = editingAccount?.id == account.id,
                    editingName = editingName,
                    onEditingNameChange = { editingName = it },
                    onEditClick = {
                        editingAccount = account
                        editingName = account.name
                    },
                    onSaveClick = {
                        accountViewModel.renameAccount(account.id, editingName)
                        editingAccount = null
                    },
                    onCancelClick = { editingAccount = null },
                    onSelectClick = { onItemSelected(account) }
                )
            }
            item {
                ListItem(
                    headlineContent = { Text("Create New Account", color = MaterialTheme.colorScheme.onSurface) },
                    leadingContent = { Icon(Icons.Default.Add, contentDescription = "Create New Account", tint = MaterialTheme.colorScheme.primary) },
                    modifier = Modifier.clickable(onClick = onAddNew)
                )
            }
        }
        Spacer(Modifier.height(16.dp))
    }
}

@Composable
private fun AccountPickerItem(
    account: Account,
    isEditing: Boolean,
    editingName: String,
    onEditingNameChange: (String) -> Unit,
    onEditClick: () -> Unit,
    onSaveClick: () -> Unit,
    onCancelClick: () -> Unit,
    onSelectClick: () -> Unit,
    isCurrent: Boolean = false
) {
    val focusRequester = remember { FocusRequester() }

    // When isEditing becomes true, this block replaces the standard ListItem
    if (isEditing) {
        // Use a simple Row for the editing UI to avoid focus conflicts
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp, vertical = 8.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            OutlinedTextField(
                value = editingName,
                onValueChange = onEditingNameChange,
                modifier = Modifier
                    .weight(1f)
                    .focusRequester(focusRequester),
                singleLine = true,
                label = { Text("Account Name") }
            )
            IconButton(onClick = onSaveClick, enabled = editingName.isNotBlank()) {
                Icon(Icons.Default.Check, contentDescription = "Save Name", tint = MaterialTheme.colorScheme.primary)
            }
            IconButton(onClick = onCancelClick) {
                Icon(Icons.Default.Close, contentDescription = "Cancel Edit", tint = MaterialTheme.colorScheme.onSurfaceVariant)
            }
        }
        // The LaunchedEffect is now keyed to Unit, so it runs exactly once when this
        // composable enters the composition tree (i.e., when isEditing becomes true).
        LaunchedEffect(Unit) {
            focusRequester.requestFocus()
        }
    } else {
        // This is the original display-only ListItem
        val colors = if (isCurrent) {
            ListItemDefaults.colors(
                containerColor = MaterialTheme.colorScheme.secondaryContainer,
                headlineColor = MaterialTheme.colorScheme.onSecondaryContainer,
                supportingColor = MaterialTheme.colorScheme.onSecondaryContainer
            )
        } else {
            ListItemDefaults.colors(
                headlineColor = MaterialTheme.colorScheme.onSurface,
                supportingColor = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }

        ListItem(
            colors = colors,
            headlineContent = {
                Text(account.name, fontWeight = if (isCurrent) FontWeight.Bold else FontWeight.Normal)
            },
            supportingContent = { if (isCurrent) Text("Currently Selected") },
            modifier = Modifier.clickable(onClick = onSelectClick),
            trailingContent = {
                IconButton(onClick = onEditClick) {
                    Icon(Icons.Default.Edit, contentDescription = "Edit Account Name", tint = MaterialTheme.colorScheme.onSurfaceVariant)
                }
            }
        )
    }
}

@Composable
private fun EditTextFieldSheet(
    title: String,
    initialValue: String,
    keyboardType: KeyboardType = KeyboardType.Text,
    onConfirm: (String) -> Unit,
    onDismiss: () -> Unit,
    additionalContent: @Composable (() -> Unit)? = null
) {
    var text by remember { mutableStateOf(initialValue) }
    val focusRequester = remember { FocusRequester() }

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text(title, style = MaterialTheme.typography.titleLarge, color = MaterialTheme.colorScheme.onSurface)
        OutlinedTextField(
            value = text,
            onValueChange = { text = it },
            label = { Text("Value") },
            keyboardOptions = KeyboardOptions(
                keyboardType = keyboardType,
                capitalization = if (keyboardType == KeyboardType.Text) KeyboardCapitalization.Sentences else KeyboardCapitalization.None
            ),
            singleLine = true,
            modifier = Modifier
                .fillMaxWidth()
                .testTag("value_input")
                .focusRequester(focusRequester),
            colors = OutlinedTextFieldDefaults.colors(
                focusedTextColor = MaterialTheme.colorScheme.onSurface,
                unfocusedTextColor = MaterialTheme.colorScheme.onSurface,
                focusedContainerColor = Color.Transparent,
                unfocusedContainerColor = Color.Transparent,
                focusedBorderColor = MaterialTheme.colorScheme.primary,
                unfocusedBorderColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f),
                focusedLabelColor = MaterialTheme.colorScheme.primary,
                unfocusedLabelColor = MaterialTheme.colorScheme.onSurfaceVariant,
                cursorColor = MaterialTheme.colorScheme.primary
            )
        )
        additionalContent?.invoke()

        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.End,
            verticalAlignment = Alignment.CenterVertically
        ) {
            TextButton(onClick = onDismiss) { Text("Cancel") } // Revert on cancel
            Spacer(modifier = Modifier.width(8.dp))
            Button(onClick = {
                onConfirm(text)
            }) { Text("Save") }
        }
    }

    // --- BUG FIX: Request focus inside a LaunchedEffect ---
    LaunchedEffect(Unit) {
        delay(100) // Give UI time to draw
        focusRequester.requestFocus()
    }
}

@Composable
private fun CategoryPickerSheet(
    title: String,
    items: List<Category>,
    onItemSelected: (Category) -> Unit,
    onDismiss: () -> Unit,
    onAddNew: (() -> Unit)? = null
) {
    Column(modifier = Modifier.navigationBarsPadding()) {
        Text(
            title,
            style = MaterialTheme.typography.titleLarge,
            modifier = Modifier.padding(16.dp),
            color = MaterialTheme.colorScheme.onSurface
        )
        LazyVerticalGrid(
            columns = GridCells.Adaptive(minSize = 100.dp),
            contentPadding = PaddingValues(horizontal = 16.dp),
            horizontalArrangement = Arrangement.spacedBy(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            items(items) { category ->
                Column(
                    modifier = Modifier
                        .clip(RoundedCornerShape(12.dp))
                        .clickable {
                            onItemSelected(category)
                        }
                        .padding(vertical = 12.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    CategoryIconDisplay(category)
                    Text(
                        category.name,
                        style = MaterialTheme.typography.bodyMedium,
                        textAlign = TextAlign.Center,
                        maxLines = 1,
                        overflow = TextOverflow.Ellipsis,
                        color = MaterialTheme.colorScheme.onSurface
                    )
                }
            }
            if (onAddNew != null) {
                item {
                    Column(
                        modifier = Modifier
                            .clip(RoundedCornerShape(12.dp))
                            .clickable(onClick = onAddNew)
                            .padding(vertical = 12.dp)
                            .height(80.dp), // Match height of other items
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.Center
                    ) {
                        Icon(
                            Icons.Default.AddCircleOutline,
                            contentDescription = "Create New",
                            modifier = Modifier.size(48.dp),
                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Text(
                            "New",
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurface
                        )
                    }
                }
            }
        }
        Spacer(Modifier.height(16.dp))
    }
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
private fun TagPickerSheet(
    allTags: List<Tag>,
    selectedTags: Set<Tag>,
    onTagSelected: (Tag) -> Unit,
    onAddNewTag: (String) -> Unit,
    onConfirm: () -> Unit,
    onDismiss: () -> Unit,
) {
    var newTagName by remember { mutableStateOf("") }

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("Manage Tags", style = MaterialTheme.typography.titleLarge, color = MaterialTheme.colorScheme.onSurface)
        FlowRow(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(8.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            allTags.forEach { tag ->
                FilterChip(
                    selected = tag in selectedTags,
                    onClick = { onTagSelected(tag) },
                    label = { Text(tag.name) }
                )
            }
        }
        HorizontalDivider()
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            OutlinedTextField(
                value = newTagName,
                onValueChange = { newTagName = it },
                label = { Text("New Tag Name") },
                modifier = Modifier.weight(1f),
                colors = OutlinedTextFieldDefaults.colors(
                    focusedTextColor = MaterialTheme.colorScheme.onSurface,
                    unfocusedTextColor = MaterialTheme.colorScheme.onSurface,
                    focusedBorderColor = MaterialTheme.colorScheme.primary,
                    unfocusedBorderColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f),
                    focusedLabelColor = MaterialTheme.colorScheme.primary,
                    unfocusedLabelColor = MaterialTheme.colorScheme.onSurfaceVariant,
                )
            )
            IconButton(
                onClick = {
                    onAddNewTag(newTagName)
                    newTagName = ""
                },
                enabled = newTagName.isNotBlank()
            ) {
                Icon(Icons.Default.Add, contentDescription = "Add New Tag", tint = MaterialTheme.colorScheme.primary)
            }
        }
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.End,
            verticalAlignment = Alignment.CenterVertically
        ) {
            TextButton(onClick = onDismiss) { Text("Cancel") }
            Spacer(modifier = Modifier.width(8.dp))
            Button(onClick = {
                if (newTagName.isNotBlank()) {
                    onAddNewTag(newTagName)
                }
                onConfirm()
            }) { Text("Save") }
        }
    }
}

@Composable
private fun CategoryIconDisplay(category: Category) {
    Box(
        modifier = Modifier
            .size(48.dp)
            .clip(CircleShape)
            .background(CategoryIconHelper.getIconBackgroundColor(category.colorKey)),
        contentAlignment = Alignment.Center
    ) {
        // --- UPDATED: Prioritize showing '?' for Uncategorized ---
        if (category.name == "Uncategorized") {
            Icon(
                imageVector = CategoryIconHelper.getIcon("help_outline"),
                contentDescription = category.name,
                tint = Color.Black,
                modifier = Modifier.size(24.dp)
            )
        } else if (category.iconKey == "letter_default") {
            Text(
                text = category.name.firstOrNull()?.uppercase() ?: "?",
                color = Color.Black,
                fontWeight = FontWeight.Bold,
                fontSize = 22.sp
            )
        } else {
            Icon(
                imageVector = CategoryIconHelper.getIcon(category.iconKey),
                contentDescription = category.name,
                tint = Color.Black,
                modifier = Modifier.size(24.dp)
            )
        }
    }
}

private fun TransactionDetails.toCategory(): Category {
    // --- UPDATED: Use red color for uncategorized items ---
    return if (this.categoryName == null || this.categoryName == "Uncategorized") {
        Category(
            id = 0,
            name = "Uncategorized",
            iconKey = "help_outline",
            colorKey = "red_light"
        )
    } else {
        Category(
            id = this.transaction.categoryId ?: 0,
            name = this.categoryName,
            iconKey = this.categoryIconKey ?: "category",
            colorKey = this.categoryColorKey ?: "gray_light"
        )
    }
}

@Composable
private fun ChipWithIcon(
    text: String,
    onClick: () -> Unit,
    category: Category
) {
    Row(
        modifier = Modifier
            .clip(CircleShape)
            .clickable(onClick = onClick)
            .background(
                CategoryIconHelper
                    .getIconBackgroundColor(category.colorKey)
                    .copy(alpha = 0.9f)
            )
            .padding(horizontal = 12.dp, vertical = 6.dp),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        // --- UPDATED: Prioritize showing '?' for Uncategorized ---
        if (category.name == "Uncategorized") {
            Icon(
                imageVector = CategoryIconHelper.getIcon("help_outline"),
                contentDescription = null,
                tint = Color.Black,
                modifier = Modifier.size(20.dp)
            )
        } else if (category.iconKey == "letter_default") {
            Text(
                text = category.name.firstOrNull()?.uppercase() ?: "?",
                color = Color.Black,
                fontWeight = FontWeight.Bold,
                fontSize = 16.sp
            )
        } else {
            Icon(
                imageVector = CategoryIconHelper.getIcon(category.iconKey),
                contentDescription = null,
                tint = Color.Black,
                modifier = Modifier.size(20.dp)
            )
        }
        Text(
            text = text,
            fontWeight = FontWeight.SemiBold,
            color = Color.Black,
            style = MaterialTheme.typography.bodyMedium
        )
    }
}

@Composable
private fun RetrospectiveUpdateSheetContent(
    state: RetroUpdateSheetState,
    onToggleSelection: (Int) -> Unit,
    onToggleSelectAll: () -> Unit,
    onConfirm: () -> Unit,
    onDismiss: () -> Unit
) {
    val changeType = if (state.newDescription != null) "description" else "category"

    Column(
        modifier = Modifier
            .navigationBarsPadding()
            .padding(16.dp)
    ) {
        Text(
            "Update Similar Transactions",
            style = MaterialTheme.typography.titleLarge,
            modifier = Modifier.padding(bottom = 8.dp),
            color = MaterialTheme.colorScheme.onSurface
        )
        Text(
            "You've changed the $changeType for transactions like '${state.originalDescription}'. Apply this change to other similar transactions?",
            style = MaterialTheme.typography.bodyMedium,
            modifier = Modifier.padding(bottom = 16.dp),
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )

        if (state.isLoading) {
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(150.dp), contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        } else {
            Row(
                verticalAlignment = Alignment.CenterVertically,
                modifier = Modifier.fillMaxWidth()
            ) {
                val allSelected = state.selectedIds.size == state.similarTransactions.size
                Checkbox(
                    checked = allSelected,
                    onCheckedChange = { onToggleSelectAll() },
                    colors = CheckboxDefaults.colors(
                        checkedColor = MaterialTheme.colorScheme.primary,
                        uncheckedColor = MaterialTheme.colorScheme.onSurfaceVariant,
                        checkmarkColor = MaterialTheme.colorScheme.surface
                    )
                )
                Text(
                    text = if (allSelected) "Deselect All" else "Select All",
                    color = MaterialTheme.colorScheme.onSurface
                )
            }
            HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))

            LazyColumn(
                modifier = Modifier.heightIn(max = 250.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(state.similarTransactions, key = { it.id }) { transaction ->
                    SelectableTransactionItem(
                        transaction = transaction,
                        isSelected = transaction.id in state.selectedIds,
                        onToggle = { onToggleSelection(transaction.id) }
                    )
                }
            }
        }

        Spacer(Modifier.height(16.dp))

        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            OutlinedButton(
                onClick = onDismiss,
                modifier = Modifier.weight(1f)
            ) {
                Text("Just This One")
            }
            Button(
                onClick = onConfirm,
                modifier = Modifier.weight(1f),
                enabled = state.selectedIds.isNotEmpty()
            ) {
                Text("Update ${state.selectedIds.size} Items")
            }
        }
    }
}

@Composable
private fun SelectableTransactionItem(
    transaction: Transaction,
    isSelected: Boolean,
    onToggle: () -> Unit
) {
    val dateFormatter = remember { SimpleDateFormat("dd MMM, yy", Locale.getDefault()) }
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onToggle)
            .padding(vertical = 8.dp),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Checkbox(
            checked = isSelected,
            onCheckedChange = { onToggle() },
            colors = CheckboxDefaults.colors(
                checkedColor = MaterialTheme.colorScheme.primary,
                uncheckedColor = MaterialTheme.colorScheme.onSurfaceVariant,
                checkmarkColor = MaterialTheme.colorScheme.surface
            )
        )
        Column(modifier = Modifier.weight(1f)) {
            Text(
                text = transaction.description,
                fontWeight = FontWeight.SemiBold,
                color = MaterialTheme.colorScheme.onSurface
            )
            Text(
                text = dateFormatter.format(Date(transaction.date)),
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
        Text(
            text = "${"%,.2f".format(transaction.amount)}",
            color = MaterialTheme.colorScheme.onSurface
        )
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/CategorySpendingScreen.kt ==================
package io.pm.finlight.ui.screens

import android.graphics.Color
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import com.github.mikephil.charting.charts.PieChart
import com.github.mikephil.charting.data.PieData
import com.github.mikephil.charting.data.PieDataSet
import com.github.mikephil.charting.data.PieEntry
import com.github.mikephil.charting.formatter.PercentFormatter
import io.pm.finlight.CategoryIconHelper
import io.pm.finlight.CategorySpending
import io.pm.finlight.ui.components.GlassPanel

@Composable
fun CategorySpendingScreen(spendingList: List<CategorySpending>) {
    if (spendingList.isEmpty()) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Text("No spending data for this month.")
        }
        return
    }

    val totalSpending = spendingList.sumOf { it.totalAmount }
    val pieData = createPieData(spendingList)
    val pieChartLabelColor = MaterialTheme.colorScheme.onSurface.toArgb()

    LazyColumn(
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        item {
            GlassPanel(modifier = Modifier.fillMaxWidth()) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(
                        "Category Breakdown",
                        style = MaterialTheme.typography.titleLarge,
                        color = MaterialTheme.colorScheme.onSurface
                    )
                    Spacer(Modifier.height(16.dp))
                    AndroidView(
                        factory = { context ->
                            PieChart(context).apply {
                                description.isEnabled = false
                                isDrawHoleEnabled = true
                                setHoleColor(Color.TRANSPARENT)
                                setEntryLabelColor(pieChartLabelColor)
                                setEntryLabelTextSize(12f)
                                legend.isEnabled = false
                                setUsePercentValues(true)
                            }
                        },
                        update = { chart ->
                            chart.data = pieData
                            chart.invalidate()
                        },
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(250.dp)
                    )
                }
            }
        }

        items(spendingList) { categorySpending ->
            CategorySpendingCard(
                categorySpending = categorySpending,
                totalSpending = totalSpending
            )
        }
    }
}

@Composable
fun CategorySpendingCard(categorySpending: CategorySpending, totalSpending: Double) {
    val percentage = if (totalSpending > 0) (categorySpending.totalAmount / totalSpending * 100) else 0.0

    GlassPanel(
        modifier = Modifier.fillMaxWidth()
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Box(
                modifier = Modifier
                    .size(40.dp)
                    .clip(CircleShape)
                    .background(
                        CategoryIconHelper.getIconBackgroundColor(
                            categorySpending.colorKey ?: "gray_light"
                        )
                    ),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = CategoryIconHelper.getIcon(categorySpending.iconKey ?: "category"),
                    contentDescription = categorySpending.categoryName,
                    tint = androidx.compose.ui.graphics.Color.Black,
                    modifier = Modifier.size(22.dp)
                )
            }
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    categorySpending.categoryName,
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.onSurface
                )
                Text(
                    "${"%.1f".format(percentage)}% of total spending",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            Text(
                "${"%,.2f".format(categorySpending.totalAmount)}",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.onSurface
            )
        }
    }
}

fun createPieData(spendingList: List<CategorySpending>): PieData {
    val entries = spendingList.map {
        PieEntry(it.totalAmount.toFloat(), it.categoryName)
    }
    val colors = spendingList.map {
        (CategoryIconHelper.getIconBackgroundColor(it.colorKey ?: "gray_light")).toArgb()
    }
    val dataSet = PieDataSet(entries, "Spending").apply {
        this.colors = colors
        valueFormatter = PercentFormatter()
        valueTextSize = 12f
        valueTextColor = Color.BLACK
        setDrawValues(false) // Hiding values on the chart itself for a cleaner look
    }
    return PieData(dataSet)
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/AccountDetailScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/AccountDetailScreen.kt
// REASON: MAJOR REFACTOR - This screen has been completely redesigned to align
// with the "Project Aurora" vision. The standard Card header has been replaced
// with a more dynamic GlassPanel header that prominently features the bank's
// logo and balance. The transaction list items have also been converted to
// GlassPanels, ensuring a cohesive, modern, and high-contrast user experience.
// =================================================================================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.Image
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import io.pm.finlight.Account
import io.pm.finlight.AccountViewModel
import io.pm.finlight.BankLogoHelper
import io.pm.finlight.TransactionDetails
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.theme.ExpenseRedDark
import io.pm.finlight.ui.theme.ExpenseRedLight
import io.pm.finlight.ui.theme.IncomeGreenDark
import io.pm.finlight.ui.theme.IncomeGreenLight
import java.text.NumberFormat
import java.text.SimpleDateFormat
import java.util.*

@Composable
fun AccountDetailScreen(
    navController: NavController,
    viewModel: AccountViewModel,
    accountId: Int,
) {
    val account by viewModel.getAccountById(accountId).collectAsState(initial = null)
    val balance by viewModel.getAccountBalance(accountId).collectAsState(initial = 0.0)
    val transactions by viewModel.getTransactionsForAccount(accountId).collectAsState(initial = emptyList())

    val currentAccount = account ?: return // Don't compose if account is not loaded yet

    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        item {
            AccountDetailHeader(
                account = currentAccount,
                balance = balance
            )
        }

        if (transactions.isNotEmpty()) {
            item {
                Text(
                    text = "Recent Transactions",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.padding(start = 8.dp)
                )
            }
            items(transactions, key = { it.transaction.id }) { details ->
                AccountDetailTransactionItem(transactionDetails = details)
            }
        } else {
            item {
                GlassPanel(modifier = Modifier.fillMaxWidth()) {
                    Box(
                        contentAlignment = Alignment.Center,
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(32.dp)
                    ) {
                        Text(
                            "No transactions for this account yet.",
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun AccountDetailHeader(account: Account, balance: Double) {
    val currencyFormat = remember { NumberFormat.getCurrencyInstance(Locale("en", "IN")) }
    val balanceColor = when {
        balance > 0 -> MaterialTheme.colorScheme.primary
        balance < 0 -> MaterialTheme.colorScheme.error
        else -> MaterialTheme.colorScheme.onSurface
    }

    GlassPanel {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            Image(
                painter = painterResource(id = BankLogoHelper.getLogoForAccount(account.name)),
                contentDescription = "${account.name} Logo",
                modifier = Modifier.size(50.dp)
            )
            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                Text(
                    text = "Current Balance",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
                Text(
                    text = currencyFormat.format(balance),
                    style = MaterialTheme.typography.displaySmall,
                    fontWeight = FontWeight.Bold,
                    color = balanceColor
                )
            }
        }
    }
}

@Composable
private fun AccountDetailTransactionItem(transactionDetails: TransactionDetails) {
    val contentAlpha = if (transactionDetails.transaction.isExcluded) 0.5f else 1f
    val currencyFormat = remember { NumberFormat.getCurrencyInstance(Locale("en", "IN")) }
    val dateFormatter = remember { SimpleDateFormat("dd MMM, yyyy", Locale.getDefault()) }

    GlassPanel(modifier = Modifier.fillMaxWidth()) {
        Row(
            modifier = Modifier.padding(horizontal = 24.dp, vertical = 16.dp),
            verticalAlignment = Alignment.CenterVertically,
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = transactionDetails.transaction.description,
                    style = MaterialTheme.typography.bodyLarge,
                    fontWeight = FontWeight.SemiBold,
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = contentAlpha)
                )
                Text(
                    text = dateFormatter.format(Date(transactionDetails.transaction.date)),
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = contentAlpha)
                )
            }
            Spacer(Modifier.width(16.dp))

            val isIncome = transactionDetails.transaction.transactionType == "income"
            val amountColor = if (isSystemInDarkTheme()) {
                if (isIncome) IncomeGreenDark else ExpenseRedDark
            } else {
                if (isIncome) IncomeGreenLight else ExpenseRedLight
            }.copy(alpha = contentAlpha)

            Text(
                text = currencyFormat.format(transactionDetails.transaction.amount),
                style = MaterialTheme.typography.bodyLarge,
                fontWeight = FontWeight.Bold,
                color = amountColor,
            )
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/DashboardScreen.kt ==================
package io.pm.finlight.ui.screens

import android.app.Application
import androidx.compose.animation.core.LinearEasing
import androidx.compose.animation.core.RepeatMode
import androidx.compose.animation.core.animateFloat
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.infiniteRepeatable
import androidx.compose.animation.core.rememberInfiniteTransition
import androidx.compose.animation.core.tween
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.clickable
import androidx.compose.foundation.gestures.detectDragGesturesAfterLongPress
import androidx.compose.foundation.gestures.scrollBy
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.DragHandle
import androidx.compose.material.icons.filled.PieChart
import androidx.compose.material.icons.filled.RemoveCircleOutline
import androidx.compose.material.icons.filled.Timeline
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.shadow
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import androidx.navigation.NavGraph.Companion.findStartDestination
import io.pm.finlight.BottomNavItem
import io.pm.finlight.DashboardCardType
import io.pm.finlight.DashboardViewModel
import io.pm.finlight.DashboardViewModelFactory
import io.pm.finlight.ui.components.*
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch

@OptIn(ExperimentalFoundationApi::class, ExperimentalMaterial3Api::class)
@Composable
fun DashboardScreen(
    navController: NavController,
    viewModel: DashboardViewModel = viewModel(factory = DashboardViewModelFactory(LocalContext.current.applicationContext as Application)),
) {
    val visibleCards by viewModel.visibleCards.collectAsState()
    val isCustomizationMode by viewModel.isCustomizationMode.collectAsState()
    val showAddCardSheet by viewModel.showAddCardSheet.collectAsState()
    val hiddenCards by viewModel.hiddenCards.collectAsState()

    val coroutineScope = rememberCoroutineScope()
    var overscrollJob by remember { mutableStateOf<Job?>(null) }
    val dragDropState = rememberDragDropState(onMove = viewModel::updateCardOrder)

    if (showAddCardSheet) {
        val sheetContainerColor = if (isSystemInDarkTheme()) {
            Color(0xFF2C2C34)
        } else {
            BottomSheetDefaults.ContainerColor
        }

        ModalBottomSheet(
            onDismissRequest = { viewModel.onAddCardSheetDismiss() },
            containerColor = sheetContainerColor
        ) {
            AddCardSheetContent(
                hiddenCards = hiddenCards,
                onAddCard = { cardType ->
                    viewModel.showCard(cardType)
                    viewModel.onAddCardSheetDismiss()
                }
            )
        }
    }

    LazyColumn(
        state = dragDropState.lazyListState,
        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp),
        modifier = Modifier
            // --- FIX: Add a testTag to make the LazyColumn findable in tests ---
            .testTag("dashboard_lazy_column")
            .pointerInput(Unit) {
                detectDragGesturesAfterLongPress(
                    onDrag = { change, offset ->
                        change.consume()
                        dragDropState.onDrag(offset)

                        if (overscrollJob?.isActive == true) return@detectDragGesturesAfterLongPress

                        dragDropState
                            .checkForOverScroll()
                            .takeIf { it != 0f }
                            ?.let {
                                overscrollJob =
                                    coroutineScope.launch { dragDropState.lazyListState.scrollBy(it) }
                            } ?: run { overscrollJob?.cancel() }
                    },
                    onDragStart = { offset ->
                        viewModel.enterCustomizationMode()
                        dragDropState.onDragStart(offset)
                    },
                    onDragEnd = { dragDropState.onDragEnd() },
                    onDragCancel = { dragDropState.onDragEnd() }
                )
            }
    ) {
        itemsIndexed(visibleCards, key = { _, item -> item.name }) { index, cardType ->
            val isBeingDragged = index == dragDropState.draggingItemIndex

            val infiniteTransition = rememberInfiniteTransition(label = "giggle_animation")
            val giggleRotation by infiniteTransition.animateFloat(
                initialValue = -0.8f,
                targetValue = 0.8f,
                animationSpec = infiniteRepeatable(
                    animation = tween(150, easing = LinearEasing),
                    repeatMode = RepeatMode.Reverse
                ),
                label = "giggle"
            )

            val dragTiltRotation by animateFloatAsState(
                targetValue = if (isBeingDragged) -2f else 0f,
                animationSpec = tween(300),
                label = "DragRotation"
            )

            val finalRotation = when {
                isBeingDragged -> dragTiltRotation
                isCustomizationMode && cardType != DashboardCardType.HERO_BUDGET -> giggleRotation
                else -> 0f
            }

            val animatedElevation by animateFloatAsState(
                targetValue = if (isBeingDragged) 8f else 0f,
                animationSpec = tween(300),
                label = "DragElevation"
            )

            Box(
                modifier = Modifier
                    .animateItemPlacement()
                    .graphicsLayer {
                        // --- UPDATED: Use the new calculated translationY for smooth dragging ---
                        translationY = if (isBeingDragged) dragDropState.draggingItemTranslationY else 0f
                        rotationZ = finalRotation
                    }
                    .shadow(elevation = animatedElevation.dp, shape = MaterialTheme.shapes.extraLarge)
            ) {
                DashboardCard(
                    cardType = cardType,
                    navController = navController,
                    viewModel = viewModel,
                    isCustomizationMode = isCustomizationMode,
                    onHide = { viewModel.hideCard(cardType) }
                )
            }
        }
    }
}

@Composable
private fun DashboardCard(
    cardType: DashboardCardType,
    navController: NavController,
    viewModel: DashboardViewModel,
    isCustomizationMode: Boolean,
    onHide: () -> Unit
) {
    val netWorth by viewModel.netWorth.collectAsState()
    val monthlyIncome by viewModel.monthlyIncome.collectAsState()
    val monthlyExpenses by viewModel.monthlyExpenses.collectAsState()
    val overallBudget by viewModel.overallMonthlyBudget.collectAsState()
    val recentTransactions by viewModel.recentTransactions.collectAsState()
    val accountsSummary by viewModel.accountsSummary.collectAsState()
    val safeToSpendPerDay by viewModel.safeToSpendPerDay.collectAsState()
    val budgetStatus by viewModel.budgetStatus.collectAsState()
    // --- NEW: Collect the remaining amount state ---
    val amountRemaining by viewModel.amountRemaining.collectAsState()
    // --- NEW: Get the month name from the ViewModel ---
    val monthYear = viewModel.monthYear

    Box {
        when (cardType) {
            DashboardCardType.HERO_BUDGET -> DashboardHeroCard(
                totalBudget = overallBudget,
                amountSpent = monthlyExpenses.toFloat(),
                amountRemaining = amountRemaining,
                income = monthlyIncome.toFloat(),
                safeToSpend = safeToSpendPerDay,
                navController = navController,
                // --- NEW: Pass the month name to the hero card ---
                monthYear = monthYear
            )
            DashboardCardType.QUICK_ACTIONS -> AuroraQuickActionsCard(navController = navController)
            DashboardCardType.NET_WORTH -> AuroraNetWorthCard(netWorth)
            DashboardCardType.RECENT_ACTIVITY -> AuroraRecentActivityCard(recentTransactions, navController)
            DashboardCardType.ACCOUNTS_CAROUSEL -> AccountsCarouselCard(accounts = accountsSummary, navController = navController)
            DashboardCardType.BUDGET_WATCH -> BudgetWatchCard(
                budgetStatus = budgetStatus,
                navController = navController,
            )
        }
        if (isCustomizationMode && cardType != DashboardCardType.HERO_BUDGET) {
            Row(
                modifier = Modifier.align(Alignment.TopEnd),
                verticalAlignment = Alignment.CenterVertically
            ) {
                IconButton(onClick = onHide, modifier = Modifier.size(36.dp).padding(4.dp)) {
                    Icon(
                        Icons.Default.RemoveCircleOutline,
                        contentDescription = "Hide Card",
                        tint = MaterialTheme.colorScheme.error
                    )
                }
                Icon(
                    imageVector = Icons.Default.DragHandle,
                    contentDescription = "Drag to reorder",
                    modifier = Modifier.padding(8.dp)
                )
            }
        }
    }
}

@Composable
private fun AddCardSheetContent(
    hiddenCards: List<DashboardCardType>,
    onAddCard: (DashboardCardType) -> Unit
) {
    Column(modifier = Modifier.padding(16.dp).navigationBarsPadding()) {
        Text(
            "Add a Card to Your Dashboard",
            style = MaterialTheme.typography.titleLarge,
            color = MaterialTheme.colorScheme.onSurface
        )
        Spacer(Modifier.height(16.dp))
        if (hiddenCards.isEmpty()) {
            Text("All available cards are already on your dashboard.")
        } else {
            LazyColumn(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                items(hiddenCards) { cardType ->
                    ListItem(
                        headlineContent = { Text(cardType.name.replace('_', ' ').lowercase().replaceFirstChar { it.titlecase() }) },
                        leadingContent = { Icon(Icons.Default.Add, contentDescription = null) },
                        modifier = Modifier.clickable { onAddCard(cardType) }
                    )
                }
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/EditProfileScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/EditProfileScreen.kt
// REASON: New screen to allow users to update their profile information
// (name and picture) after the initial onboarding.
// =================================================================================
package io.pm.finlight.ui.screens

import android.content.Context
import android.net.Uri
import android.os.Environment
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CameraAlt
import androidx.compose.material.icons.filled.PhotoLibrary
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.input.KeyboardCapitalization
import androidx.compose.ui.unit.dp
import androidx.core.content.FileProvider
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import coil.compose.AsyncImage
import com.canhub.cropper.CropImageContract
import com.canhub.cropper.CropImageContractOptions
import com.canhub.cropper.CropImageOptions
import com.canhub.cropper.CropImageView
import io.pm.finlight.ProfileViewModel
import io.pm.finlight.R
import java.io.File
import java.text.SimpleDateFormat
import java.util.*

@Composable
fun EditProfileScreen(
    navController: NavController,
    viewModel: ProfileViewModel = viewModel()
) {
    val currentName by viewModel.userName.collectAsState()
    val savedProfilePictureUri by viewModel.profilePictureUri.collectAsState()
    val context = LocalContext.current

    var editedName by remember(currentName) { mutableStateOf(currentName) }
    var croppedImageUri by remember { mutableStateOf<Uri?>(null) }
    var tempCameraImageUri by remember { mutableStateOf<Uri?>(null) }
    var showImageSourceDialog by remember { mutableStateOf(false) }

    val displayUri = croppedImageUri ?: savedProfilePictureUri?.let { Uri.parse(it) }

    val toolbarColor = MaterialTheme.colorScheme.primary.toArgb()
    val toolbarTintColor = MaterialTheme.colorScheme.onPrimary.toArgb()
    val activityBackgroundColor = MaterialTheme.colorScheme.background.toArgb()

    val imageCropper = rememberLauncherForActivityResult(CropImageContract()) { result ->
        if (result.isSuccessful) {
            croppedImageUri = result.uriContent
        } else {
            val exception = result.error
            Toast.makeText(context, "Image cropping failed: ${exception?.message}", Toast.LENGTH_SHORT).show()
        }
    }

    val cameraLauncher = rememberLauncherForActivityResult(ActivityResultContracts.TakePicture()) { success ->
        if (success) {
            tempCameraImageUri?.let { uri ->
                val cropOptions = CropImageContractOptions(
                    uri = uri,
                    cropImageOptions = createCropOptions(toolbarColor, toolbarTintColor, activityBackgroundColor)
                )
                imageCropper.launch(cropOptions)
            }
        }
    }

    val galleryLauncher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri ->
        uri?.let {
            val cropOptions = CropImageContractOptions(
                uri = it,
                cropImageOptions = createCropOptions(toolbarColor, toolbarTintColor, activityBackgroundColor)
            )
            imageCropper.launch(cropOptions)
        }
    }

    if (showImageSourceDialog) {
        AlertDialog(
            onDismissRequest = { showImageSourceDialog = false },
            title = { Text("Change Profile Picture") },
            text = { Text("Choose a source for your new image.") },
            confirmButton = {
                TextButton(
                    onClick = {
                        showImageSourceDialog = false
                        // --- FIX: Create the temp file and get its secure URI before launching the camera ---
                        val tempFile = createTempImageFile(context)
                        val newTempUri = FileProvider.getUriForFile(
                            context,
                            "${context.packageName}.provider",
                            tempFile
                        )
                        tempCameraImageUri = newTempUri
                        cameraLauncher.launch(newTempUri)
                    }
                ) {
                    Icon(Icons.Default.CameraAlt, contentDescription = "Camera")
                    Spacer(Modifier.width(8.dp))
                    Text("Camera")
                }
            },
            dismissButton = {
                TextButton(
                    onClick = {
                        showImageSourceDialog = false
                        galleryLauncher.launch("image/*")
                    }
                ) {
                    Icon(Icons.Default.PhotoLibrary, contentDescription = "Gallery")
                    Spacer(Modifier.width(8.dp))
                    Text("Gallery")
                }
            }
        )
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(24.dp)
    ) {
        AsyncImage(
            model = displayUri,
            contentDescription = "User Profile Picture",
            placeholder = painterResource(id = R.drawable.ic_launcher_foreground),
            error = painterResource(id = R.drawable.ic_launcher_foreground),
            contentScale = ContentScale.Crop,
            modifier = Modifier
                .size(128.dp)
                .clip(CircleShape)
                .background(MaterialTheme.colorScheme.surfaceVariant)
                .border(2.dp, MaterialTheme.colorScheme.primary, CircleShape)
                .clickable {
                    showImageSourceDialog = true
                }
        )

        OutlinedTextField(
            value = editedName,
            onValueChange = { editedName = it },
            label = { Text("Your Name") },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true,
            keyboardOptions = KeyboardOptions(capitalization = KeyboardCapitalization.Words)
        )

        Spacer(modifier = Modifier.weight(1f))

        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            OutlinedButton(
                onClick = { navController.popBackStack() },
                modifier = Modifier.weight(1f)
            ) {
                Text("Cancel")
            }
            Button(
                onClick = {
                    viewModel.updateUserName(editedName)
                    croppedImageUri?.let { viewModel.saveProfilePictureUri(it) }
                    Toast.makeText(context, "Profile updated!", Toast.LENGTH_SHORT).show()
                    navController.popBackStack()
                },
                modifier = Modifier.weight(1f),
                enabled = editedName.isNotBlank()
            ) {
                Text("Save")
            }
        }
    }
}

/**
 * Helper function to create the crop options for the image cropper.
 */
private fun createCropOptions(toolbarColor: Int, toolbarTintColor: Int, activityBackgroundColor: Int): CropImageOptions {
    return CropImageOptions(
        cropShape = CropImageView.CropShape.OVAL,
        aspectRatioX = 1,
        aspectRatioY = 1,
        fixAspectRatio = true,
        outputCompressQuality = 70,
        imageSourceIncludeGallery = false, // We handle this ourselves now
        imageSourceIncludeCamera = false, // We handle this ourselves now
        activityTitle = "Crop Profile Picture",
        activityMenuIconColor = toolbarTintColor,
        toolbarColor = toolbarColor,
        toolbarBackButtonColor = toolbarTintColor,
        activityBackgroundColor = activityBackgroundColor
    )
}

/**
 * Helper function to create a temporary image file in the app's external files directory.
 */
private fun createTempImageFile(context: Context): File {
    // --- FIX: Use the external files directory for better compatibility with the camera intent ---
    val timeStamp: String = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())
    val storageDir: File? = context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)
    return File.createTempFile(
        "JPEG_${timeStamp}_",
        ".jpg",
        storageDir
    )
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/RecurringTransactionScreens.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/RecurringTransactionScreens.kt
// REASON: FEATURE - The UI has been updated to support rule management. Each
// item now has "Edit" and "Delete" icon buttons. Tapping "Edit" navigates to
// the Add/Edit screen with the rule's ID, and tapping "Delete" shows a
// confirmation dialog before removing the rule.
// BUG FIX - Added the missing isDark() helper function to resolve compilation errors.
// ANIMATION - Added `animateItemPlacement()` to the RecurringTransactionItem
// in the LazyColumn. This makes the list fluidly animate changes when rules
// are added or removed.
// =================================================================================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import io.pm.finlight.*
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight
import java.text.NumberFormat
import java.util.*

private fun Color.isDark() = (red * 0.299 + green * 0.587 + blue * 0.114) < 0.5

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun RecurringTransactionScreen(navController: NavController) {
    val viewModel: RecurringTransactionViewModel = viewModel()
    val recurringTransactions by viewModel.allRecurringTransactions.collectAsState(initial = emptyList())
    var ruleToDelete by remember { mutableStateOf<RecurringTransaction?>(null) }

    if (recurringTransactions.isEmpty()) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(16.dp),
            contentAlignment = Alignment.Center
        ) {
            Text(
                "No recurring transactions set up. Tap the '+' to add one.",
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    } else {
        LazyColumn(
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            items(recurringTransactions, key = { it.id }) { rule ->
                RecurringTransactionItem(
                    modifier = Modifier.animateItemPlacement(),
                    rule = rule,
                    onEditClick = {
                        navController.navigate("add_recurring_transaction?ruleId=${rule.id}")
                    },
                    onDeleteClick = {
                        ruleToDelete = rule
                    }
                )
            }
        }
    }

    ruleToDelete?.let { rule ->
        val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
        val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight
        AlertDialog(
            onDismissRequest = { ruleToDelete = null },
            title = { Text("Delete Rule?") },
            text = { Text("Are you sure you want to delete the rule for '${rule.description}'? This cannot be undone.") },
            confirmButton = {
                Button(
                    onClick = {
                        viewModel.deleteRule(rule)
                        ruleToDelete = null
                    },
                    colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
                ) { Text("Delete") }
            },
            dismissButton = {
                TextButton(onClick = { ruleToDelete = null }) { Text("Cancel") }
            },
            containerColor = popupContainerColor
        )
    }
}

@Composable
private fun RecurringTransactionItem(
    modifier: Modifier = Modifier,
    rule: RecurringTransaction,
    onEditClick: () -> Unit,
    onDeleteClick: () -> Unit
) {
    val currencyFormat = remember { NumberFormat.getCurrencyInstance(Locale("en", "IN")) }
    val amountColor = if (rule.transactionType == "expense") {
        MaterialTheme.colorScheme.error
    } else {
        MaterialTheme.colorScheme.primary
    }

    GlassPanel(modifier = modifier.fillMaxWidth()) {
        Row(
            modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = rule.description,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onSurface
                )
                Text(
                    text = "Repeats ${rule.recurrenceInterval}",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            Spacer(Modifier.width(8.dp))
            Text(
                text = currencyFormat.format(rule.amount),
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold,
                color = amountColor
            )
            IconButton(onClick = onEditClick) {
                Icon(Icons.Default.Edit, contentDescription = "Edit Rule", tint = MaterialTheme.colorScheme.onSurfaceVariant)
            }
            IconButton(onClick = onDeleteClick) {
                Icon(Icons.Default.Delete, contentDescription = "Delete Rule", tint = MaterialTheme.colorScheme.error)
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/SearchScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/SearchScreen.kt
// REASON: Modernized the UI by implementing auto-focus for the keyword field
// and removing the now-obsolete "Apply Filter" button, creating a more
// dynamic and responsive search experience.
// UPDATE: Redesigned the layout to hide advanced filters in a collapsible
// section, providing a cleaner initial view and an indicator for active filters.
// UPDATE: The filter section has been redesigned to use a GlassPanel, aligning
// it with the "Project Aurora" aesthetic for a consistent and modern look.
// FIX: Applied a semi-opaque background to the filter dropdown menus to ensure
// legibility and consistency with other popups in dark mode.
// ANIMATION - The filter section is now wrapped in an AnimatedVisibility with
// a fast, non-fading animation spec (`expandVertically` and `shrinkVertically`).
// This makes showing/hiding the filters feel much snappier.
// =================================================================================
package io.pm.finlight.ui.screens

import android.app.Application
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.core.tween
import androidx.compose.animation.expandVertically
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Clear
import androidx.compose.material.icons.filled.DateRange
import androidx.compose.material.icons.filled.FilterList
import androidx.compose.material.icons.filled.KeyboardArrowDown
import androidx.compose.material.icons.filled.KeyboardArrowUp
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import io.pm.finlight.*
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.components.TransactionItem
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SearchScreen(navController: NavController) {
    val context = LocalContext.current
    val factory = SearchViewModelFactory(context.applicationContext as Application)
    val viewModel: SearchViewModel = viewModel(factory = factory)

    val searchUiState by viewModel.uiState.collectAsState()
    val searchResults by viewModel.searchResults.collectAsState()

    var showStartDatePicker by remember { mutableStateOf(false) }
    var showEndDatePicker by remember { mutableStateOf(false) }
    var showFilters by remember { mutableStateOf(false) }

    val focusRequester = remember { FocusRequester() }
    val dateFormatter = SimpleDateFormat("dd/MM/yyyy", Locale.getDefault())

    Column(modifier = Modifier.fillMaxSize()) {
        // Search Bar and Filter Section
        Column(modifier = Modifier.padding(16.dp)) {
            OutlinedTextField(
                value = searchUiState.keyword,
                onValueChange = { viewModel.onKeywordChange(it) },
                label = { Text("Keyword (description, notes)") },
                modifier = Modifier
                    .fillMaxWidth()
                    .focusRequester(focusRequester),
                singleLine = true
            )

            Spacer(modifier = Modifier.height(16.dp))

            // --- UPDATE: Filters are now inside a collapsible GlassPanel ---
            GlassPanel {
                Column {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable { showFilters = !showFilters }
                            .padding(16.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            Icons.Default.FilterList,
                            contentDescription = "Filters",
                            tint = MaterialTheme.colorScheme.primary
                        )
                        Spacer(Modifier.width(8.dp))
                        Text(
                            "Filters",
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.onSurface,
                            modifier = Modifier.weight(1f)
                        )
                        Icon(
                            imageVector = if (showFilters) Icons.Default.KeyboardArrowUp else Icons.Default.KeyboardArrowDown,
                            contentDescription = if (showFilters) "Collapse Filters" else "Expand Filters",
                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }

                    AnimatedVisibility(
                        visible = showFilters,
                        enter = expandVertically(animationSpec = tween(200)),
                        exit = shrinkVertically(animationSpec = tween(200))
                    ) {
                        Column(
                            modifier = Modifier.padding(start = 16.dp, end = 16.dp, bottom = 16.dp),
                            verticalArrangement = Arrangement.spacedBy(12.dp)
                        ) {
                            HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                            SearchableDropdown(
                                label = "Account",
                                options = searchUiState.accounts,
                                selectedOption = searchUiState.selectedAccount,
                                onOptionSelected = { viewModel.onAccountChange(it) },
                                getDisplayName = { it.name },
                            )
                            SearchableDropdown(
                                label = "Category",
                                options = searchUiState.categories,
                                selectedOption = searchUiState.selectedCategory,
                                onOptionSelected = { viewModel.onCategoryChange(it) },
                                getDisplayName = { it.name },
                            )
                            SearchableDropdown(
                                label = "Transaction Type",
                                options = listOf("All", "Income", "Expense"),
                                selectedOption = searchUiState.transactionType.replaceFirstChar { it.uppercase() },
                                onOptionSelected = { viewModel.onTypeChange(it) },
                                getDisplayName = { it },
                            )
                            Row(
                                modifier = Modifier.fillMaxWidth(),
                                horizontalArrangement = Arrangement.spacedBy(8.dp),
                            ) {
                                DateTextField(
                                    label = "Start Date",
                                    date = searchUiState.startDate,
                                    formatter = dateFormatter,
                                    onClick = { showStartDatePicker = true },
                                    onClear = { viewModel.onDateChange(start = null) },
                                    modifier = Modifier.weight(1f),
                                )
                                DateTextField(
                                    label = "End Date",
                                    date = searchUiState.endDate,
                                    formatter = dateFormatter,
                                    onClick = { showEndDatePicker = true },
                                    onClear = { viewModel.onDateChange(end = null) },
                                    modifier = Modifier.weight(1f),
                                )
                            }
                            OutlinedButton(
                                onClick = { viewModel.clearFilters() },
                                modifier = Modifier.fillMaxWidth(),
                            ) { Text("Clear All Filters") }
                        }
                    }
                }
            }
        }

        HorizontalDivider()

        // Search Results
        if (searchResults.isNotEmpty()) {
            LazyColumn(
                modifier = Modifier.weight(1f),
                contentPadding = PaddingValues(16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                item {
                    Text(
                        text = "Results (${searchResults.size})",
                        style = MaterialTheme.typography.titleMedium,
                        color = MaterialTheme.colorScheme.onSurface,
                        modifier = Modifier.padding(bottom = 8.dp),
                    )
                }
                items(searchResults) { transactionDetails ->
                    TransactionItem(
                        transactionDetails = transactionDetails,
                        onClick = { navController.navigate("transaction_detail/${transactionDetails.transaction.id}") },
                    )
                }
            }
        } else if (searchUiState.hasSearched) {
            Box(
                modifier = Modifier
                    .weight(1f)
                    .fillMaxWidth(),
                contentAlignment = Alignment.Center
            ) {
                Text("No transactions match your criteria.")
            }
        }
    }

    LaunchedEffect(Unit) {
        focusRequester.requestFocus()
    }

    if (showStartDatePicker) {
        val datePickerState = rememberDatePickerState(initialSelectedDateMillis = searchUiState.startDate)
        DatePickerDialog(
            onDismissRequest = { showStartDatePicker = false },
            confirmButton = {
                TextButton(onClick = {
                    viewModel.onDateChange(start = datePickerState.selectedDateMillis)
                    showStartDatePicker = false
                }) { Text("OK") }
            },
            dismissButton = {
                TextButton(onClick = { showStartDatePicker = false }) { Text("Cancel") }
            },
        ) {
            DatePicker(state = datePickerState)
        }
    }

    if (showEndDatePicker) {
        val datePickerState = rememberDatePickerState(initialSelectedDateMillis = searchUiState.endDate)
        DatePickerDialog(
            onDismissRequest = { showEndDatePicker = false },
            confirmButton = {
                TextButton(onClick = {
                    viewModel.onDateChange(end = datePickerState.selectedDateMillis)
                    showEndDatePicker = false
                }) { Text("OK") }
            },
            dismissButton = {
                TextButton(onClick = { showEndDatePicker = false }) { Text("Cancel") }
            },
        ) {
            DatePicker(state = datePickerState)
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun <T> SearchableDropdown(
    label: String,
    options: List<T>,
    selectedOption: T?,
    onOptionSelected: (T?) -> Unit,
    getDisplayName: (T) -> String,
) {
    var expanded by remember { mutableStateOf(false) }

    ExposedDropdownMenuBox(
        expanded = expanded,
        onExpandedChange = { expanded = !expanded },
    ) {
        OutlinedTextField(
            value = selectedOption?.let { getDisplayName(it) } ?: "All",
            onValueChange = {},
            readOnly = true,
            label = { Text(label) },
            trailingIcon = {
                Row {
                    if (selectedOption != null) {
                        IconButton(onClick = { onOptionSelected(null) }) {
                            Icon(Icons.Default.Clear, contentDescription = "Clear selection")
                        }
                    }
                    ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded)
                }
            },
            modifier =
                Modifier
                    .menuAnchor()
                    .fillMaxWidth(),
        )
        ExposedDropdownMenu(
            expanded = expanded,
            onDismissRequest = { expanded = false },
            // --- FIX: Apply a background to the dropdown menu for better legibility ---
            modifier = Modifier.background(
                if (isSystemInDarkTheme()) PopupSurfaceDark else PopupSurfaceLight
            )
        ) {
            options.forEach { option ->
                DropdownMenuItem(
                    text = { Text(getDisplayName(option)) },
                    onClick = {
                        onOptionSelected(option)
                        expanded = false
                    },
                )
            }
        }
    }
}

@Composable
fun DateTextField(
    label: String,
    date: Long?,
    formatter: SimpleDateFormat,
    onClick: () -> Unit,
    onClear: () -> Unit,
    modifier: Modifier = Modifier,
) {
    OutlinedTextField(
        value = date?.let { formatter.format(Date(it)) } ?: "",
        onValueChange = {},
        readOnly = true,
        label = { Text(label) },
        modifier = modifier.clickable(onClick = onClick),
        trailingIcon = {
            if (date != null) {
                IconButton(onClick = onClear) {
                    Icon(Icons.Default.Clear, "Clear Date")
                }
            } else {
                Icon(Icons.Default.DateRange, "Select Date")
            }
        },
    )
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/CsvValidationScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/CsvValidationScreen.kt
// REASON: MAJOR REFACTOR - This screen has been completely redesigned to align
// with the "Project Aurora" vision. The standard Card for each row has been
// replaced with a GlassPanel component. The status is now indicated by a
// colored icon for a cleaner look, and all text and component colors are
// theme-aware to ensure high contrast and a cohesive, modern experience.
// =================================================================================
package io.pm.finlight.ui.screens

import android.widget.Toast
import androidx.compose.foundation.clickable
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.livedata.observeAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import io.pm.finlight.*
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight
import kotlinx.coroutines.launch
import java.net.URLEncoder

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CsvValidationScreen(
    navController: NavController,
    viewModel: SettingsViewModel
) {
    val report by viewModel.csvValidationReport.collectAsState()
    val context = LocalContext.current
    val scope = rememberCoroutineScope()

    val backStackEntry = navController.currentBackStackEntry
    val updatedRowJsonState = backStackEntry?.savedStateHandle?.getLiveData<String>("corrected_row")?.observeAsState()

    LaunchedEffect(updatedRowJsonState?.value) {
        val json = updatedRowJsonState?.value
        val line = backStackEntry?.savedStateHandle?.get<Int>("corrected_row_line")
        if (json != null && line != null) {
            val gson = Gson()
            val correctedData: List<String> = gson.fromJson(json, object : TypeToken<List<String>>() {}.type)
            viewModel.updateAndRevalidateRow(line, correctedData)
            backStackEntry.savedStateHandle.remove<String>("corrected_row")
            backStackEntry.savedStateHandle.remove<Int>("corrected_row_line")
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Review CSV Import") },
                navigationIcon = {
                    IconButton(onClick = {
                        viewModel.clearCsvValidationReport()
                        navController.popBackStack()
                    }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back")
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent)
            )
        },
        bottomBar = {
            val importableRowCount = report?.reviewableRows?.count {
                it.status == CsvRowStatus.VALID ||
                        it.status == CsvRowStatus.NEEDS_ACCOUNT_CREATION ||
                        it.status == CsvRowStatus.NEEDS_CATEGORY_CREATION ||
                        it.status == CsvRowStatus.NEEDS_BOTH_CREATION
            } ?: 0

            Surface(shadowElevation = 8.dp, color = MaterialTheme.colorScheme.surface.copy(alpha = 0.5f)) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp)
                        .navigationBarsPadding(),
                    horizontalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    OutlinedButton(onClick = {
                        viewModel.clearCsvValidationReport()
                        navController.popBackStack()
                    }, modifier = Modifier.weight(1f)) { Text("Cancel") }

                    Button(
                        onClick = {
                            scope.launch {
                                val rowsToImport = report?.reviewableRows?.filter {
                                    it.status != CsvRowStatus.INVALID_AMOUNT &&
                                            it.status != CsvRowStatus.INVALID_DATE &&
                                            it.status != CsvRowStatus.INVALID_COLUMN_COUNT
                                }
                                if (!rowsToImport.isNullOrEmpty()) {
                                    viewModel.commitCsvImport(rowsToImport)
                                    Toast.makeText(context, "$importableRowCount transactions imported!", Toast.LENGTH_LONG).show()
                                    navController.navigate("dashboard") { popUpTo(0) }
                                }
                            }
                        },
                        modifier = Modifier.weight(1f),
                        enabled = importableRowCount > 0
                    ) { Text("Import ($importableRowCount)") }
                }
            }
        },
        containerColor = Color.Transparent
    ) { innerPadding ->
        val currentReport = report
        if (currentReport == null) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(innerPadding),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        } else {
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(innerPadding),
                contentPadding = PaddingValues(16.dp),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                item {
                    Text(
                        "Validation Complete",
                        style = MaterialTheme.typography.headlineSmall,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.onSurface
                    )
                    Text(
                        "Tap a row to edit it, or use the trash icon to ignore it.",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }

                items(currentReport.reviewableRows, key = { it.lineNumber }) { row ->
                    EditableRowItem(
                        row = row,
                        onEditClick = {
                            val gson = Gson()
                            val rowDataJson = gson.toJson(row.rowData)
                            val encodedJson = URLEncoder.encode(rowDataJson, "UTF-8")
                            navController.navigate("add_transaction?isCsvEdit=true&csvLineNumber=${row.lineNumber}&initialDataJson=$encodedJson")
                        },
                        onDeleteClick = {
                            viewModel.removeRowFromReport(row)
                        }
                    )
                }
            }
        }
    }
}

@Composable
fun EditableRowItem(row: ReviewableRow, onEditClick: () -> Unit, onDeleteClick: () -> Unit) {
    val statusColor = when (row.status) {
        CsvRowStatus.VALID -> MaterialTheme.colorScheme.primary
        CsvRowStatus.NEEDS_ACCOUNT_CREATION, CsvRowStatus.NEEDS_CATEGORY_CREATION, CsvRowStatus.NEEDS_BOTH_CREATION -> MaterialTheme.colorScheme.secondary
        else -> MaterialTheme.colorScheme.error
    }
    val icon = when (row.status) {
        CsvRowStatus.VALID -> Icons.Default.CheckCircle
        CsvRowStatus.NEEDS_ACCOUNT_CREATION, CsvRowStatus.NEEDS_CATEGORY_CREATION, CsvRowStatus.NEEDS_BOTH_CREATION -> Icons.Default.AddCircle
        else -> Icons.Default.Warning
    }

    GlassPanel(modifier = Modifier.fillMaxWidth()) {
        Row(
            modifier = Modifier
                .padding(start = 16.dp)
                .clickable(onClick = onEditClick),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = icon,
                contentDescription = "Status",
                tint = statusColor,
                modifier = Modifier.padding(end = 16.dp)
            )
            Column(
                modifier = Modifier
                    .weight(1f)
                    .padding(vertical = 16.dp)
            ) {
                Text(
                    "Line ${row.lineNumber}: ${row.rowData.getOrNull(1) ?: "N/A"}",
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onSurface
                )
                Spacer(Modifier.height(4.dp))
                Text(
                    row.statusMessage,
                    style = MaterialTheme.typography.bodySmall,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            IconButton(onClick = onDeleteClick) {
                Icon(Icons.Default.Delete, contentDescription = "Ignore this row", tint = MaterialTheme.colorScheme.error)
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/ManageParseRulesScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/ManageParseRulesScreen.kt
// REASON: MAJOR REFACTOR - The screen has been redesigned to align with the
// "Project Aurora" vision. The standard Card has been replaced with a GlassPanel
// component, and all text colors have been updated to be theme-aware, ensuring
// a consistent, high-contrast experience.
// BUG FIX - The AlertDialog now correctly derives its background color from
// the app's MaterialTheme, ensuring it matches the selected theme (e.g.,
// Aurora) instead of defaulting to the system's light/dark mode.
// ANIMATION - Added `animateItemPlacement()` to the RuleItemCard in the
// LazyColumn. This makes the list fluidly animate changes when rules are
// added or removed.
// =================================================================================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import io.pm.finlight.CustomSmsRule
import io.pm.finlight.ManageParseRulesViewModel
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight

// Helper function to determine if a color is 'dark' based on luminance.
private fun Color.isDark() = (red * 0.299 + green * 0.587 + blue * 0.114) < 0.5

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun ManageParseRulesScreen(
    navController: NavController,
    viewModel: ManageParseRulesViewModel = viewModel()
) {
    val rules by viewModel.allRules.collectAsState()
    var ruleToDelete by remember { mutableStateOf<CustomSmsRule?>(null) }

    if (rules.isEmpty()) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(16.dp),
            contentAlignment = Alignment.Center
        ) {
            Text(
                "No custom parsing rules have been created yet.",
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    } else {
        LazyColumn(
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            items(rules, key = { it.id }) { rule ->
                RuleItemCard(
                    modifier = Modifier.animateItemPlacement(),
                    rule = rule,
                    onEditClick = {
                        navController.navigate("rule_creation_screen?ruleId=${rule.id}")
                    },
                    onDeleteClick = { ruleToDelete = rule }
                )
            }
        }
    }

    if (ruleToDelete != null) {
        val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
        val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

        AlertDialog(
            onDismissRequest = { ruleToDelete = null },
            title = { Text("Delete Rule?") },
            text = { Text("Are you sure you want to delete this parsing rule? This action cannot be undone.") },
            confirmButton = {
                Button(
                    onClick = {
                        viewModel.deleteRule(ruleToDelete!!)
                        ruleToDelete = null
                    },
                    colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
                ) {
                    Text("Delete")
                }
            },
            dismissButton = {
                TextButton(onClick = { ruleToDelete = null }) {
                    Text("Cancel")
                }
            },
            containerColor = popupContainerColor
        )
    }
}

@Composable
private fun RuleItemCard(
    modifier: Modifier = Modifier,
    rule: CustomSmsRule,
    onEditClick: () -> Unit,
    onDeleteClick: () -> Unit
) {
    GlassPanel(
        modifier = modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier.padding(horizontal = 24.dp, vertical = 16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = rule.triggerPhrase,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    modifier = Modifier.weight(1f),
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis,
                    color = MaterialTheme.colorScheme.onSurface
                )
                IconButton(onClick = onEditClick) {
                    Icon(
                        Icons.Default.Edit,
                        contentDescription = "Edit Rule",
                        tint = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
                IconButton(onClick = onDeleteClick) {
                    Icon(
                        Icons.Default.Delete,
                        contentDescription = "Delete Rule",
                        tint = MaterialTheme.colorScheme.error
                    )
                }
            }
            HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                rule.merchantNameExample?.let {
                    RuleDetailRow(label = "Merchant Name", value = it)
                }
                rule.amountExample?.let {
                    RuleDetailRow(label = "Amount", value = it)
                }
                rule.accountNameExample?.let {
                    RuleDetailRow(label = "Account Info", value = it)
                }
            }
        }
    }
}

@Composable
private fun RuleDetailRow(label: String, value: String) {
    Column {
        Text(
            text = label,
            style = MaterialTheme.typography.labelMedium,
            color = MaterialTheme.colorScheme.primary,
            fontWeight = FontWeight.Bold
        )
        Text(
            text = value,
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/IncomeScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/IncomeScreen.kt
// REASON: MAJOR REFACTOR - The `IncomeHeader` has been updated to align with the
// "Project Aurora" vision. The standard `Card` has been replaced with a `GlassPanel`
// component, and all text colors are now theme-aware, ensuring a cohesive,
// modern, and high-contrast user experience for the income screen.
// =================================================================================
package io.pm.finlight.ui.screens

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.expandVertically
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.pager.HorizontalPager
import androidx.compose.foundation.pager.rememberPagerState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material.icons.filled.ArrowDropUp
import androidx.compose.material.icons.filled.FilterList
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import io.pm.finlight.IncomeViewModel
import io.pm.finlight.MonthlySummaryItem
import io.pm.finlight.ui.components.FilterBottomSheet
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.components.TransactionList
import io.pm.finlight.ui.components.pagerTabIndicatorOffset
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalFoundationApi::class, ExperimentalMaterial3Api::class)
@Composable
fun IncomeScreen(
    navController: NavController,
    viewModel: IncomeViewModel = viewModel(),
) {
    val tabs = listOf("Credits", "Categories")
    val pagerState = rememberPagerState { tabs.size }
    val scope = rememberCoroutineScope()

    val incomeTransactions by viewModel.incomeTransactionsForSelectedMonth.collectAsState()
    val incomeByCategory by viewModel.incomeByCategoryForSelectedMonth.collectAsState()
    val totalIncome by viewModel.totalIncomeForSelectedMonth.collectAsState()
    val selectedMonth by viewModel.selectedMonth.collectAsState()
    val monthlySummaries by viewModel.monthlySummaries.collectAsState()

    val filterState by viewModel.filterState.collectAsState()
    val allAccounts by viewModel.allAccounts.collectAsState()
    val allCategories by viewModel.allCategories.collectAsState(initial = emptyList())
    var showFilterSheet by remember { mutableStateOf(false) }

    val areFiltersActive by remember(filterState) {
        derivedStateOf {
            filterState.keyword.isNotBlank() || filterState.account != null || filterState.category != null
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Income") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                    }
                },
                actions = {
                    BadgedBox(
                        badge = {
                            if (areFiltersActive) {
                                Box(
                                    modifier = Modifier
                                        .size(8.dp)
                                        .clip(CircleShape)
                                        .background(MaterialTheme.colorScheme.primary)
                                )
                            }
                        }
                    ) {
                        IconButton(onClick = { showFilterSheet = true }) {
                            Icon(Icons.Default.FilterList, contentDescription = "Filter Income")
                        }
                    }
                }
            )
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
        ) {
            IncomeHeader(
                totalIncome = totalIncome,
                selectedMonth = selectedMonth,
                monthlySummaries = monthlySummaries,
                onMonthSelected = { viewModel.setSelectedMonth(it) }
            )

            TabRow(
                selectedTabIndex = pagerState.currentPage,
                indicator = { tabPositions ->
                    TabRowDefaults.SecondaryIndicator(
                        Modifier.pagerTabIndicatorOffset(pagerState, tabPositions)
                    )
                }
            ) {
                tabs.forEachIndexed { index, title ->
                    Tab(
                        selected = pagerState.currentPage == index,
                        onClick = {
                            scope.launch {
                                pagerState.animateScrollToPage(index)
                            }
                        },
                        text = { Text(title) }
                    )
                }
            }

            HorizontalPager(
                state = pagerState,
                modifier = Modifier.weight(1f)
            ) { page ->
                when (page) {
                    0 -> TransactionList(transactions = incomeTransactions, navController = navController)
                    1 -> CategorySpendingScreen(spendingList = incomeByCategory)
                }
            }
        }
    }

    if (showFilterSheet) {
        ModalBottomSheet(onDismissRequest = { showFilterSheet = false }) {
            FilterBottomSheet(
                filterState = filterState,
                accounts = allAccounts,
                categories = allCategories,
                onKeywordChange = viewModel::updateFilterKeyword,
                onAccountChange = viewModel::updateFilterAccount,
                onCategoryChange = viewModel::updateFilterCategory,
                onClearFilters = viewModel::clearFilters
            )
        }
    }
}

@Composable
fun IncomeHeader(
    selectedMonth: Calendar,
    monthlySummaries: List<MonthlySummaryItem>,
    totalIncome: Double,
    onMonthSelected: (Calendar) -> Unit
) {
    val monthFormat = SimpleDateFormat("LLL", Locale.getDefault())
    val monthYearFormat = SimpleDateFormat("LLLL yyyy", Locale.getDefault())
    var showMonthScroller by remember { mutableStateOf(false) }

    val selectedTabIndex = monthlySummaries.indexOfFirst {
        it.calendar.get(Calendar.MONTH) == selectedMonth.get(Calendar.MONTH) &&
                it.calendar.get(Calendar.YEAR) == selectedMonth.get(Calendar.YEAR)
    }.coerceAtLeast(0)

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(bottom = 8.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clickable { showMonthScroller = !showMonthScroller }
                .padding(horizontal = 16.dp, vertical = 8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(
                    text = monthYearFormat.format(selectedMonth.time),
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onSurface
                )
                Icon(
                    imageVector = if (showMonthScroller) Icons.Default.ArrowDropUp else Icons.Default.ArrowDropDown,
                    contentDescription = if (showMonthScroller) "Hide month selector" else "Show month selector",
                    tint = MaterialTheme.colorScheme.onSurface
                )
            }
        }

        AnimatedVisibility(
            visible = showMonthScroller,
            enter = expandVertically(),
            exit = shrinkVertically()
        ) {
            ScrollableTabRow(
                selectedTabIndex = selectedTabIndex,
                edgePadding = 16.dp,
                indicator = {},
                divider = {}
            ) {
                monthlySummaries.forEach { summaryItem ->
                    val isSelected = summaryItem.calendar.get(Calendar.MONTH) == selectedMonth.get(Calendar.MONTH) &&
                            summaryItem.calendar.get(Calendar.YEAR) == selectedMonth.get(Calendar.YEAR)
                    Tab(
                        selected = isSelected,
                        onClick = {
                            onMonthSelected(summaryItem.calendar)
                            showMonthScroller = false
                        },
                        text = {
                            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                                Text(
                                    text = monthFormat.format(summaryItem.calendar.time),
                                    style = if (isSelected) MaterialTheme.typography.titleMedium else MaterialTheme.typography.titleSmall,
                                    fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal,
                                    color = MaterialTheme.colorScheme.onSurface
                                )
                                Text(
                                    text = "${"%,.0f".format(summaryItem.totalSpent)}",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = if (isSelected) MaterialTheme.colorScheme.onSurface else MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }
                        }
                    )
                }
            }
        }

        Spacer(Modifier.height(16.dp))

        GlassPanel(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp)
        ) {
            Column(
                modifier = Modifier.padding(16.dp),
                horizontalAlignment = Alignment.Start
            ) {
                Text("Total Income", style = MaterialTheme.typography.labelMedium, color = MaterialTheme.colorScheme.onSurfaceVariant)
                Text(
                    "${"%,.2f".format(totalIncome)}",
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.primary
                )
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/OnboardingScreen.kt ==================
// =================================================================================
// FILE: app/src/main/java/io/pm/finlight/ui/screens/OnboardingScreen.kt
// REASON: BUG FIX - The PagerState is now passed down to the individual page
// composables (`UserNamePage`, `BudgetSetupPage`). This allows each page to
// know when it is the `currentPage` and request focus only when it is active,
// preventing focus from being stolen by off-screen pages.
// =================================================================================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.pager.HorizontalPager
import androidx.compose.foundation.pager.PagerState
import androidx.compose.foundation.pager.rememberPagerState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.unit.dp
import io.pm.finlight.OnboardingViewModel
import kotlinx.coroutines.launch

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun OnboardingScreen(viewModel: OnboardingViewModel, onOnboardingFinished: () -> Unit) {
    val pagerState = rememberPagerState { 7 }
    val scope = rememberCoroutineScope()

    val onNextClicked: () -> Unit = {
        scope.launch {
            pagerState.animateScrollToPage(pagerState.currentPage + 1)
        }
    }

    Scaffold(
        bottomBar = {
            OnboardingBottomBar(
                pagerState = pagerState,
                viewModel = viewModel,
                onNextClicked = onNextClicked,
                onFinishClicked = {
                    viewModel.finishOnboarding()
                    onOnboardingFinished()
                }
            )
        }
    ) { innerPadding ->
        HorizontalPager(
            state = pagerState,
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding),
            userScrollEnabled = false
        ) { page ->
            when (page) {
                0 -> WelcomePage()
                // --- FIX: Pass pagerState to pages that need to manage focus ---
                1 -> UserNamePage(viewModel = viewModel, pagerState = pagerState)
                2 -> BudgetSetupPage(viewModel = viewModel, pagerState = pagerState)
                3 -> SmsPermissionPage(onPermissionResult = onNextClicked)
                4 -> SmsScanningInfoPage()
                5 -> NotificationPermissionPage(onPermissionResult = onNextClicked)
                6 -> CompletionPage()
            }
        }
    }
}

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun OnboardingBottomBar(
    pagerState: PagerState,
    viewModel: OnboardingViewModel,
    onNextClicked: () -> Unit,
    onFinishClicked: () -> Unit
) {
    val userName by viewModel.userName.collectAsState()

    Surface(shadowElevation = 8.dp) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp, vertical = 12.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            PageIndicator(pageCount = pagerState.pageCount, currentPage = pagerState.currentPage)

            val isNextButtonVisible = pagerState.currentPage < pagerState.pageCount - 1 &&
                    pagerState.currentPage != 3 && // Hide on SMS Permission Page
                    pagerState.currentPage != 5    // Hide on Notification Permission Page

            val isNextEnabled = if (pagerState.currentPage == 1) {
                userName.isNotBlank()
            } else {
                true
            }

            if (isNextButtonVisible) {
                Button(
                    onClick = onNextClicked,
                    enabled = isNextEnabled
                ) {
                    Text("Next")
                    Icon(Icons.AutoMirrored.Filled.ArrowForward, contentDescription = "Next Page")
                }
            } else if (pagerState.currentPage == pagerState.pageCount - 1) {
                Button(onClick = onFinishClicked) {
                    Text("Finish Setup")
                }
            } else {
                Spacer(modifier = Modifier.width(0.dp))
            }
        }
    }
}

@Composable
fun PageIndicator(pageCount: Int, currentPage: Int) {
    Row(
        horizontalArrangement = Arrangement.spacedBy(8.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        repeat(pageCount) { iteration ->
            val color = if (currentPage == iteration) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f)
            Box(
                modifier = Modifier
                    .size(10.dp)
                    .clip(CircleShape)
                    .background(color)
            )
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/LinkTransactionScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/LinkTransactionScreen.kt
// REASON: FEATURE - The screen now includes an AlertDialog to confirm the user's
// choice before linking. The onClick handler has been updated to show this
// dialog. Upon confirmation, it calls the ViewModel to perform the link, passes
// a signal back to the previous screen to remove the item from the review list,
// and then navigates away, completing the feature's workflow.
// BUG FIX - The AlertDialog now correctly derives its background color from
// the app's MaterialTheme, ensuring it matches the selected theme (e.g.,
// Aurora) instead of defaulting to the system's light/dark mode.
// =================================================================================
package io.pm.finlight.ui.screens

import android.app.Application
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.google.gson.Gson
import io.pm.finlight.LinkTransactionViewModel
import io.pm.finlight.LinkTransactionViewModelFactory
import io.pm.finlight.PotentialTransaction
import io.pm.finlight.Transaction
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight
import java.net.URLDecoder
import java.text.SimpleDateFormat
import java.util.*

// Helper function to determine if a color is 'dark' based on luminance.
private fun Color.isDark() = (red * 0.299 + green * 0.587 + blue * 0.114) < 0.5

@Composable
fun LinkTransactionScreen(
    navController: NavController,
    potentialTransactionJson: String
) {
    val potentialTxn = remember(potentialTransactionJson) {
        Gson().fromJson(URLDecoder.decode(potentialTransactionJson, "UTF-8"), PotentialTransaction::class.java)
    }

    val application = LocalContext.current.applicationContext as Application
    val factory = LinkTransactionViewModelFactory(application, potentialTxn)
    val viewModel: LinkTransactionViewModel = viewModel(factory = factory)

    val candidates by viewModel.linkableTransactions.collectAsState()
    var showConfirmationDialog by remember { mutableStateOf(false) }
    var transactionToLink by remember { mutableStateOf<Transaction?>(null) }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        SmsDetailsCard(potentialTxn)

        Text("Select a transaction to link:", style = MaterialTheme.typography.titleMedium)

        if (candidates.isEmpty()) {
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                Text("No potential matches found.")
            }
        } else {
            LazyColumn(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                items(candidates, key = { it.id }) { transaction ->
                    LinkCandidateItem(
                        transaction = transaction,
                        onClick = {
                            transactionToLink = transaction
                            showConfirmationDialog = true
                        }
                    )
                }
            }
        }
    }

    if (showConfirmationDialog && transactionToLink != null) {
        val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
        val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

        AlertDialog(
            onDismissRequest = { showConfirmationDialog = false },
            title = { Text("Confirm Link") },
            text = { Text("Link this SMS to the transaction for '${transactionToLink!!.description}'?") },
            confirmButton = {
                Button(onClick = {
                    viewModel.linkTransaction(transactionToLink!!.id) {
                        // Pass the ID of the linked SMS back to the review screen
                        navController.previousBackStackEntry
                            ?.savedStateHandle
                            ?.set("linked_sms_id", potentialTxn.sourceSmsId)
                        navController.popBackStack()
                    }
                    showConfirmationDialog = false
                }) {
                    Text("Confirm")
                }
            },
            dismissButton = {
                TextButton(onClick = { showConfirmationDialog = false }) {
                    Text("Cancel")
                }
            },
            containerColor = popupContainerColor
        )
    }
}

@Composable
private fun SmsDetailsCard(pt: PotentialTransaction) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(2.dp)
    ) {
        Column(modifier = Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
            Text("SMS Details", style = MaterialTheme.typography.titleLarge)
            HorizontalDivider()
            Text("Amount: ${"%,.2f".format(pt.amount)}", fontWeight = FontWeight.Bold)
            Text("Type: ${pt.transactionType.replaceFirstChar { it.uppercase() }}")
            Text("Original Message: ${pt.originalMessage}", style = MaterialTheme.typography.bodySmall)
        }
    }
}

@Composable
private fun LinkCandidateItem(transaction: Transaction, onClick: () -> Unit) {
    val dateFormatter = remember { SimpleDateFormat("dd MMM, yyyy", Locale.getDefault()) }
    Card(
        modifier = Modifier.fillMaxWidth(),
        onClick = onClick,
        elevation = CardDefaults.cardElevation(2.dp)
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(transaction.description, style = MaterialTheme.typography.bodyLarge, fontWeight = FontWeight.SemiBold)
                Text(dateFormatter.format(Date(transaction.date)), style = MaterialTheme.typography.bodySmall)
            }
            Text("${"%,.2f".format(transaction.amount)}", style = MaterialTheme.typography.bodyLarge, fontWeight = FontWeight.Bold)
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/ProfileScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/ProfileScreen.kt
// REASON: FEATURE - Added a new "Savings Goals" item to the "General" settings
// section, providing a navigation entry point to the new GoalScreen.
// UPDATE: Reorganized the screen to be more minimalistic. The "General" section
// is now displayed directly, while other sections are moved to separate screens
// accessible via navigation items.
// =================================================================================
package io.pm.finlight.ui.screens

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.core.content.ContextCompat
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import coil.compose.AsyncImage
import io.pm.finlight.*
import io.pm.finlight.R
import io.pm.finlight.ui.components.*
import androidx.compose.ui.unit.dp

@Composable
fun ProfileScreen(
    navController: NavController,
    profileViewModel: ProfileViewModel = viewModel(),
    settingsViewModel: SettingsViewModel
) {
    val userName by profileViewModel.userName.collectAsState()
    val savedProfilePictureUri by profileViewModel.profilePictureUri.collectAsState()

    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        item {
            GlassPanel(
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable { navController.navigate("edit_profile") }
            ) {
                Row(
                    modifier = Modifier.padding(16.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    AsyncImage(
                        model = savedProfilePictureUri,
                        contentDescription = "User Profile Picture",
                        placeholder = painterResource(id = R.drawable.ic_launcher_foreground),
                        error = painterResource(id = R.drawable.ic_launcher_foreground),
                        contentScale = ContentScale.Crop,
                        modifier = Modifier
                            .size(64.dp)
                            .clip(CircleShape)
                            .background(MaterialTheme.colorScheme.surfaceVariant)
                            .border(2.dp, MaterialTheme.colorScheme.primary, CircleShape)
                    )
                    Spacer(modifier = Modifier.width(16.dp))
                    Column(modifier = Modifier.weight(1f)) {
                        Text(userName, style = MaterialTheme.typography.titleLarge, color = MaterialTheme.colorScheme.onSurface)
                        Text("Edit Profile", style = MaterialTheme.typography.bodyMedium, color = MaterialTheme.colorScheme.onSurfaceVariant)
                    }
                    Icon(
                        imageVector = Icons.Default.Edit,
                        contentDescription = "Edit Profile",
                        tint = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }
        }

        item {
            SettingsSection(title = "General") {
                SettingsActionItem(
                    text = "Manage Accounts",
                    subtitle = "View, add, or edit your financial accounts",
                    icon = Icons.Default.AccountBalanceWallet,
                    onClick = { navController.navigate("account_list") },
                )
                HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                SettingsActionItem(
                    text = "Manage Categories",
                    subtitle = "Add, edit, or remove transaction categories",
                    icon = Icons.Default.Category,
                    onClick = { navController.navigate("category_list") },
                )
                HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                SettingsActionItem(
                    text = "Manage Budgets",
                    subtitle = "Set and edit your monthly budgets",
                    icon = Icons.Default.Savings,
                    onClick = { navController.navigate("budget_screen") },
                )
                HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                SettingsActionItem(
                    text = "Savings Goals",
                    subtitle = "Set and track your savings goals",
                    icon = Icons.Default.TrackChanges,
                    onClick = { navController.navigate("goals_screen") },
                )
                HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                SettingsActionItem(
                    text = "Manage Recurring Rules",
                    subtitle = "Automate your regular bills and income",
                    icon = Icons.Default.Autorenew,
                    onClick = { navController.navigate("recurring_transactions") },
                )
                HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                SettingsActionItem(
                    text = "Manage Tags",
                    subtitle = "Create and organize custom tags",
                    icon = Icons.Default.NewLabel,
                    onClick = { navController.navigate("tag_management") },
                )
            }
        }

        item {
            SettingsSection(title = "Preferences") {
                SettingsActionItem(
                    text = "Theme & Appearance",
                    subtitle = "Change the look and feel of the app",
                    icon = Icons.Default.Palette,
                    onClick = { navController.navigate("appearance_settings") }
                )
                HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                SettingsActionItem(
                    text = "Automation",
                    subtitle = "Manage SMS parsing and rules",
                    icon = Icons.Default.AutoAwesome,
                    onClick = { navController.navigate("automation_settings") }
                )
                HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                SettingsActionItem(
                    text = "Notifications",
                    subtitle = "Control reminders and summaries",
                    icon = Icons.Default.Notifications,
                    onClick = { navController.navigate("notification_settings") }
                )
                HorizontalDivider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f))
                SettingsActionItem(
                    text = "Security & Data",
                    subtitle = "Manage app lock, backups, and import/export",
                    icon = Icons.Default.Security,
                    onClick = { navController.navigate("data_settings") }
                )
            }
        }
    }
}

private fun hasSmsPermission(context: Context): Boolean {
    return ContextCompat.checkSelfPermission(context, Manifest.permission.READ_SMS) == PackageManager.PERMISSION_GRANTED
}

@Composable
private fun SettingsSection(
    title: String,
    content: @Composable ColumnScope.() -> Unit
) {
    Column(modifier = Modifier.fillMaxWidth()) {
        Text(
            text = title.uppercase(),
            style = MaterialTheme.typography.labelSmall,
            color = MaterialTheme.colorScheme.primary,
            modifier = Modifier.padding(start = 16.dp, bottom = 8.dp),
        )
        GlassPanel {
            Column {
                content()
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/ReportsScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/ReportsScreen.kt
// REASON: REFACTOR - The "Daily Report" navigation card has been removed from
// this screen. This report is now only accessible via its daily notification,
// as per the user's request to declutter the main reports interface.
// =================================================================================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CalendarViewMonth
import androidx.compose.material.icons.filled.CalendarViewWeek
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.github.mikephil.charting.charts.PieChart
import io.pm.finlight.*
import io.pm.finlight.ui.components.ChartLegend
import io.pm.finlight.ui.components.GlassPanel
import io.pm.finlight.ui.components.GroupedBarChart

@Composable
fun ReportsScreen(
    navController: NavController,
    viewModel: ReportsViewModel = viewModel(),
) {
    val pieData by viewModel.spendingByCategoryPieData.collectAsState(initial = null)
    val trendDataPair by viewModel.monthlyTrendData.collectAsState(initial = null)
    val pieChartLabelColor = MaterialTheme.colorScheme.onSurface.toArgb()

    LazyColumn(
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        item {
            Text(
                "Spending Reports",
                style = MaterialTheme.typography.titleMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
        // --- REMOVED: The Daily Report card is no longer shown here. ---
        item {
            GlassReportNavigationCard(
                title = "Weekly Report",
                subtitle = "Analyze your spending week by week.",
                icon = Icons.Default.CalendarViewWeek,
                onClick = { navController.navigate("time_period_report_screen/${TimePeriod.WEEKLY}") }
            )
        }
        item {
            GlassReportNavigationCard(
                title = "Monthly Report",
                subtitle = "Get a high-level overview of your monthly habits.",
                icon = Icons.Default.CalendarViewMonth,
                onClick = { navController.navigate("time_period_report_screen/${TimePeriod.MONTHLY}") }
            )
        }

        item {
            Spacer(Modifier.height(8.dp))
            Text(
                "Analysis",
                style = MaterialTheme.typography.titleMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }

        item {
            GlassPanel(modifier = Modifier.fillMaxWidth()) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(
                        "Spending by Category for ${viewModel.monthYear}",
                        style = MaterialTheme.typography.titleLarge,
                        color = MaterialTheme.colorScheme.onSurface
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                    if (pieData == null || pieData?.entryCount == 0) {
                        Box(
                            modifier = Modifier
                                .fillMaxWidth()
                                .height(300.dp),
                            contentAlignment = Alignment.Center
                        ) {
                            Text(
                                "No expense data for this month.",
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                    } else {
                        AndroidView(
                            factory = { context ->
                                PieChart(context).apply {
                                    description.isEnabled = false
                                    isDrawHoleEnabled = true
                                    setHoleColor(android.graphics.Color.TRANSPARENT)
                                    setEntryLabelColor(pieChartLabelColor)
                                    setEntryLabelTextSize(12f)
                                    legend.isEnabled = false
                                }
                            },
                            update = { chart ->
                                chart.data = pieData
                                chart.invalidate()
                            },
                            modifier = Modifier
                                .fillMaxWidth()
                                .height(300.dp),
                        )
                        Spacer(modifier = Modifier.height(16.dp))
                        ChartLegend(pieData)
                    }
                }
            }
        }

        item {
            GlassPanel(modifier = Modifier.fillMaxWidth()) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(
                        "Income vs. Expense Trend",
                        style = MaterialTheme.typography.titleLarge,
                        color = MaterialTheme.colorScheme.onSurface
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                    if (trendDataPair != null && trendDataPair!!.first.entryCount > 0) {
                        GroupedBarChart(trendDataPair!!)
                    } else {
                        Box(
                            modifier = Modifier
                                .fillMaxWidth()
                                .height(250.dp),
                            contentAlignment = Alignment.Center
                        ) {
                            Text(
                                "Not enough data for trend analysis.",
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun GlassReportNavigationCard(
    title: String,
    subtitle: String,
    icon: ImageVector,
    onClick: () -> Unit
) {
    GlassPanel(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick)
    ) {
        Row(
            modifier = Modifier.padding(horizontal = 24.dp, vertical = 16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Icon(
                imageVector = icon,
                contentDescription = title,
                modifier = Modifier.size(28.dp),
                tint = MaterialTheme.colorScheme.primary
            )
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = title,
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.onSurface
                )
                Text(
                    text = subtitle,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/components/AnimatedCircle.kt ==================
package io.pm.finlight.ui.components

import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color

/**
 * Data class to hold the properties of each animated circle for background effects.
 * This is marked as 'internal' to be accessible within the 'app' module.
 *
 * @param color The base color of the circle.
 * @param baseRadiusMultiplier The radius of the circle as a multiplier of the canvas's max dimension.
 * @param baseCenter The center of the circle as a fraction of the canvas's width and height.
 * @param speedMultiplier A multiplier to vary the animation speed of each circle.
 */
internal data class AnimatedCircle(
    val color: Color,
    val baseRadiusMultiplier: Float,
    val baseCenter: Offset,
    val speedMultiplier: Float
)-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/components/AuroraAnimatedBackground.kt ==================
package io.pm.finlight.ui.components

import androidx.compose.animation.core.*
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import kotlin.math.sin

/**
 * A composable that renders a slow, gently moving aurora-like background effect.
 * It uses an infinite transition to animate the properties of several large,
 * blurred, overlapping circles.
 */
@Composable
fun AuroraAnimatedBackground() {
    val transition = rememberInfiniteTransition(label = "AuroraBackgroundTransition")

    // Animate the sine wave over time to create a gentle vertical bobbing motion.
    val time by transition.animateFloat(
        initialValue = 0f,
        targetValue = 2f * Math.PI.toFloat(),
        animationSpec = infiniteRepeatable(
            animation = tween(durationMillis = 30000, easing = LinearEasing),
            repeatMode = RepeatMode.Restart
        ),
        label = "AuroraTime"
    )

    // Define the properties of the circles that will form the aurora.
    val circles = listOf(
        AnimatedCircle(
            color = Color(0xFF8A2BE2), // Deep Purple
            baseRadiusMultiplier = 0.8f,
            baseCenter = Offset(0.2f, 0.2f),
            speedMultiplier = 0.6f
        ),
        AnimatedCircle(
            color = Color(0xFF00008B), // Midnight Blue
            baseRadiusMultiplier = 0.9f,
            baseCenter = Offset(0.8f, 0.3f),
            speedMultiplier = 0.4f
        ),
        AnimatedCircle(
            color = Color(0xFF008080), // Dark Teal
            baseRadiusMultiplier = 1.0f,
            baseCenter = Offset(0.4f, 0.8f),
            speedMultiplier = 0.5f
        ),
        AnimatedCircle(
            color = Color(0xFF4B0082), // Indigo
            baseRadiusMultiplier = 0.7f,
            baseCenter = Offset(0.9f, 0.9f),
            speedMultiplier = 0.7f
        )
    )

    Canvas(modifier = Modifier.fillMaxSize()) {
        circles.forEach { circle ->
            // Calculate the vertical offset using a sine wave for a smooth bobbing effect.
            val yOffset = sin(time * circle.speedMultiplier) * size.height * 0.1f

            // Create a radial gradient brush to simulate a blurred, glowing effect.
            val brush = Brush.radialGradient(
                colors = listOf(circle.color.copy(alpha = 0.3f), Color.Transparent),
                center = Offset(
                    x = circle.baseCenter.x * size.width,
                    y = (circle.baseCenter.y * size.height) + yOffset
                ),
                radius = size.maxDimension * circle.baseRadiusMultiplier
            )

            // Draw the circle onto the canvas.
            drawCircle(
                brush = brush,
                radius = size.maxDimension * circle.baseRadiusMultiplier,
                center = Offset(
                    x = circle.baseCenter.x * size.width,
                    y = (circle.baseCenter.y * size.height) + yOffset
                )
            )
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/components/GlassmorphismComponents.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/components/GlassmorphismComponents.kt
// REASON: FIX - Corrected a @Composable invocation error inside the `Canvas`
// of the `CategoryBudgetGauge`. The primary color is now read from the
// `MaterialTheme` and stored in a variable *before* the Canvas is drawn,
// resolving the issue where a composable function was being called from a
// non-composable context.
// ANIMATION - The duration of the `tween` animations for the hero card stats
// and budget gauges has been reduced from 1500ms to a much snappier 400ms.
// This makes the dashboard data visualizations feel more responsive.
// FIX (Navigation) - Updated the onClick handlers in the AuroraQuickActionsCard
// to use the proper NavOptions (popUpTo, launchSingleTop, restoreState). This
// prevents the back stack from growing when navigating from the dashboard to
// other top-level destinations, fixing a major navigation bug.
// =================================================================================
package io.pm.finlight.ui.components

import androidx.compose.animation.core.EaseOutCubic
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.tween
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.PieChart
import androidx.compose.material.icons.filled.Timeline
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.VerticalDivider
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.*
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.layout.Layout
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.unit.Constraints
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import androidx.navigation.NavGraph.Companion.findStartDestination
import io.pm.finlight.*
import io.pm.finlight.ui.theme.GlassPanelBorder
import androidx.compose.ui.graphics.vector.ImageVector
import java.text.NumberFormat
import java.util.Locale
import kotlin.math.min
import kotlin.math.roundToInt

/**
 * A reusable composable that creates a "glassmorphism" effect panel.
 *
 * @param modifier The modifier to be applied to the panel.
 * @param isCustomizationMode If true, a dashed border is shown.
 * @param content The content to be placed inside the panel.
 */
@Composable
fun GlassPanel(
    modifier: Modifier = Modifier,
    isCustomizationMode: Boolean = false,
    content: @Composable BoxScope.() -> Unit
) {
    val borderModifier = if (isCustomizationMode) {
        Modifier.border(
            width = 1.dp,
            brush = Brush.horizontalGradient(listOf(GlassPanelBorder, GlassPanelBorder.copy(alpha = 0.5f))),
            shape = RoundedCornerShape(24.dp)
        )
    } else {
        Modifier.border(1.dp, GlassPanelBorder, RoundedCornerShape(24.dp))
    }

    val glassFillColor = if (isSystemInDarkTheme()) {
        Color.White.copy(alpha = 0.08f)
    } else {
        Color.Black.copy(alpha = 0.04f)
    }

    Box(
        modifier = modifier
            .clip(RoundedCornerShape(24.dp))
            .background(glassFillColor)
            .then(borderModifier),
        content = content
    )
}

/**
 * The new hero card for the dashboard, displaying the monthly budget status
 * with a visually rich "Aurora" theme and glassmorphism effect.
 *
 * @param totalBudget The total budget for the month.
 * @param amountSpent The amount spent so far in the month.
 * @param amountRemaining The amount remaining in the budget.
 * @param monthYear The name of the current month.
 * @param navController The NavController for navigation.
 */
@Composable
fun DashboardHeroCard(
    totalBudget: Float,
    amountSpent: Float,
    amountRemaining: Float,
    income: Float,
    safeToSpend: Float,
    navController: NavController,
    monthYear: String
) {
    val progress = if (totalBudget > 0) (amountSpent / totalBudget) else 0f
    val animatedProgress by animateFloatAsState(
        targetValue = progress,
        animationSpec = tween(durationMillis = 400, easing = EaseOutCubic),
        label = "BudgetProgressAnimation"
    )

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 16.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(24.dp)
    ) {
        Text(
            text = "Monthly Budget",
            style = MaterialTheme.typography.headlineSmall,
            fontWeight = FontWeight.Bold,
            color = MaterialTheme.colorScheme.onSurface
        )

        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            Text(
                text = buildAnnotatedString {
                    append("Spent in ")
                    withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {
                        append(monthYear)
                    }
                },
                style = MaterialTheme.typography.titleLarge,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
            Text(
                text = "${NumberFormat.getNumberInstance(Locale("en", "IN")).format(amountSpent.toInt())}",
                style = MaterialTheme.typography.displayLarge,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.onSurface
            )
        }

        Column(
            modifier = Modifier.padding(horizontal = 16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            AuroraProgressBar(progress = animatedProgress)
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = "Remaining: ${NumberFormat.getNumberInstance(Locale("en", "IN")).format(amountRemaining.toInt())}",
                    style = MaterialTheme.typography.bodyLarge,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
                Text(
                    text = "Total: ${NumberFormat.getNumberInstance(Locale("en", "IN")).format(totalBudget.toInt())}",
                    style = MaterialTheme.typography.bodyLarge,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }

        HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp, vertical = 0.dp), color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.1f))

        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp),
            horizontalArrangement = Arrangement.SpaceAround
        ) {
            StatItem(label = "Income", amount = income, onClick = { navController.navigate("income_screen") })
            StatItem(label = "Budget", amount = totalBudget, isCurrency = true, onClick = { navController.navigate("budget_screen") })
            StatItem(label = "Safe to Spend", amount = safeToSpend, isPerDay = true)
        }
    }
}

@Composable
private fun StatItem(label: String, amount: Float, isCurrency: Boolean = true, isPerDay: Boolean = false, onClick: (() -> Unit)? = null) {
    val animatedAmount by animateFloatAsState(
        targetValue = amount,
        animationSpec = tween(durationMillis = 400, easing = EaseOutCubic),
        label = "StatItemAnimation"
    )
    val clickableModifier = if (onClick != null) Modifier.clickable(onClick = onClick) else Modifier

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = clickableModifier
    ) {
        Text(
            text = label,
            style = MaterialTheme.typography.labelLarge,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        Row(verticalAlignment = Alignment.CenterVertically) {
            if (isCurrency) {
                Text(
                    text = "",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.onSurface
                )
            }
            Text(
                text = NumberFormat.getNumberInstance(Locale("en", "IN")).format(animatedAmount.toInt()),
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.SemiBold,
                color = MaterialTheme.colorScheme.onSurface
            )
            if (isPerDay) {
                Text(
                    text = "/day",
                    style = MaterialTheme.typography.labelMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.padding(start = 2.dp, top = 4.dp)
                )
            }
        }
    }
}


/**
 * A custom styled Progress Bar that includes a percentage indicator.
 *
 * @param progress The progress to display, from 0.0 to 1.0.
 */
@Composable
private fun AuroraProgressBar(progress: Float) {
    val animatedPercentage = (progress * 100).roundToInt()
    val progressColor = when {
        progress > 0.9 -> MaterialTheme.colorScheme.error
        progress > 0.7 -> MaterialTheme.colorScheme.secondary
        else -> MaterialTheme.colorScheme.primary
    }

    Layout(
        content = {
            Text(
                text = "$animatedPercentage%",
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.onSurface,
                style = MaterialTheme.typography.labelSmall
            )
            Canvas(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(20.dp)
            ) {
                drawRoundRect(
                    color = Color.Black.copy(alpha = 0.2f),
                    size = size,
                    cornerRadius = androidx.compose.ui.geometry.CornerRadius(size.height / 2),
                    style = Stroke(width = 1.dp.toPx()),
                    topLeft = Offset(0f, 1.dp.toPx())
                )
                drawRoundRect(
                    color = Color.White.copy(alpha = 0.1f),
                    size = size,
                    cornerRadius = androidx.compose.ui.geometry.CornerRadius(size.height / 2)
                )

                if (progress > 0) {
                    drawRoundRect(
                        brush = Brush.horizontalGradient(
                            colors = listOf(progressColor.copy(alpha = 0.6f), progressColor)
                        ),
                        size = Size(width = size.width * progress, height = size.height),
                        cornerRadius = androidx.compose.ui.geometry.CornerRadius(size.height / 2)
                    )
                }
            }
        }
    ) { measurables, constraints ->
        val textPlaceable = measurables[0].measure(Constraints())
        val canvasPlaceable = measurables[1].measure(constraints)

        val progressWidth = (canvasPlaceable.width * progress).toInt()
        val textX = (progressWidth - textPlaceable.width / 2).coerceIn(
            0,
            canvasPlaceable.width - textPlaceable.width
        )
        val textY = (canvasPlaceable.height - textPlaceable.height) / 2

        layout(canvasPlaceable.width, canvasPlaceable.height + textPlaceable.height + 4.dp.roundToPx()) {
            canvasPlaceable.placeRelative(0, textPlaceable.height + 4.dp.roundToPx())
            textPlaceable.placeRelative(textX, 0)
        }
    }
}

/**
 * A dashboard card that displays a horizontally scrolling carousel of user accounts.
 *
 * @param accounts The list of accounts with their balances.
 * @param navController The NavController for navigation.
 */
@Composable
fun AccountsCarouselCard(
    accounts: List<AccountWithBalance>,
    navController: NavController
) {
    Column(
        modifier = Modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Text(
            text = "Accounts",
            style = MaterialTheme.typography.titleMedium,
            color = MaterialTheme.colorScheme.onSurface,
            modifier = Modifier.padding(horizontal = 8.dp)
        )
        LazyRow(
            horizontalArrangement = Arrangement.spacedBy(16.dp),
            contentPadding = PaddingValues(horizontal = 4.dp)
        ) {
            items(accounts) { account ->
                AccountItem(account = account, navController = navController)
            }
        }
    }
}

/**
 * An individual item in the AccountsCarouselCard, styled to look like a mini glass credit card.
 *
 * @param account The account data to display.
 * @param navController The NavController for navigation.
 */
@Composable
private fun AccountItem(account: AccountWithBalance, navController: NavController) {
    GlassPanel(
        modifier = Modifier
            .width(180.dp)
            .height(110.dp)
            .clickable { navController.navigate("account_detail/${account.account.id}") }
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(16.dp),
            verticalArrangement = Arrangement.SpaceBetween
        ) {
            Image(
                painter = painterResource(id = BankLogoHelper.getLogoForAccount(account.account.name)),
                contentDescription = "${account.account.name} Logo",
                modifier = Modifier.height(24.dp)
            )
            Column {
                Text(
                    text = account.account.name,
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.SemiBold,
                    color = MaterialTheme.colorScheme.onSurface
                )
                Text(
                    text = "${NumberFormat.getNumberInstance(Locale("en", "IN")).format(account.balance)}",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

/**
 * A dashboard card that displays radial gauges for individual category budgets.
 *
 * @param budgetStatus A list of budgets with their current spending.
 * @param navController The NavController for navigation.
 */
@Composable
fun BudgetWatchCard(
    budgetStatus: List<BudgetWithSpending>,
    navController: NavController
) {
    GlassPanel {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(24.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Text(
                "Budget Watch",
                style = MaterialTheme.typography.titleMedium,
                color = MaterialTheme.colorScheme.onSurface
            )
            if (budgetStatus.isEmpty()) {
                Text(
                    "No category-specific budgets set for this month.",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.padding(vertical = 16.dp)
                )
            } else {
                LazyRow(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(24.dp),
                    contentPadding = PaddingValues(horizontal = 4.dp)
                ) {
                    items(budgetStatus) { budget ->
                        CategoryBudgetGauge(budget = budget, navController = navController)
                    }
                }
            }
        }
    }
}

/**
 * A radial gauge for displaying the status of a single category budget.
 *
 * @param budget The budget data with spending information.
 * @param navController The NavController for navigation.
 */
@Composable
private fun CategoryBudgetGauge(budget: BudgetWithSpending, navController: NavController) {
    val progress = if (budget.budget.amount > 0) (budget.spent / budget.budget.amount).toFloat() else 0f
    val animatedProgress by animateFloatAsState(
        targetValue = progress.coerceIn(0f, 1f),
        animationSpec = tween(400),
        label = "CategoryBudgetGaugeAnimation"
    )
    val remaining = budget.budget.amount - budget.spent

    // --- FIX: Read the color from the theme outside the Canvas scope ---
    val primaryColor = MaterialTheme.colorScheme.primary

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(8.dp),
        modifier = Modifier
            .clickable { navController.navigate("budget_screen") }
            .width(90.dp)
    ) {
        Box(contentAlignment = Alignment.Center, modifier = Modifier.size(80.dp)) {
            Canvas(modifier = Modifier.fillMaxSize()) {
                val strokeWidth = 8.dp.toPx()
                val diameter = min(size.width, size.height) - strokeWidth
                drawArc(
                    color = Color.White.copy(alpha = 0.1f),
                    startAngle = -90f,
                    sweepAngle = 360f,
                    useCenter = false,
                    style = Stroke(width = strokeWidth)
                )
                drawArc(
                    color = primaryColor, // Use the variable here
                    startAngle = -90f,
                    sweepAngle = 360 * animatedProgress,
                    useCenter = false,
                    style = Stroke(width = strokeWidth, cap = StrokeCap.Round)
                )
            }
            Icon(
                imageVector = CategoryIconHelper.getIcon(budget.iconKey ?: "category"),
                contentDescription = budget.budget.categoryName,
                tint = MaterialTheme.colorScheme.onSurface,
                modifier = Modifier.size(32.dp)
            )
        }
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            Text(
                text = budget.budget.categoryName,
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onSurface,
                maxLines = 1,
                overflow = TextOverflow.Ellipsis
            )
            Text(
                text = "${NumberFormat.getNumberInstance(Locale("en", "IN")).format(remaining.toInt())} left",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

/**
 * A dashboard card for displaying the user's net worth.
 *
 * @param netWorth The calculated net worth.
 */
@Composable
fun AuroraNetWorthCard(netWorth: Double) {
    GlassPanel {
        Column(modifier = Modifier.padding(24.dp)) {
            Text(
                "Net Worth",
                style = MaterialTheme.typography.titleMedium,
                color = MaterialTheme.colorScheme.onSurface
            )
            Text(
                text = "${NumberFormat.getNumberInstance(Locale("en", "IN")).format(netWorth)}",
                style = MaterialTheme.typography.displaySmall,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.onSurface
            )
        }
    }
}

/**
 * A dashboard card for displaying recent transactions.
 *
 * @param transactions The list of recent transactions.
 * @param navController The NavController for navigation.
 */
@Composable
fun AuroraRecentActivityCard(transactions: List<TransactionDetails>, navController: NavController) {
    GlassPanel {
        Column(modifier = Modifier.padding(16.dp)) {
            Row(
                verticalAlignment = Alignment.CenterVertically,
                modifier = Modifier.padding(horizontal = 8.dp)
            ) {
                Text(
                    "Recent Transactions",
                    style = MaterialTheme.typography.titleMedium,
                    modifier = Modifier.weight(1f),
                    color = MaterialTheme.colorScheme.onSurface
                )
                Button(
                    onClick = { navController.navigate("add_transaction") },
                    shape = CircleShape,
                    contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.primary,
                        contentColor = MaterialTheme.colorScheme.onPrimary
                    )
                ) {
                    Icon(
                        Icons.Default.Add,
                        contentDescription = "Add Transaction",
                        modifier = Modifier.size(18.dp)
                    )
                    Spacer(Modifier.width(4.dp))
                    Text("Add")
                }
                Spacer(Modifier.width(8.dp))
                TextButton(
                    onClick = {
                        navController.navigate(BottomNavItem.Transactions.route) {
                            popUpTo(navController.graph.findStartDestination().id) { saveState = true }
                            launchSingleTop = true
                            restoreState = true
                        }
                    }
                ) { Text("View All") }
            }
            Spacer(modifier = Modifier.height(8.dp))
            if (transactions.isEmpty()) {
                Text(
                    "No transactions yet.",
                    modifier = Modifier.padding(vertical = 16.dp),
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            } else {
                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    transactions.forEach { details ->
                        TransactionItem(
                            transactionDetails = details,
                            onClick = {
                                navController.navigate("transaction_detail/${details.transaction.id}")
                            }
                        )
                    }
                }
            }
        }
    }
}

/**
 * --- NEW ---
 * A dashboard card that provides quick navigation actions.
 *
 * @param navController The NavController for navigation.
 */
@Composable
fun AuroraQuickActionsCard(navController: NavController) {
    GlassPanel(
        modifier = Modifier.fillMaxWidth()
    ) {
        Row(
            modifier = Modifier.height(IntrinsicSize.Min), // Ensures divider stretches
            verticalAlignment = Alignment.CenterVertically
        ) {
            QuickActionItem(
                modifier = Modifier.weight(1f),
                icon = Icons.Default.Timeline,
                text = "View Trends",
                onClick = {
                    navController.navigate(BottomNavItem.Reports.route) {
                        popUpTo(BottomNavItem.Dashboard.route) {
                            saveState = true
                        }
                        launchSingleTop = true
                        restoreState = true
                    }
                }
            )
            VerticalDivider(
                modifier = Modifier
                    .fillMaxHeight()
                    .width(1.dp),
                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f)
            )
            QuickActionItem(
                modifier = Modifier.weight(1f),
                icon = Icons.Default.PieChart,
                text = "View Categories",
                onClick = {
                    navController.navigate(BottomNavItem.Reports.route) {
                        popUpTo(BottomNavItem.Dashboard.route) {
                            saveState = true
                        }
                        launchSingleTop = true
                        restoreState = true
                    }
                }
            )
        }
    }
}

@Composable
private fun QuickActionItem(
    modifier: Modifier = Modifier,
    icon: ImageVector,
    text: String,
    onClick: () -> Unit
) {
    Row(
        modifier = modifier
            .clickable(onClick = onClick)
            .padding(horizontal = 16.dp, vertical = 20.dp),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.spacedBy(12.dp, Alignment.CenterHorizontally)
    ) {
        Icon(
            imageVector = icon,
            contentDescription = text,
            tint = MaterialTheme.colorScheme.onSurface
        )
        Text(
            text = text,
            style = MaterialTheme.typography.titleSmall,
            fontWeight = FontWeight.SemiBold,
            color = MaterialTheme.colorScheme.onSurface
        )
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/components/UtilityComponents.kt ==================
package io.pm.finlight.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import com.github.mikephil.charting.charts.BarChart
import com.github.mikephil.charting.components.XAxis
import com.github.mikephil.charting.data.BarData
import com.github.mikephil.charting.data.PieData
import com.github.mikephil.charting.data.PieDataSet
import com.github.mikephil.charting.formatter.IndexAxisValueFormatter

@Composable
fun TimePickerDialog(
    title: String = "Select Time",
    onDismissRequest: () -> Unit,
    onConfirm: () -> Unit,
    content: @Composable () -> Unit,
) {
    AlertDialog(
        onDismissRequest = onDismissRequest,
        title = { Text(title) },
        text = {
            Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                content()
            }
        },
        confirmButton = {
            TextButton(onClick = onConfirm) {
                Text("OK")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismissRequest) {
                Text("Cancel")
            }
        },
    )
}

@Composable
fun ChartLegend(pieData: PieData?) {
    val dataSet = pieData?.dataSet as? PieDataSet ?: return

    Column {
        for (i in 0 until dataSet.entryCount) {
            val entry = dataSet.getEntryForIndex(i)
            val color = dataSet.getColor(i)

            Row(
                verticalAlignment = Alignment.CenterVertically,
                modifier = Modifier.padding(vertical = 4.dp),
            ) {
                Box(
                    modifier =
                        Modifier
                            .size(12.dp)
                            .clip(CircleShape)
                            .background(Color(color)),
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = "${entry.label} - ${"%.2f".format(entry.value)}",
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

@Composable
fun GroupedBarChart(trendDataPair: Pair<BarData, List<String>>) {
    val (barData, labels) = trendDataPair
    val textColor = MaterialTheme.colorScheme.onSurface.toArgb()
    val legendColor = MaterialTheme.colorScheme.onSurfaceVariant.toArgb()

    AndroidView(
        factory = { context ->
            BarChart(context).apply {
                description.isEnabled = false
                legend.isEnabled = true
                setDrawGridBackground(false)

                xAxis.position = XAxis.XAxisPosition.BOTTOM
                xAxis.setDrawGridLines(false)
                xAxis.granularity = 1f

                axisLeft.axisMinimum = 0f
                axisLeft.setDrawGridLines(true)

                axisRight.isEnabled = false
            }
        },
        update = { chart ->
            val barWidth = 0.25f
            val barSpace = 0.05f
            val groupSpace = 0.4f
            barData.barWidth = barWidth

            chart.data = barData
            chart.xAxis.valueFormatter = IndexAxisValueFormatter(labels)
            chart.xAxis.axisMinimum = 0f
            chart.xAxis.axisMaximum = labels.size.toFloat()
            chart.xAxis.setCenterAxisLabels(true)

            chart.legend.textColor = legendColor
            chart.xAxis.textColor = textColor
            chart.axisLeft.textColor = textColor

            chart.groupBars(0f, groupSpace, barSpace)
            chart.invalidate()
        },
        modifier =
            Modifier
                .fillMaxWidth()
                .height(250.dp),
    )
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/components/PagerUtils.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/components/PagerUtils.kt
// REASON: NEW FILE - Centralized the pagerTabIndicatorOffset helper function
// to resolve conflicting overload errors and avoid code duplication.
// =================================================================================
package io.pm.finlight.ui.components

import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.layout.wrapContentSize
import androidx.compose.foundation.pager.PagerState
import androidx.compose.material3.TabPosition
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.composed
import androidx.compose.ui.unit.Dp
import kotlin.math.absoluteValue

private fun lerp(start: Dp, stop: Dp, fraction: Float): Dp {
    return Dp(start.value + (stop.value - start.value) * fraction)
}

@OptIn(ExperimentalFoundationApi::class)
fun Modifier.pagerTabIndicatorOffset(
    pagerState: PagerState,
    tabPositions: List<TabPosition>,
): Modifier = composed {
    if (tabPositions.isEmpty()) {
        this
    } else {
        val currentPage = pagerState.currentPage
        val fraction = pagerState.currentPageOffsetFraction.absoluteValue

        val currentTab = tabPositions[currentPage]
        val nextTab = tabPositions.getOrNull(currentPage + 1)

        val targetIndicatorOffset = if (nextTab != null) {
            lerp(currentTab.left, nextTab.left, fraction)
        } else {
            currentTab.left
        }

        val indicatorWidth = if (nextTab != null) {
            lerp(currentTab.width, nextTab.width, fraction)
        } else {
            currentTab.width
        }

        this.fillMaxWidth()
            .wrapContentSize(Alignment.BottomStart)
            .offset(x = targetIndicatorOffset)
            .width(indicatorWidth)
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/components/DashboardComponents.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/components/DashboardComponents.kt
// REASON: REFACTOR - The unused `RecentActivityCard` has been removed from this
// file. The correct component, `AuroraRecentActivityCard`, is located in
// `GlassmorphismComponents.kt` and has been updated there. This cleanup
// prevents future confusion.
// =================================================================================
package io.pm.finlight.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Category
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.LinearProgressIndicator
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import androidx.navigation.NavGraph.Companion.findStartDestination
import io.pm.finlight.BottomNavItem
import io.pm.finlight.BudgetViewModel
import io.pm.finlight.BudgetWithSpending
import io.pm.finlight.CategoryIconHelper
import io.pm.finlight.TransactionDetails

// Note: The old OverallBudgetCard, StatCard, and AccountSummaryCard have been
// removed and replaced by the new Aurora-themed components in GlassmorphismComponents.kt

@Composable
fun NetWorthCard(netWorth: Double) {
    Card(elevation = CardDefaults.cardElevation(4.dp), modifier = Modifier.fillMaxWidth()) {
        Column(modifier = Modifier.padding(16.dp)) {
            Text("Net Worth", style = MaterialTheme.typography.titleMedium)
            Text(
                text = "${"%,.2f".format(netWorth)}",
                style = MaterialTheme.typography.displaySmall,
                fontWeight = FontWeight.Bold
            )
        }
    }
}

// --- REMOVED: The old RecentActivityCard, BudgetWatchCard, and BudgetItem are no longer needed ---
// They have been replaced by the new components in GlassmorphismComponents.kt
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/components/TransactionItem.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/components/TransactionItem.kt
// REASON: ANIMATION - Added `animateItemPlacement()` to the TransactionItem in the
// TransactionList composable. This makes the list fluidly animate changes when
// items are added, removed, or reordered due to filtering, enhancing the app's
// snappy feel.
// FIX - Added the 'modifier' parameter to the TransactionItem composable to
// resolve the "No parameter with name 'modifier' found" compilation error.
// =================================================================================
package io.pm.finlight.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.NorthEast
import androidx.compose.material.icons.filled.SouthWest
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontStyle
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import io.pm.finlight.CategoryIconHelper
import io.pm.finlight.TransactionDetails
import io.pm.finlight.ui.theme.ExpenseRedDark
import io.pm.finlight.ui.theme.ExpenseRedLight
import io.pm.finlight.ui.theme.IncomeGreenDark
import io.pm.finlight.ui.theme.IncomeGreenLight
import java.text.SimpleDateFormat
import java.util.*
import androidx.compose.foundation.ExperimentalFoundationApi

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun TransactionItem(
    modifier: Modifier = Modifier,
    transactionDetails: TransactionDetails,
    onClick: () -> Unit,
) {
    val contentAlpha = if (transactionDetails.transaction.isExcluded) 0.5f else 1f
    val isUncategorized = transactionDetails.categoryName == null || transactionDetails.categoryName == "Uncategorized"

    GlassPanel(
        modifier = modifier
            .fillMaxWidth()
            .clickable(onClick = onClick)
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Box(
                modifier = Modifier
                    .size(40.dp)
                    .clip(CircleShape)
                    .background(
                        CategoryIconHelper.getIconBackgroundColor(
                            if (isUncategorized) "red_light" else transactionDetails.categoryColorKey ?: "gray_light"
                        )
                            .copy(alpha = contentAlpha)
                    ),
                contentAlignment = Alignment.Center
            ) {
                // --- UPDATED: Logic to handle uncategorized state ---
                when {
                    isUncategorized -> {
                        Icon(
                            imageVector = CategoryIconHelper.getIcon("help_outline"),
                            contentDescription = "Uncategorized",
                            tint = Color.Black.copy(alpha = contentAlpha),
                            modifier = Modifier.size(24.dp)
                        )
                    }
                    transactionDetails.categoryIconKey == "letter_default" -> {
                        Text(
                            text = transactionDetails.categoryName?.firstOrNull()?.uppercase() ?: "?",
                            fontWeight = FontWeight.Bold,
                            fontSize = 18.sp,
                            color = Color.Black.copy(alpha = contentAlpha)
                        )
                    }
                    else -> {
                        Icon(
                            imageVector = CategoryIconHelper.getIcon(transactionDetails.categoryIconKey ?: "category"),
                            contentDescription = transactionDetails.categoryName,
                            tint = Color.Black.copy(alpha = contentAlpha),
                            modifier = Modifier.size(22.dp)
                        )
                    }
                }
            }
            Spacer(modifier = Modifier.width(16.dp))
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = transactionDetails.transaction.description,
                    style = MaterialTheme.typography.bodyLarge,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = contentAlpha)
                )
                if (!transactionDetails.transaction.notes.isNullOrBlank()) {
                    Text(
                        text = transactionDetails.transaction.notes!!,
                        style = MaterialTheme.typography.bodyMedium,
                        fontStyle = FontStyle.Italic,
                        color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = contentAlpha)
                    )
                }
                Text(
                    text = SimpleDateFormat("dd MMM yy, h:mm a", Locale.getDefault()).format(Date(transactionDetails.transaction.date)),
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = contentAlpha)
                )
            }

            val isIncome = transactionDetails.transaction.transactionType == "income"
            val amountColor = if (isSystemInDarkTheme()) {
                if (isIncome) IncomeGreenDark else ExpenseRedDark
            } else {
                if (isIncome) IncomeGreenLight else ExpenseRedLight
            }.copy(alpha = contentAlpha)
            val icon = if (isIncome) Icons.Default.SouthWest else Icons.Default.NorthEast

            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(
                    text = "${"%.2f".format(transactionDetails.transaction.amount)}",
                    style = MaterialTheme.typography.bodyLarge,
                    fontWeight = FontWeight.SemiBold,
                    color = amountColor
                )
                Spacer(modifier = Modifier.width(4.dp))
                Icon(
                    imageVector = icon,
                    contentDescription = transactionDetails.transaction.transactionType,
                    tint = amountColor,
                    modifier = Modifier.size(20.dp)
                )
            }
        }
    }
}

@Composable
fun AccountTransactionItem(transactionDetails: TransactionDetails) {
    val contentAlpha = if (transactionDetails.transaction.isExcluded) 0.5f else 1f

    Row(
        modifier =
            Modifier
                .fillMaxWidth()
                .padding(vertical = 12.dp),
        verticalAlignment = Alignment.CenterVertically,
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Text(
                text = transactionDetails.transaction.description,
                style = MaterialTheme.typography.bodyLarge,
                color = LocalContentColor.current.copy(alpha = contentAlpha)
            )
            Text(
                text = SimpleDateFormat("dd MMM yy", Locale.getDefault()).format(Date(transactionDetails.transaction.date)),
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = contentAlpha)
            )
        }
        val isIncome = transactionDetails.transaction.transactionType == "income"
        val amountColor = if (isSystemInDarkTheme()) {
            if (isIncome) IncomeGreenDark else ExpenseRedDark
        } else {
            if (isIncome) IncomeGreenLight else ExpenseRedLight
        }.copy(alpha = contentAlpha)

        Text(
            text = "${"%.2f".format(transactionDetails.transaction.amount)}",
            style = MaterialTheme.typography.bodyLarge,
            color = amountColor,
        )
    }
}

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun TransactionList(
    transactions: List<TransactionDetails>,
    navController: NavController,
) {
    if (transactions.isEmpty()) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(16.dp),
            contentAlignment = Alignment.Center,
        ) {
            Text("No transactions yet. Add one!")
        }
    } else {
        LazyColumn(
            modifier = Modifier.fillMaxSize(),
            contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            items(transactions, key = { it.transaction.id }) { details ->
                TransactionItem(
                    modifier = Modifier.animateItemPlacement(),
                    transactionDetails = details,
                    onClick = {
                        navController.navigate("transaction_detail/${details.transaction.id}")
                    }
                )
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/components/DaybreakAnimatedBackground.kt ==================
package io.pm.finlight.ui.components

import androidx.compose.animation.core.*
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import kotlin.math.sin

/**
 * A composable that renders a slow, gently moving daybreak-like background effect.
 * It uses an infinite transition to animate the properties of several large,
 * blurred, overlapping circles with light, sunrise colors.
 */
@Composable
fun DaybreakAnimatedBackground() {
    val transition = rememberInfiniteTransition(label = "DaybreakBackgroundTransition")

    // Animate the sine wave over time to create a gentle vertical bobbing motion.
    val time by transition.animateFloat(
        initialValue = 0f,
        targetValue = 2f * Math.PI.toFloat(),
        animationSpec = infiniteRepeatable(
            animation = tween(durationMillis = 35000, easing = LinearEasing),
            repeatMode = RepeatMode.Restart
        ),
        label = "DaybreakTime"
    )

    // --- UPDATED: Replaced vibrant colors with a softer, more professional palette ---
    val circles = listOf(
        AnimatedCircle(
            color = Color(0xFFD0BCFF), // Soft Lavender
            baseRadiusMultiplier = 0.8f,
            baseCenter = Offset(0.2f, 0.8f),
            speedMultiplier = 0.6f
        ),
        AnimatedCircle(
            color = Color(0xFFCCC2DC), // Muted Purple
            baseRadiusMultiplier = 0.9f,
            baseCenter = Offset(0.8f, 0.7f),
            speedMultiplier = 0.4f
        ),
        AnimatedCircle(
            color = Color(0xFFB9A2DB), // A slightly deeper purple
            baseRadiusMultiplier = 1.0f,
            baseCenter = Offset(0.6f, 0.2f),
            speedMultiplier = 0.5f
        ),
        AnimatedCircle(
            color = Color(0xFF90CAF9), // Soft Blue
            baseRadiusMultiplier = 0.7f,
            baseCenter = Offset(0.9f, 0.1f),
            speedMultiplier = 0.7f
        )
    )

    Canvas(modifier = Modifier.fillMaxSize()) {
        circles.forEach { circle ->
            // Calculate the vertical offset using a sine wave for a smooth bobbing effect.
            val yOffset = sin(time * circle.speedMultiplier) * size.height * 0.1f

            // Create a radial gradient brush to simulate a blurred, glowing effect.
            // --- UPDATED: Reduced alpha for a more subtle effect ---
            val brush = Brush.radialGradient(
                colors = listOf(circle.color.copy(alpha = 0.4f), Color.Transparent),
                center = Offset(
                    x = circle.baseCenter.x * size.width,
                    y = (circle.baseCenter.y * size.height) + yOffset
                ),
                radius = size.maxDimension * circle.baseRadiusMultiplier
            )

            // Draw the circle onto the canvas.
            drawCircle(
                brush = brush,
                radius = size.maxDimension * circle.baseRadiusMultiplier,
                center = Offset(
                    x = circle.baseCenter.x * size.width,
                    y = (circle.baseCenter.y * size.height) + yOffset
                )
            )
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/components/CategoryDialogs.kt ==================
package io.pm.finlight.ui.components

import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import io.pm.finlight.Category

@Composable
fun EditCategoryDialog(
    category: Category,
    onDismiss: () -> Unit,
    onConfirm: (Category) -> Unit,
) {
    var updatedName by remember { mutableStateOf(category.name) }

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Edit Category") },
        text = {
            OutlinedTextField(
                value = updatedName,
                onValueChange = { updatedName = it },
                label = { Text("Category Name") },
            )
        },
        confirmButton = {
            Button(
                onClick = {
                    if (updatedName.isNotBlank()) {
                        onConfirm(category.copy(name = updatedName))
                    }
                },
                enabled = updatedName.isNotBlank(),
            ) {
                Text("Update")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        },
    )
}

@Composable
fun DeleteCategoryDialog(
    category: Category,
    onDismiss: () -> Unit,
    onConfirm: () -> Unit,
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Delete Category") },
        text = { Text("Are you sure you want to delete the category '${category.name}'? This cannot be undone.") },
        confirmButton = {
            Button(
                onClick = onConfirm,
                colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error),
            ) {
                Text("Delete")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        },
    )
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/components/SettingsComponents.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/components/SettingsComponents.kt
// REASON: REFACTOR - The ListItem components have been updated to use a
// transparent container color. This ensures they blend seamlessly when placed
// inside a GlassPanel, allowing the frosted glass effect to show through and
// creating a visually consistent settings screen.
// FIX: Removed the duplicate TimePickerDialog definition to resolve the
// "Conflicting overloads" compilation error.
// BUG FIX - The AlertDialogs for the time pickers now determine their color
// based on the app's MaterialTheme, not the system theme. This ensures they
// correctly follow the selected app theme (e.g., Aurora, Daybreak) instead of
// defaulting to the system's light/dark mode.
// BUG FIX - Ensured the Switch component is always present in the
// SettingsToggleItem's trailingContent, fixing an issue where it could disappear.
// =================================================================================
package io.pm.finlight.ui.components

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.foundation.clickable
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material.icons.filled.ArrowDropUp
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.unit.dp
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight
import java.text.SimpleDateFormat
import java.util.*

// Helper function to determine if a color is 'dark' based on luminance.
private fun Color.isDark() = (red * 0.299 + green * 0.587 + blue * 0.114) < 0.5

@Composable
fun SettingsToggleItem(
    title: String,
    subtitle: String,
    icon: ImageVector,
    checked: Boolean,
    onCheckedChange: (Boolean) -> Unit,
    enabled: Boolean = true,
) {
    ListItem(
        headlineContent = { Text(title) },
        supportingContent = { Text(subtitle, style = MaterialTheme.typography.bodySmall) },
        leadingContent = { Icon(icon, contentDescription = null, modifier = Modifier.size(24.dp)) },
        trailingContent = { Switch(checked = checked, onCheckedChange = onCheckedChange, enabled = enabled) },
        modifier = Modifier.clickable(enabled = enabled) { onCheckedChange(!checked) },
        colors = ListItemDefaults.colors(
            containerColor = Color.Transparent, // Make transparent to show GlassPanel behind
            headlineColor = if (enabled) MaterialTheme.colorScheme.onSurface else MaterialTheme.colorScheme.onSurface.copy(alpha = 0.38f),
            supportingColor = if (enabled) MaterialTheme.colorScheme.onSurfaceVariant else MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.38f),
            leadingIconColor = if (enabled) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.primary.copy(alpha = 0.38f)
        )
    )
}

@Composable
fun SettingsActionItem(
    text: String,
    subtitle: String? = null,
    icon: ImageVector,
    onClick: () -> Unit,
    enabled: Boolean = true
) {
    ListItem(
        headlineContent = { Text(text) },
        supportingContent = { subtitle?.let { Text(it, style = MaterialTheme.typography.bodySmall) } },
        leadingContent = { Icon(icon, contentDescription = null, modifier = Modifier.size(24.dp)) },
        modifier = Modifier.clickable(enabled = enabled, onClick = onClick),
        colors = ListItemDefaults.colors(
            containerColor = Color.Transparent, // Make transparent to show GlassPanel behind
            headlineColor = if (enabled) MaterialTheme.colorScheme.onSurface else MaterialTheme.colorScheme.onSurface.copy(alpha = 0.38f),
            supportingColor = if (enabled) MaterialTheme.colorScheme.onSurfaceVariant else MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.38f),
            leadingIconColor = if (enabled) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.primary.copy(alpha = 0.38f)
        )
    )
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun WeeklyReportTimePicker(
    initialDay: Int,
    initialHour: Int,
    initialMinute: Int,
    onDismiss: () -> Unit,
    onConfirm: (Int, Int, Int) -> Unit
) {
    var selectedDay by remember { mutableStateOf(initialDay) }
    val timePickerState = rememberTimePickerState(initialHour, initialMinute, false)
    val days = (1..7).map {
        val cal = Calendar.getInstance().apply { set(Calendar.DAY_OF_WEEK, it) }
        Pair(it, cal.getDisplayName(Calendar.DAY_OF_WEEK, Calendar.SHORT, Locale.getDefault()))
    }

    val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
    val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Set Weekly Report Time") },
        text = {
            Column {
                Text("Day of the Week", style = MaterialTheme.typography.titleMedium)
                Spacer(Modifier.height(8.dp))
                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    days.chunked(4).forEach { rowDays ->
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            rowDays.forEach { (dayInt, dayName) ->
                                val isSelected = dayInt == selectedDay
                                OutlinedButton(
                                    modifier = Modifier.weight(1f),
                                    shape = MaterialTheme.shapes.medium,
                                    onClick = { selectedDay = dayInt },
                                    colors = if (isSelected) ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.primary) else ButtonDefaults.outlinedButtonColors(),
                                    contentPadding = PaddingValues(vertical = 12.dp)
                                ) {
                                    Text(dayName)
                                }
                            }
                            if (rowDays.size < 4) {
                                Spacer(modifier = Modifier.weight(4f - rowDays.size))
                            }
                        }
                    }
                }
                Spacer(Modifier.height(16.dp))
                Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                    TimePicker(state = timePickerState)
                }
            }
        },
        confirmButton = {
            Button(onClick = { onConfirm(selectedDay, timePickerState.hour, timePickerState.minute) }) {
                Text("Set Time")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) { Text("Cancel") }
        },
        containerColor = popupContainerColor
    )
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MonthlyReportTimePicker(
    initialDay: Int,
    initialHour: Int,
    initialMinute: Int,
    onDismiss: () -> Unit,
    onConfirm: (Int, Int, Int) -> Unit
) {
    var selectedDay by remember { mutableStateOf(initialDay) }
    val timePickerState = rememberTimePickerState(initialHour, initialMinute, false)
    var isDayPickerExpanded by remember { mutableStateOf(false) }

    val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
    val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Set Monthly Report Time") },
        text = {
            Column {
                Text("Day of the Month", style = MaterialTheme.typography.titleMedium)
                Spacer(Modifier.height(8.dp))
                OutlinedButton(
                    onClick = { isDayPickerExpanded = !isDayPickerExpanded },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Day: $selectedDay")
                    Spacer(Modifier.weight(1f))
                    Icon(
                        imageVector = if (isDayPickerExpanded) Icons.Default.ArrowDropUp else Icons.Default.ArrowDropDown,
                        contentDescription = "Toggle day picker"
                    )
                }
                AnimatedVisibility(visible = isDayPickerExpanded) {
                    LazyVerticalGrid(
                        columns = GridCells.Adaptive(minSize = 52.dp),
                        modifier = Modifier.heightIn(max = 240.dp),
                        contentPadding = PaddingValues(vertical = 8.dp)
                    ) {
                        items((1..28).toList()) { day ->
                            val isSelected = day == selectedDay
                            OutlinedButton(
                                onClick = {
                                    selectedDay = day
                                    isDayPickerExpanded = false
                                },
                                shape = CircleShape,
                                colors = if (isSelected) ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.primary) else ButtonDefaults.outlinedButtonColors(),
                                modifier = Modifier.size(48.dp),
                                contentPadding = PaddingValues(0.dp)
                            ) {
                                Text("$day")
                            }
                        }
                    }
                }
                Spacer(Modifier.height(16.dp))
                Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                    TimePicker(state = timePickerState)
                }
            }
        },
        confirmButton = {
            Button(onClick = { onConfirm(selectedDay, timePickerState.hour, timePickerState.minute) }) {
                Text("Set Time")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) { Text("Cancel") }
        },
        containerColor = popupContainerColor
    )
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/components/CreationDialogs.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/components/CreationDialogs.kt
// REASON: NEW FILE - Centralized the creation dialogs to resolve conflicting
// overload errors and improve code organization.
// BUG FIX - The AlertDialogs now correctly derive their background color from
// the app's MaterialTheme, ensuring they match the selected theme (e.g.,
// Aurora) instead of defaulting to the system's light/dark mode.
// =================================================================================
package io.pm.finlight.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.heightIn
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import io.pm.finlight.CategoryIconHelper
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight

// Helper function to determine if a color is 'dark' based on luminance.
private fun Color.isDark() = (red * 0.299 + green * 0.587 + blue * 0.114) < 0.5

@Composable
fun CreateAccountDialog(
    onDismiss: () -> Unit,
    onConfirm: (String, String) -> Unit
) {
    var name by remember { mutableStateOf("") }
    var type by remember { mutableStateOf("") }

    val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
    val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Create New Account") },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                OutlinedTextField(
                    value = name,
                    onValueChange = { name = it },
                    label = { Text("Account Name (e.g., Chase Sapphire)") }
                )
                OutlinedTextField(
                    value = type,
                    onValueChange = { type = it },
                    label = { Text("Account Type (e.g., Credit Card)") }
                )
            }
        },
        confirmButton = {
            Button(
                onClick = { onConfirm(name, type) },
                enabled = name.isNotBlank() && type.isNotBlank()
            ) { Text("Create") }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) { Text("Cancel") }
        },
        containerColor = popupContainerColor
    )
}

@Composable
fun CreateCategoryDialog(
    onDismiss: () -> Unit,
    onConfirm: (String, String, String) -> Unit
) {
    var name by remember { mutableStateOf("") }
    var selectedIconKey by remember { mutableStateOf("category") }
    var selectedColorKey by remember { mutableStateOf("gray_light") }
    val allIcons = remember { CategoryIconHelper.getAllIcons().entries.toList() }
    val allColors = remember { CategoryIconHelper.getAllIconColors().entries.toList() }

    val isThemeDark = MaterialTheme.colorScheme.surface.isDark()
    val popupContainerColor = if (isThemeDark) PopupSurfaceDark else PopupSurfaceLight

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Create New Category") },
        text = {
            Column {
                OutlinedTextField(
                    value = name,
                    onValueChange = { name = it },
                    label = { Text("Category Name") },
                    modifier = Modifier.fillMaxWidth()
                )
                Spacer(Modifier.height(16.dp))
                Text("Select Icon", style = MaterialTheme.typography.titleMedium)
                LazyVerticalGrid(
                    columns = GridCells.Adaptive(minSize = 48.dp),
                    modifier = Modifier.heightIn(max = 150.dp)
                ) {
                    items(allIcons) { (key, icon) ->
                        IconButton(
                            onClick = { selectedIconKey = key },
                            modifier = Modifier
                                .padding(4.dp)
                                .border(
                                    width = 1.dp,
                                    color = if (selectedIconKey == key) MaterialTheme.colorScheme.primary else Color.Transparent,
                                    shape = MaterialTheme.shapes.medium
                                )
                        ) {
                            Icon(imageVector = icon, contentDescription = key)
                        }
                    }
                }
                Spacer(Modifier.height(16.dp))
                Text("Select Color", style = MaterialTheme.typography.titleMedium)
                LazyVerticalGrid(
                    columns = GridCells.Adaptive(minSize = 48.dp),
                    modifier = Modifier.heightIn(max = 100.dp)
                ) {
                    items(allColors) { (key, color) ->
                        Box(
                            modifier = Modifier
                                .padding(6.dp)
                                .size(32.dp)
                                .clip(CircleShape)
                                .background(color)
                                .clickable { selectedColorKey = key }
                                .border(
                                    width = 2.dp,
                                    color = if (selectedColorKey == key) MaterialTheme.colorScheme.outline else Color.Transparent,
                                    shape = CircleShape
                                )
                        )
                    }
                }
            }
        },
        confirmButton = {
            Button(
                onClick = { onConfirm(name, selectedIconKey, selectedColorKey) },
                enabled = name.isNotBlank()
            ) { Text("Create") }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) { Text("Cancel") }
        },
        containerColor = popupContainerColor
    )
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/components/FilterBottomSheet.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/components/FilterBottomSheet.kt
// REASON: NEW FILE - A reusable composable for the filter bottom sheet to be
// used across the Transaction and Income screens, avoiding code duplication.
// FIX: Explicitly set the title's text color to ensure proper contrast in dark mode.
// FIX: Applied a semi-opaque background to the filter dropdown menus to ensure
// legibility and consistency with other popups in dark mode.
// =================================================================================
package io.pm.finlight.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Clear
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.unit.dp
import io.pm.finlight.Account
import io.pm.finlight.Category
import io.pm.finlight.TransactionFilterState
import io.pm.finlight.ui.theme.PopupSurfaceDark
import io.pm.finlight.ui.theme.PopupSurfaceLight

@Composable
fun FilterBottomSheet(
    filterState: TransactionFilterState,
    accounts: List<Account>,
    categories: List<Category>,
    onKeywordChange: (String) -> Unit,
    onAccountChange: (Account?) -> Unit,
    onCategoryChange: (Category?) -> Unit,
    onClearFilters: () -> Unit
) {
    Column(
        modifier = Modifier
            .padding(16.dp)
            .navigationBarsPadding(),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text(
            "Filter Transactions",
            style = MaterialTheme.typography.titleLarge,
            color = MaterialTheme.colorScheme.onSurface
        )

        OutlinedTextField(
            value = filterState.keyword,
            onValueChange = onKeywordChange,
            label = { Text("Search by keyword") },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true,
            keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search)
        )

        SearchableDropdown(
            label = "Account",
            options = accounts,
            selectedOption = filterState.account,
            onOptionSelected = onAccountChange,
            getDisplayName = { it.name }
        )

        SearchableDropdown(
            label = "Category",
            options = categories,
            selectedOption = filterState.category,
            onOptionSelected = onCategoryChange,
            getDisplayName = { it.name }
        )

        Button(
            onClick = onClearFilters,
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Clear All Filters")
        }
    }
}


@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun <T> SearchableDropdown(
    label: String,
    options: List<T>,
    selectedOption: T?,
    onOptionSelected: (T?) -> Unit,
    getDisplayName: (T) -> String,
) {
    var expanded by remember { mutableStateOf(false) }

    ExposedDropdownMenuBox(
        expanded = expanded,
        onExpandedChange = { expanded = !expanded },
    ) {
        OutlinedTextField(
            value = selectedOption?.let { getDisplayName(it) } ?: "All",
            onValueChange = {},
            readOnly = true,
            label = { Text(label) },
            trailingIcon = {
                Row {
                    if (selectedOption != null) {
                        IconButton(onClick = { onOptionSelected(null) }) {
                            Icon(Icons.Default.Clear, contentDescription = "Clear selection")
                        }
                    }
                    ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded)
                }
            },
            modifier =
                Modifier
                    .menuAnchor()
                    .fillMaxWidth(),
        )
        ExposedDropdownMenu(
            expanded = expanded,
            onDismissRequest = { expanded = false },
            modifier = Modifier.background(
                if (isSystemInDarkTheme()) PopupSurfaceDark else PopupSurfaceLight
            )
        ) {
            options.forEach { option ->
                DropdownMenuItem(
                    text = { Text(getDisplayName(option)) },
                    onClick = {
                        onOptionSelected(option)
                        expanded = false
                    },
                )
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/components/DragDrop.kt ==================
package io.pm.finlight.ui.components

import androidx.compose.foundation.lazy.LazyListItemInfo
import androidx.compose.foundation.lazy.LazyListState
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.geometry.Offset

@Composable
fun rememberDragDropState(
    lazyListState: LazyListState = rememberLazyListState(),
    onMove: (Int, Int) -> Unit,
): DragDropState {
    return remember { DragDropState(lazyListState, onMove) }
}

class DragDropState(
    val lazyListState: LazyListState,
    private val onMove: (Int, Int) -> Unit
) {
    var draggingItemIndex by mutableStateOf<Int?>(null)
        private set

    // This is the total displacement of the user's finger since the drag started.
    private var draggingItemOffset by mutableFloatStateOf(0f)

    // We need to store the initial offset of the item being dragged.
    private var initialDraggingItemOffset by mutableStateOf<Int?>(null)

    // A reference to the LazyListItemInfo of the item currently being dragged.
    private val currentDraggingItem: LazyListItemInfo?
        get() = draggingItemIndex?.let {
            lazyListState.layoutInfo.visibleItemsInfo.find { item -> item.index == it }
        }

    // The calculated translationY to be applied in the graphicsLayer.
    // This is the magic that makes the drag smooth.
    val draggingItemTranslationY: Float
        get() = currentDraggingItem?.let {
            (initialDraggingItemOffset ?: 0) + draggingItemOffset - it.offset
        } ?: 0f

    /**
     * Called when a drag gesture starts.
     * Finds the item under the pointer and initializes the drag state.
     * Prevents dragging the first item (the Hero Card).
     */
    fun onDragStart(offset: Offset) {
        lazyListState.layoutInfo.visibleItemsInfo
            .firstOrNull { item -> offset.y.toInt() in item.offset..(item.offset + item.size) }
            ?.also {
                // Prevent dragging the hero card at index 0
                if (it.index == 0) return

                draggingItemIndex = it.index
                initialDraggingItemOffset = it.offset
            }
    }

    /**
     * Called for each movement during a drag gesture.
     * This function accumulates the finger's movement and detects when a swap should occur.
     */
    fun onDrag(offset: Offset) {
        draggingItemOffset += offset.y

        val currentDraggingIndex = draggingItemIndex ?: return
        val initialOffset = initialDraggingItemOffset ?: return

        // Calculate the absolute visual position of the item's center.
        val itemCenter = initialOffset + draggingItemOffset + (currentDraggingItem?.size ?: 0) / 2

        // Find the item that the dragging item is hovering over.
        val targetItem = lazyListState.layoutInfo.visibleItemsInfo.find {
            // Exclude the item being dragged and the non-movable hero card at index 0.
            it.index != currentDraggingIndex && it.index != 0 &&
                    // Check if the center of the dragging item is within the bounds of the target item.
                    itemCenter.toInt() in it.offset..(it.offset + it.size)
        }

        if (targetItem != null) {
            val from = currentDraggingIndex
            val to = targetItem.index
            onMove(from, to)
            // Only update the index. The offset logic will handle the visual position.
            draggingItemIndex = to
        }
    }

    /**
     * Called when the drag gesture ends. Resets the state.
     */
    fun onDragEnd() {
        draggingItemIndex = null
        draggingItemOffset = 0f
        initialDraggingItemOffset = null
    }

    /**
     * Calculates the amount to scroll when the dragged item reaches the edge of the viewport.
     */
    fun checkForOverScroll(): Float {
        val draggingItem = currentDraggingItem ?: return 0f
        val viewportStartOffset = lazyListState.layoutInfo.viewportStartOffset
        val viewportEndOffset = lazyListState.layoutInfo.viewportEndOffset

        val itemTop = draggingItem.offset + draggingItemTranslationY
        val itemBottom = itemTop + draggingItem.size

        val scrollAmount = 20f

        return when {
            itemBottom > viewportEndOffset -> scrollAmount
            itemTop < viewportStartOffset -> -scrollAmount
            else -> 0f
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/theme/ThemeManager.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/theme/ThemeManager.kt
// REASON: FEATURE - The AppTheme enum has been updated to include "Daybreak"
// as a distinct option, separating the light and dark purple themes and giving
// the user more explicit control over the app's appearance.
// UPDATE: Swapped the icon background colors for the Midnight and Paper themes
// to better reflect their nature (dark vs. light).
// =================================================================================
package io.pm.finlight.ui.theme

import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector

/**
 * Enum to represent the available themes in the application.
 * This provides a type-safe way to manage theme selection.
 */
enum class AppTheme(
    val key: String,
    val displayName: String,
    val icon: ImageVector,
    val lightColor: Color,
    val darkColor: Color
) {
    SYSTEM_DEFAULT(
        key = "system_default",
        displayName = "System",
        icon = Icons.Default.SettingsBrightness,
        lightColor = PaperPrimary,
        darkColor = MidnightPrimary
    ),
    AURORA(
        key = "aurora",
        displayName = "Aurora",
        icon = Icons.Default.Nightlight,
        lightColor = AuroraDarkPrimary, // Fallback, dark-only theme
        darkColor = AuroraDarkPrimary
    ),
    DAYBREAK(
        key = "daybreak",
        displayName = "Daybreak",
        icon = Icons.Default.WbSunny,
        lightColor = DaybreakPrimary,
        darkColor = DaybreakPrimary // Fallback, light-only theme
    ),
    MIDNIGHT(
        key = "midnight",
        displayName = "Midnight",
        icon = Icons.Default.DarkMode,
        // --- FIX: Use the dark color for the dark theme's icon ---
        lightColor = PaperPrimary,
        darkColor = PaperPrimary
    ),
    PAPER(
        key = "paper",
        displayName = "Paper",
        icon = Icons.Default.LightMode,
        // --- FIX: Use the light color for the light theme's icon ---
        lightColor = MidnightPrimary,
        darkColor = MidnightPrimary
    );

    companion object {
        fun fromKey(key: String?): AppTheme {
            return entries.find { it.key == key } ?: SYSTEM_DEFAULT
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/theme/Color.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/theme/Color.kt
// REASON: REFINEMENT - The opacity of the popup surfaces has been increased
// from 80% to 85%. This makes the popups more solid, reducing the distraction
// from background text and improving overall legibility on both light and dark
// themes.
// =================================================================================
package io.pm.finlight.ui.theme

import androidx.compose.ui.graphics.Color

// --- Aurora Theme (Dark Purple) ---
val AuroraDarkPrimary = Color(0xFF00E5FF) // Vibrant Teal/Cyan
val AuroraDarkSecondary = Color(0xFFFFBA3F) // Subtle Gold
val AuroraDarkBackground = Color(0xFF121212) // Very dark charcoal
val AuroraDarkOnSurface = Color(0xFFE6E1E5) // Off-white for text
val AuroraDarkOnSurfaceVariant = Color(0xFFC4C7C5) // Brighter gray for secondary text

// --- Daybreak Theme (Light Purple) ---
// --- UPDATED: New, more mature and professional color palette based on user feedback ---
val DaybreakPrimary = Color(0xFF6750A4)       // Muted, professional purple
val DaybreakSecondary = Color(0xFF81D4FA)      // Soft, light blue for secondary accents
val DaybreakBackground = Color(0xFFEADDFF)      // Light lavender background
val DaybreakOnSurface = Color(0xFF1D1B20)       // Dark, readable text
val DaybreakOnSurfaceVariant = Color(0xFF49454F) // Softer gray for secondary text


// --- Midnight Theme (Monochrome Dark) ---
val MidnightPrimary = Color(0xFFBBBBBB) // A bright, neutral gray for accents
val MidnightSecondary = Color(0xFF888888) // A softer gray
val MidnightBackground = Color(0xFF000000) // Pure black for deep contrast
val MidnightOnSurface = Color(0xFFFFFFFF) // Pure white for maximum readability
val MidnightOnSurfaceVariant = Color(0xFFB0B0B0) // Lighter gray for secondary text

// --- Paper Theme (Monochrome Light/Creme) ---
val PaperPrimary = Color(0xFF444444) // A strong, dark gray for accents
val PaperSecondary = Color(0xFF757575) // A medium gray
val PaperBackground = Color(0xFFFDFCF7) // A soft, off-white/creme
val PaperOnSurface = Color(0xFF1C1C1C) // Near-black for maximum readability
val PaperOnSurfaceVariant = Color(0xFF555555) // Dark gray for secondary text


// --- Shared Colors ---
val GlassPanelBorder = Color(0x33FFFFFF) // White with 20% opacity
val AuroraNumpadHighlight = Color(0x29FFFFFF) // White with 16% opacity
// --- UPDATED: Increased opacity from 80% (0xCC) to 85% (0xD9) ---
val PopupSurfaceDark = Color(0xD9212125) // 85% opaque dark charcoal
val PopupSurfaceLight = Color(0xD9FFFFFF) // 85% opaque white

// High-contrast colors for transaction amounts
val IncomeGreenDark = Color(0xFF66BB6A)
val ExpenseRedDark = Color(0xFFEF5350)
val IncomeGreenLight = Color(0xFF2E7D32)
val ExpenseRedLight = Color(0xFFC62828)
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/theme/Theme.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/theme/Theme.kt
// REASON: FEATURE - The logic inside the PersonalFinanceAppTheme composable has
// been updated to fully decouple the themes from the system setting. It now
// correctly forces "Aurora" and "Midnight" to use their dark color schemes,
// and "Daybreak" and "Paper" to use their light color schemes, regardless of
// the phone's light/dark mode. "System" continues to respect the device setting.
// =================================================================================
package io.pm.finlight.ui.theme

import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext

// --- Aurora Dark Theme ---
private val AuroraDarkColorScheme = darkColorScheme(
    primary = AuroraDarkPrimary,
    onPrimary = Color(0xFF00363A),
    secondary = AuroraDarkSecondary,
    onSecondary = Color(0xFF452B00),
    background = AuroraDarkBackground,
    onBackground = AuroraDarkOnSurface,
    surface = Color.Transparent,
    onSurface = AuroraDarkOnSurface,
    surfaceVariant = Color(0xFF3F4849),
    onSurfaceVariant = AuroraDarkOnSurfaceVariant,
    error = Color(0xFFFFB4AB),
    onError = Color(0xFF690005)
)

// --- Daybreak Light Theme ---
// --- UPDATED: The color scheme now uses the new, more professional Daybreak colors. ---
private val DaybreakColorScheme = lightColorScheme(
    primary = DaybreakPrimary,
    onPrimary = Color.White,
    secondary = DaybreakSecondary,
    onSecondary = Color(0xFF00363A), // Dark text for contrast on light blue
    background = DaybreakBackground,
    onBackground = DaybreakOnSurface,
    surface = Color.Transparent,
    onSurface = DaybreakOnSurface,
    surfaceVariant = Color(0xFFE7E0EC), // Adjusted for the new background
    onSurfaceVariant = DaybreakOnSurfaceVariant,
    error = Color(0xFFB00020),
    onError = Color.White
)

// --- Midnight Theme (Monochrome Dark) ---
private val MidnightColorScheme = darkColorScheme(
    primary = MidnightPrimary,
    onPrimary = Color.Black,
    secondary = MidnightSecondary,
    onSecondary = Color.Black,
    background = MidnightBackground,
    onBackground = MidnightOnSurface,
    surface = Color.Transparent,
    onSurface = MidnightOnSurface,
    surfaceVariant = Color(0xFF2C2C2C),
    onSurfaceVariant = MidnightOnSurfaceVariant,
    error = Color(0xFFCF6679),
    onError = Color.Black
)

// --- Paper Theme (Monochrome Light) ---
private val PaperColorScheme = lightColorScheme(
    primary = PaperPrimary,
    onPrimary = Color.White,
    secondary = PaperSecondary,
    onSecondary = Color.White,
    background = PaperBackground,
    onBackground = PaperOnSurface,
    surface = Color.Transparent,
    onSurface = PaperOnSurface,
    surfaceVariant = Color(0xFFE0E0E0),
    onSurfaceVariant = PaperOnSurfaceVariant,
    error = Color(0xFFB00020),
    onError = Color.White
)

@Composable
fun PersonalFinanceAppTheme(
    selectedTheme: AppTheme = AppTheme.SYSTEM_DEFAULT,
    dynamicColor: Boolean = false,
    content: @Composable () -> Unit,
) {
    val systemIsDark = isSystemInDarkTheme()

    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (systemIsDark) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }
        // --- UPDATED: Decoupled theme logic ---
        else -> when (selectedTheme) {
            AppTheme.SYSTEM_DEFAULT -> if (systemIsDark) MidnightColorScheme else PaperColorScheme
            AppTheme.AURORA -> AuroraDarkColorScheme
            AppTheme.DAYBREAK -> DaybreakColorScheme
            AppTheme.MIDNIGHT -> MidnightColorScheme
            AppTheme.PAPER -> PaperColorScheme
        }
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content,
    )
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/theme/Type.kt ==================
// FILE: app/src/main/java/io/pm/finlight/ui/theme/Type.kt

package io.pm.finlight.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.Font
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp
import io.pm.finlight.R

/**
 * NEW: Defines the custom FontFamily using the font files
 * located in the res/font directory.
 */
val Inter = FontFamily(
    Font(R.font.inter_regular, FontWeight.Normal),
    Font(R.font.inter_medium, FontWeight.Medium),
    Font(R.font.inter_bold, FontWeight.Bold)
)

/**
 * UPDATED: The Material 3 Typography object is now configured to use
 * the custom "Inter" font for all text styles, ensuring a consistent
 * and professional look across the entire application.
 */
val Typography = Typography(
    displayLarge = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Bold,
        fontSize = 57.sp,
        lineHeight = 64.sp,
        letterSpacing = (-0.25).sp,
    ),
    displayMedium = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Bold,
        fontSize = 45.sp,
        lineHeight = 52.sp,
        letterSpacing = 0.sp,
    ),
    displaySmall = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Bold,
        fontSize = 36.sp,
        lineHeight = 44.sp,
        letterSpacing = 0.sp,
    ),
    headlineLarge = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Bold,
        fontSize = 32.sp,
        lineHeight = 40.sp,
        letterSpacing = 0.sp,
    ),
    headlineMedium = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Bold,
        fontSize = 28.sp,
        lineHeight = 36.sp,
        letterSpacing = 0.sp,
    ),
    headlineSmall = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Bold,
        fontSize = 24.sp,
        lineHeight = 32.sp,
        letterSpacing = 0.sp,
    ),
    titleLarge = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Medium,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp,
    ),
    titleMedium = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Medium,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.15.sp,
    ),
    titleSmall = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Medium,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.1.sp,
    ),
    bodyLarge = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp,
    ),
    bodyMedium = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Normal,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.25.sp,
    ),
    bodySmall = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Normal,
        fontSize = 12.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.4.sp,
    ),
    labelLarge = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Medium,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.1.sp,
    ),
    labelMedium = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Medium,
        fontSize = 12.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp,
    ),
    labelSmall = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp,
    ),
)
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/MainActivity.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/MainActivity.kt
// REASON: REFACTOR - The screen transitions have been updated from a simple slide
// to a more polished "shared axis" effect. This combines the fast 300ms slide
// with a subtle fade and scale. This change addresses the "flimsy" feel of the
// previous animation, creating a more robust and high-quality navigation
// experience while maintaining snappiness.
// FIX - Corrected all transition-related type mismatch errors by defining the
// animations inline for each composable route, satisfying the NavHost function
// signature.
// FIX (Navigation) - Updated the onClick handler in the NavigationBarItem to
// explicitly popUpTo the Dashboard's route. This fixes the back stack issue
// where screens would pile up instead of being replaced.
// =================================================================================
package io.pm.finlight

import android.Manifest
import android.app.Activity
import android.app.Application
import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.activity.result.contract.ActivityResultContracts
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AppCompatActivity
import androidx.biometric.BiometricPrompt
import androidx.compose.animation.core.tween
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.scaleIn
import androidx.compose.animation.scaleOut
import androidx.compose.animation.slideInHorizontally
import androidx.compose.animation.slideOutHorizontally
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.unit.dp
import androidx.core.content.ContextCompat
import androidx.fragment.app.FragmentActivity
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import androidx.navigation.NavDestination.Companion.hierarchy
import androidx.navigation.NavGraph.Companion.findStartDestination
import androidx.navigation.NavHostController
import androidx.navigation.NavOptions
import androidx.navigation.NavType
import androidx.navigation.compose.*
import androidx.navigation.navArgument
import androidx.navigation.navDeepLink
import coil.compose.AsyncImage
import com.google.gson.Gson
import io.pm.finlight.ui.components.AuroraAnimatedBackground
import io.pm.finlight.ui.components.DaybreakAnimatedBackground
import io.pm.finlight.ui.screens.*
import io.pm.finlight.ui.theme.AppTheme
import io.pm.finlight.ui.theme.PersonalFinanceAppTheme
import java.net.URLDecoder
import java.util.concurrent.Executor

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()

        val settingsRepository = SettingsRepository(this)
        val hasSeenOnboarding = settingsRepository.hasSeenOnboarding()

        setContent {
            val settingsViewModel: SettingsViewModel = viewModel()
            val selectedTheme by settingsViewModel.selectedTheme.collectAsState()

            PersonalFinanceAppTheme(selectedTheme = selectedTheme) {
                var showOnboarding by remember { mutableStateOf(!hasSeenOnboarding) }

                if (showOnboarding) {
                    val onboardingViewModel: OnboardingViewModel = viewModel(factory = OnboardingViewModelFactory(application))
                    OnboardingScreen(
                        viewModel = onboardingViewModel,
                        onOnboardingFinished = {
                            settingsRepository.setHasSeenOnboarding(true)
                            showOnboarding = false
                        }
                    )
                } else {
                    FinanceAppWithLockScreen(isInitiallyLocked = settingsRepository.isAppLockEnabledBlocking())
                }
            }
        }
    }
}

@Composable
fun FinanceAppWithLockScreen(isInitiallyLocked: Boolean) {
    val context = LocalContext.current
    val settingsRepository = remember { SettingsRepository(context) }

    var isLocked by remember { mutableStateOf(isInitiallyLocked) }
    val appLockEnabled by settingsRepository.getAppLockEnabled().collectAsState(initial = isInitiallyLocked)

    val permissionsToRequest = arrayOf(
        Manifest.permission.READ_SMS,
        Manifest.permission.RECEIVE_SMS,
        Manifest.permission.POST_NOTIFICATIONS
    )
    val permissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestMultiplePermissions()
    ) { perms ->
        val allPermissionsGranted = perms.all { it.value }
        if (!allPermissionsGranted) {
            Toast.makeText(context, "Some permissions were denied. The app may not function fully.", Toast.LENGTH_LONG).show()
        }
    }

    LaunchedEffect(key1 = true) {
        val areAllPermissionsGranted = permissionsToRequest.all {
            ContextCompat.checkSelfPermission(context, it) == PackageManager.PERMISSION_GRANTED
        }
        if (!areAllPermissionsGranted) {
            permissionLauncher.launch(permissionsToRequest)
        }
    }

    LaunchedEffect(appLockEnabled) {
        if (!appLockEnabled) {
            isLocked = false
        }
    }

    if (isLocked) {
        LockScreen(onUnlock = { isLocked = false })
    } else {
        MainAppScreen()
    }
}


@Composable
fun LockScreen(onUnlock: () -> Unit) {
    val context = LocalContext.current
    val activity = LocalContext.current as FragmentActivity
    val executor: Executor = remember { ContextCompat.getMainExecutor(context) }

    val promptInfo = remember {
        BiometricPrompt.PromptInfo.Builder()
            .setTitle("App Locked")
            .setSubtitle("Authenticate to access your finances")
            .setNegativeButtonText("Cancel")
            .build()
    }

    val biometricPrompt = remember {
        BiometricPrompt(activity, executor,
            object : BiometricPrompt.AuthenticationCallback() {
                override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {
                    super.onAuthenticationSucceeded(result)
                    onUnlock()
                }

                override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {
                    super.onAuthenticationError(errorCode, errString)
                    if (errorCode != BiometricPrompt.ERROR_NEGATIVE_BUTTON && errorCode != BiometricPrompt.ERROR_USER_CANCELED) {
                        Toast.makeText(context, "Authentication error: $errString", Toast.LENGTH_SHORT).show()
                    }
                }

                override fun onAuthenticationFailed() {
                    super.onAuthenticationFailed()
                    Toast.makeText(context, "Authentication failed", Toast.LENGTH_SHORT).show()
                }
            })
    }

    LaunchedEffect(Unit) {
        biometricPrompt.authenticate(promptInfo)
    }

    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Button(onClick = { biometricPrompt.authenticate(promptInfo) }) {
            Icon(Icons.Default.Fingerprint, contentDescription = null, modifier = Modifier.size(24.dp))
            Spacer(Modifier.width(8.dp))
            Text("Unlock App")
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainAppScreen() {
    val navController = rememberNavController()

    val dashboardViewModel: DashboardViewModel = viewModel(factory = DashboardViewModelFactory(LocalContext.current.applicationContext as Application))
    val settingsViewModel: SettingsViewModel = viewModel()
    val transactionViewModel: TransactionViewModel = viewModel()
    val accountViewModel: AccountViewModel = viewModel()
    val categoryViewModel: CategoryViewModel = viewModel()
    val budgetViewModel: BudgetViewModel = viewModel()
    val profileViewModel: ProfileViewModel = viewModel()
    val incomeViewModel: IncomeViewModel = viewModel()
    val goalViewModel: GoalViewModel = viewModel()

    val userName by dashboardViewModel.userName.collectAsState()
    val profilePictureUri by dashboardViewModel.profilePictureUri.collectAsState()
    val filterState by transactionViewModel.filterState.collectAsState()
    val isCustomizationMode by dashboardViewModel.isCustomizationMode.collectAsState()
    val selectedTheme by settingsViewModel.selectedTheme.collectAsState()


    val bottomNavItems = listOf(
        BottomNavItem.Dashboard,
        BottomNavItem.Transactions,
        BottomNavItem.Reports
    )

    val navBackStackEntry by navController.currentBackStackEntryAsState()
    val currentDestination = navBackStackEntry?.destination
    val currentRoute = currentDestination?.route
    val baseCurrentRoute = currentRoute?.split("?")?.firstOrNull()?.split("/")?.firstOrNull()

    val showBottomBar = bottomNavItems.any { it.route == baseCurrentRoute }

    val showMainTopBar = baseCurrentRoute !in setOf(
        "transaction_detail",
        "income_screen",
        "splash_screen",
        "add_transaction",
        "time_period_report_screen",
        "link_recurring_transaction",
        "appearance_settings",
        "automation_settings",
        "notification_settings",
        "data_settings"
    )

    val currentTitle = if (showBottomBar) {
        if (isCustomizationMode) "Customize Dashboard" else "Hi, $userName!"
    } else {
        screenTitles[currentRoute] ?: screenTitles[baseCurrentRoute] ?: "Finance App"
    }
    val showProfileIcon = showBottomBar && !isCustomizationMode

    val fabRoutes = setOf(
        "account_list",
        "recurring_transactions"
    )
    val showFab = baseCurrentRoute in fabRoutes && !isCustomizationMode

    val activity = LocalContext.current as AppCompatActivity

    Box(modifier = Modifier.fillMaxSize()) {
        when (selectedTheme) {
            AppTheme.AURORA -> {
                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {}
                AuroraAnimatedBackground()
            }
            AppTheme.DAYBREAK -> {
                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {}
                DaybreakAnimatedBackground()
            }
            else -> {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {}
            }
        }

        Scaffold(
            topBar = {
                if (showMainTopBar) {
                    TopAppBar(
                        title = { Text(currentTitle) },
                        navigationIcon = {
                            if (showProfileIcon) {
                                AsyncImage(
                                    model = profilePictureUri,
                                    contentDescription = "User Profile Picture",
                                    placeholder = painterResource(id = R.drawable.ic_launcher_foreground),
                                    error = painterResource(id = R.drawable.ic_launcher_foreground),
                                    contentScale = ContentScale.Crop,
                                    modifier = Modifier
                                        .padding(start = 16.dp)
                                        .size(36.dp)
                                        .clip(CircleShape)
                                        .background(MaterialTheme.colorScheme.surfaceVariant)
                                        .clickable { navController.navigate("profile") }
                                )
                            } else if (!showBottomBar) {
                                IconButton(onClick = { navController.popBackStack() }) {
                                    Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                                }
                            }
                        },
                        actions = {
                            if (isCustomizationMode) {
                                IconButton(onClick = { dashboardViewModel.onAddCardClick() }) {
                                    Icon(Icons.Default.Add, contentDescription = "Add Card")
                                }
                                TextButton(onClick = { dashboardViewModel.exitCustomizationModeAndSave() }) {
                                    Text("Done")
                                }
                            } else {
                                when (baseCurrentRoute) {
                                    BottomNavItem.Dashboard.route -> {
                                        IconButton(onClick = { navController.navigate("search_screen") }) {
                                            Icon(Icons.Default.Search, contentDescription = "Search")
                                        }
                                    }
                                    BottomNavItem.Transactions.route -> {
                                        val areFiltersActive by remember(filterState) {
                                            derivedStateOf {
                                                filterState.keyword.isNotBlank() || filterState.account != null || filterState.category != null
                                            }
                                        }
                                        IconButton(onClick = { navController.navigate("add_transaction") }) {
                                            Icon(Icons.Default.Add, contentDescription = "Add Transaction")
                                        }
                                        BadgedBox(
                                            badge = {
                                                if (areFiltersActive) {
                                                    Box(
                                                        modifier = Modifier
                                                            .size(8.dp)
                                                            .clip(CircleShape)
                                                            .background(MaterialTheme.colorScheme.primary)
                                                    )
                                                }
                                            }
                                        ) {
                                            IconButton(onClick = { transactionViewModel.onFilterClick() }) {
                                                Icon(Icons.Default.FilterList, contentDescription = "Filter Transactions")
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent)
                    )
                }
            },
            bottomBar = {
                if (showBottomBar) {
                    NavigationBar(
                        containerColor = Color.Transparent
                    ) {
                        bottomNavItems.forEach { screen ->
                            val isSelected = currentDestination?.hierarchy?.any { it.route == screen.route } == true
                            NavigationBarItem(
                                icon = { Icon(screen.icon, contentDescription = screen.label) },
                                label = { Text(screen.label) },
                                selected = isSelected,
                                onClick = {
                                    navController.navigate(screen.route) {
                                        popUpTo(BottomNavItem.Dashboard.route) {
                                            saveState = true
                                        }
                                        launchSingleTop = true
                                        restoreState = true
                                    }
                                }
                            )
                        }
                    }
                }
            },
            floatingActionButton = {
                if (showFab) {
                    FloatingActionButton(onClick = {
                        when (baseCurrentRoute) {
                            "account_list" -> {
                                navController.navigate("add_account")
                            }
                            "recurring_transactions" -> {
                                navController.navigate("add_recurring_transaction")
                            }
                        }
                    }) {
                        Icon(Icons.Filled.Add, contentDescription = "Add Transaction or Account")
                    }
                }
            },
            containerColor = Color.Transparent
        ) { innerPadding ->
            AppNavHost(
                navController = navController,
                modifier = Modifier.padding(innerPadding),
                activity = activity,
                dashboardViewModel = dashboardViewModel,
                settingsViewModel = settingsViewModel,
                transactionViewModel = transactionViewModel,
                accountViewModel = accountViewModel,
                categoryViewModel = categoryViewModel,
                budgetViewModel = budgetViewModel,
                profileViewModel = profileViewModel,
                incomeViewModel = incomeViewModel,
                goalViewModel = goalViewModel
            )
        }
    }
}


@RequiresApi(Build.VERSION_CODES.TIRAMISU)
@Composable
fun AppNavHost(
    navController: NavHostController,
    modifier: Modifier = Modifier,
    activity: AppCompatActivity,
    dashboardViewModel: DashboardViewModel,
    settingsViewModel: SettingsViewModel,
    transactionViewModel: TransactionViewModel,
    accountViewModel: AccountViewModel,
    categoryViewModel: CategoryViewModel,
    budgetViewModel: BudgetViewModel,
    profileViewModel: ProfileViewModel,
    incomeViewModel: IncomeViewModel,
    goalViewModel: GoalViewModel
) {
    NavHost(
        navController = navController,
        startDestination = "splash_screen",
        modifier = modifier
    ) {
        // --- FIX: Define transitions inline for each composable to fix type errors ---
        composable("splash_screen") {
            SplashScreen(navController = navController, activity = activity)
        }

        composable(
            "manage_parse_rules",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) {
            ManageParseRulesScreen(navController)
        }
        composable(
            "manage_ignore_rules",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) {
            ManageIgnoreRulesScreen()
        }

        composable(BottomNavItem.Dashboard.route) {
            DashboardScreen(navController, dashboardViewModel)
        }
        composable(
            route = BottomNavItem.Transactions.route,
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) {
            TransactionListScreen(
                navController = navController,
                viewModel = transactionViewModel
            )
        }
        composable(
            route = BottomNavItem.Reports.route,
            deepLinks = listOf(navDeepLink { uriPattern = "app://finlight.pm.io/reports" }),
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { ReportsScreen(navController, viewModel()) }

        composable(
            "profile",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) {
            ProfileScreen(
                navController = navController,
                profileViewModel = profileViewModel,
                settingsViewModel = settingsViewModel
            )
        }
        composable(
            "edit_profile",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { EditProfileScreen(navController, profileViewModel) }
        composable(
            "csv_validation_screen",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { CsvValidationScreen(navController, settingsViewModel) }
        composable(
            "search_screen",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { SearchScreen(navController) }
        composable(
            route = "review_sms_screen",
            deepLinks = listOf(navDeepLink { uriPattern = "app://finlight.pm.io/review_sms" }),
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { ReviewSmsScreen(navController, settingsViewModel) }

        composable(
            "income_screen",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) {
            IncomeScreen(navController, incomeViewModel)
        }

        composable(
            route = "approve_transaction_screen?potentialTxnJson={potentialTxnJson}",
            arguments = listOf(navArgument("potentialTxnJson") { type = NavType.StringType }),
            deepLinks = listOf(navDeepLink { uriPattern = "app://finlight.pm.io/approve_sms?potentialTxnJson={potentialTxnJson}" }),
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { backStackEntry ->
            val json = backStackEntry.arguments?.getString("potentialTxnJson")
            val potentialTxn = Gson().fromJson(URLDecoder.decode(json, "UTF-8"), PotentialTransaction::class.java)

            ApproveTransactionScreen(
                navController = navController,
                transactionViewModel = transactionViewModel,
                settingsViewModel = settingsViewModel,
                potentialTxn = potentialTxn
            )
        }

        composable(
            "add_transaction?isCsvEdit={isCsvEdit}&csvLineNumber={csvLineNumber}&initialDataJson={initialDataJson}",
            arguments = listOf(
                navArgument("isCsvEdit") { type = NavType.BoolType; defaultValue = false },
                navArgument("csvLineNumber") { type = NavType.IntType; defaultValue = -1 },
                navArgument("initialDataJson") { type = NavType.StringType; nullable = true; defaultValue = null }
            ),
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { backStackEntry ->
            val arguments = requireNotNull(backStackEntry.arguments)
            AddTransactionScreen(
                navController = navController,
                viewModel = transactionViewModel,
                isCsvEdit = arguments.getBoolean("isCsvEdit"),
                csvLineNumber = arguments.getInt("csvLineNumber"),
                initialDataJson = arguments.getString("initialDataJson")?.let { URLDecoder.decode(it, "UTF-8") }
            )
        }

        composable(
            route = "transaction_detail/{transactionId}",
            arguments = listOf(navArgument("transactionId") { type = NavType.IntType }),
            deepLinks = listOf(navDeepLink { uriPattern = "app://finlight.pm.io/transaction_detail/{transactionId}" }),
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { backStackEntry ->
            val transactionId = backStackEntry.arguments!!.getInt("transactionId")
            TransactionDetailScreen(
                navController = navController,
                transactionId = transactionId,
                viewModel = transactionViewModel,
                accountViewModel = accountViewModel,
                onSaveRenameRule = { original, new -> settingsViewModel.saveMerchantRenameRule(original, new) }
            )
        }

        composable(
            "account_list",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { AccountListScreen(navController, accountViewModel) }

        composable(
            "add_account",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) {
            AddEditAccountScreen(navController, accountViewModel, null)
        }
        composable(
            "edit_account/{accountId}",
            arguments = listOf(navArgument("accountId") { type = NavType.IntType }),
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { backStackEntry ->
            AddEditAccountScreen(navController, accountViewModel, backStackEntry.arguments!!.getInt("accountId"))
        }

        composable(
            "account_detail/{accountId}",
            arguments = listOf(navArgument("accountId") { type = NavType.IntType }),
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { backStackEntry ->
            AccountDetailScreen(navController, accountViewModel, backStackEntry.arguments!!.getInt("accountId"))
        }
        composable(
            "budget_screen",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { BudgetScreen(navController, budgetViewModel) }
        composable(
            "add_budget",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { AddEditBudgetScreen(navController, budgetViewModel, null) }
        composable(
            "edit_budget/{budgetId}",
            arguments = listOf(navArgument("budgetId") { type = NavType.IntType }),
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { backStackEntry ->
            AddEditBudgetScreen(navController, budgetViewModel, backStackEntry.arguments?.getInt("budgetId"))
        }
        composable(
            "category_list",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { CategoryListScreen(navController, categoryViewModel) }
        composable(
            "tag_management",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { TagManagementScreen() }
        composable(
            "recurring_transactions",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { RecurringTransactionScreen(navController) }

        composable(
            "add_recurring_transaction?ruleId={ruleId}",
            arguments = listOf(navArgument("ruleId") { type = NavType.IntType; defaultValue = -1 }),
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { backStackEntry ->
            val ruleId = backStackEntry.arguments?.getInt("ruleId")
            AddRecurringTransactionScreen(navController = navController, ruleId = if (ruleId == -1) null else ruleId)
        }

        composable(
            "rule_creation_screen?potentialTransactionJson={potentialTransactionJson}&ruleId={ruleId}",
            arguments = listOf(
                navArgument("potentialTransactionJson") { type = NavType.StringType; nullable = true },
                navArgument("ruleId") { type = NavType.IntType; defaultValue = -1 }
            ),
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { backStackEntry ->
            val json = backStackEntry.arguments?.getString("potentialTransactionJson")
            val ruleId = backStackEntry.arguments?.getInt("ruleId")
            RuleCreationScreen(
                navController = navController,
                potentialTransactionJson = json?.let { URLDecoder.decode(it, "UTF-8") },
                ruleId = if (ruleId == -1) null else ruleId
            )
        }

        composable(
            "link_transaction_screen/{potentialTransactionJson}",
            arguments = listOf(navArgument("potentialTransactionJson") { type = NavType.StringType }),
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { backStackEntry ->
            val json = backStackEntry.arguments?.getString("potentialTransactionJson") ?: ""
            LinkTransactionScreen(navController = navController, potentialTransactionJson = json)
        }

        composable(
            route = "link_recurring_transaction/{potentialTransactionJson}",
            arguments = listOf(navArgument("potentialTransactionJson") { type = NavType.StringType }),
            deepLinks = listOf(navDeepLink { uriPattern = "app://finlight.pm.io/link_recurring/{potentialTransactionJson}" }),
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { backStackEntry ->
            val json = backStackEntry.arguments?.getString("potentialTransactionJson") ?: ""
            LinkRecurringTransactionScreen(navController = navController, potentialTransactionJson = json)
        }

        composable(
            "time_period_report_screen/{timePeriod}?date={date}",
            arguments = listOf(
                navArgument("timePeriod") { type = NavType.EnumType(TimePeriod::class.java) },
                navArgument("date") { type = NavType.LongType; defaultValue = -1L }
            ),
            deepLinks = listOf(navDeepLink { uriPattern = "app://finlight.pm.io/report/{timePeriod}?date={date}" }),
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) { backStackEntry ->
            val timePeriod = backStackEntry.arguments?.getSerializable("timePeriod", TimePeriod::class.java)
            val date = backStackEntry.arguments?.getLong("date")
            if (timePeriod != null) {
                TimePeriodReportScreen(navController = navController, timePeriod = timePeriod, initialDateMillis = date)
            }
        }

        composable(
            "goals_screen",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) {
            GoalScreen(navController = navController, goalViewModel = goalViewModel)
        }

        composable(
            "appearance_settings",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) {
            AppearanceSettingsScreen(navController, settingsViewModel)
        }
        composable(
            "automation_settings",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) {
            AutomationSettingsScreen(navController, settingsViewModel)
        }
        composable(
            "notification_settings",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) {
            NotificationSettingsScreen(navController, settingsViewModel)
        }
        composable(
            "data_settings",
            enterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { 1000 }, animationSpec = tween(300)) },
            exitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { -1000 }, animationSpec = tween(300)) },
            popEnterTransition = { fadeIn(animationSpec = tween(300)) + slideInHorizontally(initialOffsetX = { -1000 }, animationSpec = tween(300)) },
            popExitTransition = { fadeOut(animationSpec = tween(300)) + slideOutHorizontally(targetOffsetX = { 1000 }, animationSpec = tween(300)) }
        ) {
            DataSettingsScreen(navController, settingsViewModel)
        }
    }
}

@Composable
fun SplashScreen(navController: NavHostController, activity: Activity) {
    LaunchedEffect(key1 = Unit) {
        val deepLinkUri = activity.intent?.data
        if (deepLinkUri != null) {
            navController.navigate(BottomNavItem.Dashboard.route) {
                popUpTo("splash_screen") { inclusive = true }
            }
            navController.navigate(deepLinkUri)
            activity.intent.data = null
        } else {
            navController.navigate(BottomNavItem.Dashboard.route) {
                popUpTo("splash_screen") { inclusive = true }
            }
        }
    }

    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        CircularProgressIndicator()
    }
}
-e 


================== FILE: ./app/src/main/java/RecurringTransactionRepository.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/RecurringTransactionRepository.kt
// REASON: FEATURE - The repository has been updated to expose `getById`,
// `update`, and `delete` functions, providing a complete data access layer
// for managing recurring rules. This resolves the "Unresolved reference" errors
// in the ViewModel.
// =================================================================================
package io.pm.finlight

import kotlinx.coroutines.flow.Flow

class RecurringTransactionRepository(private val recurringTransactionDao: RecurringTransactionDao) {
    fun getAll(): Flow<List<RecurringTransaction>> {
        return recurringTransactionDao.getAllRulesFlow()
    }

    fun getById(id: Int): Flow<RecurringTransaction?> {
        return recurringTransactionDao.getById(id)
    }

    suspend fun insert(recurringTransaction: RecurringTransaction) {
        recurringTransactionDao.insert(recurringTransaction)
    }

    suspend fun update(recurringTransaction: RecurringTransaction) {
        recurringTransactionDao.update(recurringTransaction)
    }

    suspend fun delete(recurringTransaction: RecurringTransaction) {
        recurringTransactionDao.delete(recurringTransaction)
    }
}
-e 


================== FILE: ./app/src/main/java/OnboardingViewModelFactory.kt ==================
// FILE: app/src/main/java/io/pm/finlight/OnboardingViewModelFactory.kt

package io.pm.finlight

import android.app.Application
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider

/**
 * Factory for creating an OnboardingViewModel.
 */
class OnboardingViewModelFactory(private val application: Application) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(OnboardingViewModel::class.java)) {
            val db = AppDatabase.getInstance(application)
            // --- UPDATED: AccountRepository is no longer needed for onboarding ---
            val categoryRepository = CategoryRepository(db.categoryDao())
            val settingsRepository = SettingsRepository(application)

            @Suppress("UNCHECKED_CAST")
            // --- UPDATED: Pass only the required dependencies ---
            return OnboardingViewModel(categoryRepository, settingsRepository) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
-e 


================== FILE: ./app/src/main/java/BankLogoHelper.kt ==================
package io.pm.finlight

import androidx.annotation.DrawableRes

/**
 * A helper object to provide logos for various Indian banks.
 */
object BankLogoHelper {

    /**
     * Returns the drawable resource ID for a bank's logo based on the account name.
     *
     * @param accountName The name of the account (e.g., "HDFC Bank Savings", "My SBI Card").
     * @return The resource ID for the matching logo, or a default bank icon if no match is found.
     */
    @DrawableRes
    fun getLogoForAccount(accountName: String): Int {
        val lowerCaseName = accountName.lowercase()
        return when {
            "hdfc" in lowerCaseName -> R.drawable.ic_hdfc_logo
            "icici" in lowerCaseName -> R.drawable.ic_icici_logo
            "sbi" in lowerCaseName || "state bank" in lowerCaseName -> R.drawable.ic_sbi_logo
            "axis" in lowerCaseName -> R.drawable.ic_axis_logo
            "kotak" in lowerCaseName || "kotak mahindra" in lowerCaseName -> R.drawable.ic_kotak_logo
            "pnb" in lowerCaseName || "punjab national" in lowerCaseName -> R.drawable.ic_pnb_logo
            "baroda" in lowerCaseName -> R.drawable.ic_bob_logo
            "canara" in lowerCaseName -> R.drawable.ic_canara_logo
            "yes" in lowerCaseName -> R.drawable.ic_yes_logo
            "indusind" in lowerCaseName -> R.drawable.ic_indusind_logo
            "idfc" in lowerCaseName -> R.drawable.ic_idfc_logo
            "citi" in lowerCaseName -> R.drawable.ic_citi_logo
            "bandan" in lowerCaseName -> R.drawable.ic_bandan_logo
            "bank of america" in lowerCaseName || "boa" in lowerCaseName -> R.drawable.ic_boa_logo
            "bank of india" in lowerCaseName || "boi" in lowerCaseName -> R.drawable.ic_boi_logo
            "bank of maharastra" in lowerCaseName || "bom" in lowerCaseName -> R.drawable.ic_bom_logo
            "central" in lowerCaseName -> R.drawable.ic_cbi_logo
            "union" in lowerCaseName -> R.drawable.ic_cub_logo
            "credit suisse" in lowerCaseName -> R.drawable.ic_creditsuisse_logo
            "hsbc" in lowerCaseName -> R.drawable.ic_hsbc_logo
            "idbi" in lowerCaseName -> R.drawable.ic_idbi_logo
            "indian overseas" in lowerCaseName || "iob" in lowerCaseName -> R.drawable.ic_iob_logo
            "jpmorgan chase" in lowerCaseName || "jpm" in lowerCaseName -> R.drawable.ic_jpm_logo
            "karnataka" in lowerCaseName -> R.drawable.ic_kb_logo
            "natwest" in lowerCaseName -> R.drawable.ic_natwest_logo
            "standard chartered" in lowerCaseName -> R.drawable.ic_standardchartered_logo
            "cash" in lowerCaseName -> R.drawable.ic_cash_spends
            else -> R.drawable.ic_default_bank_logo // Default fallback icon
        }
    }
}
-e 


================== FILE: ./app/src/main/java/Goal.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/Goal.kt
// REASON: NEW FILE - Defines the Room entity for a savings goal, including its
// name, target and saved amounts, target date, and the associated account.
// =================================================================================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "goals",
    foreignKeys = [
        ForeignKey(
            entity = Account::class,
            parentColumns = ["id"],
            childColumns = ["accountId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index(value = ["accountId"])]
)
data class Goal(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val name: String,
    val targetAmount: Double,
    var savedAmount: Double,
    val targetDate: Long?,
    val accountId: Int
)
-e 


================== FILE: ./app/src/main/java/TagRepository.kt ==================
package io.pm.finlight

import kotlinx.coroutines.flow.Flow

/**
 * Repository that abstracts access to the tag data source.
 * Now includes update and delete logic.
 */
class TagRepository(
    private val tagDao: TagDao,
    private val transactionDao: TransactionDao
) {

    val allTags: Flow<List<Tag>> = tagDao.getAllTags()

    // --- FIX: Modified to return the new row's ID from the DAO ---
    suspend fun insert(tag: Tag): Long {
        return tagDao.insert(tag)
    }

    suspend fun update(tag: Tag) {
        tagDao.update(tag)
    }

    suspend fun delete(tag: Tag) {
        tagDao.delete(tag)
    }

    suspend fun isTagInUse(tagId: Int): Boolean {
        return transactionDao.countTransactionsForTag(tagId) > 0
    }
}
-e 


================== FILE: ./app/src/main/java/MonthlySummary.kt ==================
package io.pm.finlight

/**
 * A data class to hold the results of a GROUP BY query for monthly summaries.
 */
data class MonthlySummary(
    val year: Int,
    val month: Int,
    val totalAmount: Double,
)
-e 


================== FILE: ./app/src/main/java/CustomSmsRule.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/CustomSmsRule.kt
// REASON: FEATURE - Added a new `sourceSmsBody` column. This will store the
// original SMS text that the rule was created from, which is a necessary
// foundation for the upcoming "Edit Rule" feature.
// =================================================================================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.Index
import androidx.room.PrimaryKey

/**
 * Represents a user-defined parsing rule that is independent of the SMS sender.
 * The rule is activated when its 'triggerPhrase' is found within an SMS body.
 *
 * @param id The unique identifier for the rule.
 * @param triggerPhrase A stable, unique piece of text from an SMS that identifies
 * when this rule should be applied (e.g., "spent on your SBI Credit Card").
 * @param merchantRegex The regex pattern to extract the merchant name. Can be null.
 * @param amountRegex The regex pattern to extract the transaction amount. Can be null.
 * @param accountRegex The regex pattern to extract the account name/number. Can be null.
 * @param merchantNameExample The user-selected text for the merchant, for display purposes.
 * @param amountExample The user-selected text for the amount, for display purposes.
 * @param accountNameExample The user-selected text for the account, for display purposes.
 * @param priority The execution priority. Higher numbers are checked first.
 * @param sourceSmsBody The original SMS text this rule was created from.
 */
@Entity(
    tableName = "custom_sms_rules",
    indices = [Index(value = ["triggerPhrase"], unique = true)]
)
data class CustomSmsRule(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val triggerPhrase: String,
    val merchantRegex: String?,
    val amountRegex: String?,
    val accountRegex: String?,
    val merchantNameExample: String?,
    val amountExample: String?,
    val accountNameExample: String?,
    val priority: Int,
    val sourceSmsBody: String
)
-e 


================== FILE: ./app/src/main/java/CategoryRepository.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/CategoryRepository.kt
// REASON: Updated the insert function to return the new category's ID (Long) and
// added a function to get a category by its ID.
// =================================================================================
package io.pm.finlight

import kotlinx.coroutines.flow.Flow

/**
 * Repository that abstracts access to the category data source.
 */
class CategoryRepository(private val categoryDao: CategoryDao) {
    /**
     * Retrieves all categories from the category table, ordered by name.
     */
    val allCategories: Flow<List<Category>> = categoryDao.getAllCategories()

    /**
     * Retrieves a single category by its unique ID.
     */
    suspend fun getCategoryById(id: Int): Category? {
        return categoryDao.getCategoryById(id)
    }

    /**
     * Inserts a category in a non-blocking way.
     */
    suspend fun insert(category: Category): Long {
        return categoryDao.insert(category)
    }

    /**
     * Inserts a list of categories in a non-blocking way.
     */
    suspend fun insertAll(categories: List<Category>) {
        categoryDao.insertAll(categories)
    }

    /**
     * Updates a category in a non-blocking way.
     */
    suspend fun update(category: Category) {
        categoryDao.update(category)
    }

    /**
     * Deletes a category in a non-blocking way.
     */
    suspend fun delete(category: Category) {
        categoryDao.delete(category)
    }
}
-e 


================== FILE: ./app/src/main/java/MerchantMappingDao.kt ==================
package io.pm.finlight

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import kotlinx.coroutines.flow.Flow

@Dao
interface MerchantMappingDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(mapping: MerchantMapping)

    // --- NEW: Function to insert a list of mappings during import ---
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(mappings: List<MerchantMapping>)

    // --- NEW: Function to clear the table during import ---
    @Query("DELETE FROM merchant_mappings")
    suspend fun deleteAll()

    @Query("SELECT * FROM merchant_mappings")
    fun getAllMappings(): Flow<List<MerchantMapping>>

    @Query("SELECT * FROM merchant_mappings WHERE smsSender = :sender")
    suspend fun getMappingForSender(sender: String): MerchantMapping?
}
-e 


================== FILE: ./app/src/main/java/MerchantMappingRepository.kt ==================
package io.pm.finlight

import kotlinx.coroutines.flow.Flow

/**
 * Repository that abstracts access to the MerchantMapping data source.
 */
class MerchantMappingRepository(private val merchantMappingDao: MerchantMappingDao) {
    /**
     * Retrieves all user-defined merchant mappings from the database.
     */
    val allMappings: Flow<List<MerchantMapping>> = merchantMappingDao.getAllMappings()

    /**
     * Inserts a new or updated mapping into the database.
     */
    suspend fun insert(mapping: MerchantMapping) {
        merchantMappingDao.insert(mapping)
    }

    /**
     * Gets a specific mapping for a given SMS sender address.
     */
    suspend fun getMappingForSender(sender: String): MerchantMapping? {
        return merchantMappingDao.getMappingForSender(sender)
    }
}
-e 


================== FILE: ./app/src/main/java/ManageParseRulesViewModel.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ManageParseRulesViewModel.kt
// REASON: NEW FILE - This ViewModel provides the logic for the new rule management
// screen. It fetches all custom SMS parsing rules from the database and exposes
// them as a StateFlow for the UI. It also includes a function to handle the
// deletion of a specific rule.
// =================================================================================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

class ManageParseRulesViewModel(application: Application) : AndroidViewModel(application) {

    private val customSmsRuleDao = AppDatabase.getInstance(application).customSmsRuleDao()

    /**
     * A flow of all custom SMS parsing rules, collected as StateFlow for the UI.
     */
    val allRules: StateFlow<List<CustomSmsRule>> = customSmsRuleDao.getAllRules()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )

    /**
     * Deletes a given custom rule from the database.
     *
     * @param rule The rule to be deleted.
     */
    fun deleteRule(rule: CustomSmsRule) {
        viewModelScope.launch {
            customSmsRuleDao.delete(rule)
        }
    }
}
-e 


================== FILE: ./app/src/main/java/ProfileViewModel.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ProfileViewModel.kt
// REASON: Added a function to handle updating the user's name in SharedPreferences.
// =================================================================================
package io.pm.finlight

import android.app.Application
import android.net.Uri
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream

class ProfileViewModel(application: Application) : AndroidViewModel(application) {

    private val settingsRepository = SettingsRepository(application)
    private val context = application

    val userName: StateFlow<String> = settingsRepository.getUserName()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = "User"
        )

    val profilePictureUri: StateFlow<String?> = settingsRepository.getProfilePictureUri()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = null
        )

    /**
     * Saves the cropped image from the source URI to internal storage and persists its path.
     */
    fun saveProfilePictureUri(sourceUri: Uri?) {
        viewModelScope.launch {
            if (sourceUri == null) {
                settingsRepository.saveProfilePictureUri(null)
                return@launch
            }
            // Copy the file to internal storage and get the new path
            val localPath = saveImageToInternalStorage(sourceUri)
            // Save the path to our new local file
            settingsRepository.saveProfilePictureUri(localPath)
        }
    }

    // --- NEW: Function to save the updated user name ---
    fun updateUserName(name: String) {
        viewModelScope.launch {
            if (name.isNotBlank()) {
                settingsRepository.saveUserName(name)
            }
        }
    }

    /**
     * Copies a file from a given content URI to the app's private internal storage.
     * @param sourceUri The temporary URI of the file to copy (e.g., from the image cropper).
     * @return The absolute path to the newly created file, or null if an error occurred.
     */
    private suspend fun saveImageToInternalStorage(sourceUri: Uri): String? {
        return withContext(Dispatchers.IO) {
            try {
                // Open an input stream from the source URI provided by the cropper
                val inputStream = context.contentResolver.openInputStream(sourceUri)

                // Create a destination file in the app's private 'files' directory
                val fileName = "profile_${System.currentTimeMillis()}.jpg"
                val file = File(context.filesDir, fileName)

                // Open an output stream to the destination file
                val outputStream = FileOutputStream(file)

                // Copy the bytes from the input stream to the output stream
                inputStream?.use { input ->
                    outputStream.use { output ->
                        input.copyTo(output)
                    }
                }

                // Return the path of the file we just created
                file.absolutePath
            } catch (e: Exception) {
                Log.e("ProfileViewModel", "Error saving image to internal storage", e)
                null
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/LoginRequest.kt ==================
package io.pm.finlight

data class LoginRequest(
    val email: String,
    val password: String,
)
-e 


================== FILE: ./app/src/main/java/OnboardingViewModel.kt ==================
package io.pm.finlight

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

class OnboardingViewModel(
    private val categoryRepository: CategoryRepository,
    private val settingsRepository: SettingsRepository
) : ViewModel() {

    private val _userName = MutableStateFlow("")
    val userName = _userName.asStateFlow()

    private val _monthlyBudget = MutableStateFlow("")
    val monthlyBudget = _monthlyBudget.asStateFlow()

    fun onNameChanged(newName: String) {
        _userName.value = newName
    }

    fun onBudgetChanged(newBudget: String) {
        if (newBudget.all { it.isDigit() }) {
            _monthlyBudget.value = newBudget
        }
    }

    fun finishOnboarding() {
        viewModelScope.launch {
            if (_userName.value.isNotBlank()) {
                settingsRepository.saveUserName(_userName.value)
            }

            // --- BUG FIX: Ensure the full list of predefined categories is inserted ---
            // This replaces any faulty logic that was creating a few default categories.
            // It guarantees all users start with the complete, visually-rich category set.
            categoryRepository.insertAll(CategoryIconHelper.predefinedCategories)

            val budgetFloat = _monthlyBudget.value.toFloatOrNull() ?: 0f
            if (budgetFloat > 0) {
                settingsRepository.saveOverallBudgetForCurrentMonth(budgetFloat)
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/GoalRepository.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/GoalRepository.kt
// REASON: NEW FILE - Creates a repository to abstract the Goal data source,
// providing a clean API for the ViewModel to interact with the DAO.
// =================================================================================
package io.pm.finlight

import kotlinx.coroutines.flow.Flow

class GoalRepository(private val goalDao: GoalDao) {

    fun getAllGoalsWithAccountName(): Flow<List<GoalWithAccountName>> = goalDao.getAllGoalsWithAccountName()

    fun getGoalById(id: Int): Flow<Goal?> = goalDao.getGoalById(id)

    suspend fun insert(goal: Goal) {
        goalDao.insert(goal)
    }

    suspend fun update(goal: Goal) {
        goalDao.update(goal)
    }

    suspend fun delete(goal: Goal) {
        goalDao.delete(goal)
    }
}
-e 


================== FILE: ./app/src/main/java/SmsRepository.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/SmsRepository.kt
// REASON: Making the fallback SMS lookup more robust. Instead of an exact date
// match, we now find the SMS with the mathematically closest timestamp, which
// fixes the bug where original messages couldn't be found for rule creation.
// =================================================================================
package io.pm.finlight

import android.content.Context
import android.provider.Telephony
import android.util.Log

/**
 * A repository class dedicated to handling data operations related to SMS messages.
 * This abstracts the logic of querying the Android ContentResolver away from ViewModels or Workers.
 */
class SmsRepository(private val context: Context) {
    /**
     * Fetches all SMS messages from the device's inbox.
     * @return A list of SmsMessage objects.
     */
    fun fetchAllSms(startDate: Long?): List<SmsMessage> {
        val smsList = mutableListOf<SmsMessage>()
        // Define the columns we want to retrieve
        val projection =
            arrayOf(
                Telephony.Sms._ID,
                Telephony.Sms.ADDRESS,
                Telephony.Sms.BODY,
                Telephony.Sms.DATE,
            )
        val selection: String?
        val selectionArgs: Array<String>?

        if (startDate != null) {
            selection = "${Telephony.Sms.DATE} >= ?"
            selectionArgs = arrayOf(startDate.toString())
            Log.d("SmsRepository", "Querying SMS with start date: $startDate")
        } else {
            selection = null
            selectionArgs = null
            Log.d("SmsRepository", "Querying all SMS messages.")
        }

        // Query the SMS inbox, sorting by date in descending order
        val cursor =
            context.contentResolver.query(
                Telephony.Sms.Inbox.CONTENT_URI,
                projection,
                selection,
                selectionArgs,
                "date DESC",
            )

        cursor?.use {
            // Get column indices once for efficiency
            val idIndex = it.getColumnIndexOrThrow(Telephony.Sms._ID)
            val addressIndex = it.getColumnIndexOrThrow(Telephony.Sms.ADDRESS)
            val bodyIndex = it.getColumnIndexOrThrow(Telephony.Sms.BODY)
            val dateIndex = it.getColumnIndexOrThrow(Telephony.Sms.DATE)

            while (it.moveToNext()) {
                smsList.add(
                    SmsMessage(
                        id = it.getLong(idIndex),
                        sender = it.getString(addressIndex) ?: "Unknown",
                        body = it.getString(bodyIndex) ?: "",
                        date = it.getLong(dateIndex),
                    ),
                )
            }
        }
        return smsList
    }

    /**
     * Fetches a single SMS message by its ID or timestamp.
     * This function first attempts to find the SMS by its database _ID.
     * If that fails, it falls back to searching by the timestamp (date), providing a robust way to
     * find the original message for transactions created via different import paths.
     *
     * @param lookupValue The value to search for, which could be the SMS _ID or its timestamp.
     * @return An SmsMessage object if found, otherwise null.
     */
    fun getSmsDetailsById(lookupValue: Long): SmsMessage? {
        val projection = arrayOf(Telephony.Sms._ID, Telephony.Sms.ADDRESS, Telephony.Sms.BODY, Telephony.Sms.DATE)

        // --- First Attempt: Query by the proper database _ID ---
        var selection = "${Telephony.Sms._ID} = ?"
        var selectionArgs = arrayOf(lookupValue.toString())

        context.contentResolver.query(
            Telephony.Sms.Inbox.CONTENT_URI,
            projection,
            selection,
            selectionArgs,
            null
        )?.use { cursor ->
            if (cursor.moveToFirst()) {
                val idIndex = cursor.getColumnIndexOrThrow(Telephony.Sms._ID)
                val addressIndex = cursor.getColumnIndexOrThrow(Telephony.Sms.ADDRESS)
                val bodyIndex = cursor.getColumnIndexOrThrow(Telephony.Sms.BODY)
                val dateIndex = cursor.getColumnIndexOrThrow(Telephony.Sms.DATE)

                return SmsMessage(
                    id = cursor.getLong(idIndex),
                    sender = cursor.getString(addressIndex) ?: "Unknown",
                    body = cursor.getString(bodyIndex) ?: "",
                    date = cursor.getLong(dateIndex)
                )
            }
        }

        // --- BUG FIX: A more robust fallback that finds the message with the closest timestamp ---
        // Instead of an exact match, which is fragile, this finds the SMS whose 'date'
        // is mathematically closest to the timestamp we stored.
        val sortOrder = "ABS(date - $lookupValue) ASC LIMIT 1"

        context.contentResolver.query(
            Telephony.Sms.Inbox.CONTENT_URI,
            projection,
            null, // Selection is not needed, we use the sort order
            null, // Selection args are not needed
            sortOrder
        )?.use { cursor ->
            if (cursor.moveToFirst()) {
                val idIndex = cursor.getColumnIndexOrThrow(Telephony.Sms._ID)
                val addressIndex = cursor.getColumnIndexOrThrow(Telephony.Sms.ADDRESS)
                val bodyIndex = cursor.getColumnIndexOrThrow(Telephony.Sms.BODY)
                val dateIndex = cursor.getColumnIndexOrThrow(Telephony.Sms.DATE)

                return SmsMessage(
                    id = cursor.getLong(idIndex),
                    sender = cursor.getString(addressIndex) ?: "Unknown",
                    body = cursor.getString(bodyIndex) ?: "",
                    date = cursor.getLong(dateIndex)
                )
            }
        }


        // If neither query found a result, return null.
        return null
    }
}
-e 


================== FILE: ./app/src/main/java/IgnoreRuleDao.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/IgnoreRuleDao.kt
// REASON: FEATURE - The DAO has been updated with new methods to support the
// enhanced ignore rule management. It can now insert a list of default rules,
// update the enabled status of a rule, and fetch only the active phrases for
// the parser to use.
// =================================================================================
package io.pm.finlight

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import kotlinx.coroutines.flow.Flow

/**
 * Data Access Object (DAO) for the IgnoreRule entity.
 */
@Dao
interface IgnoreRuleDao {

    /**
     * Retrieves all ignore rules from the database, ordered alphabetically.
     * @return A Flow emitting a list of all IgnoreRule objects.
     */
    @Query("SELECT * FROM ignore_rules ORDER BY phrase ASC")
    fun getAll(): Flow<List<IgnoreRule>>

    /**
     * Retrieves all enabled ignore phrases.
     * @return A list of strings containing the active ignore phrases.
     */
    @Query("SELECT phrase FROM ignore_rules WHERE isEnabled = 1")
    suspend fun getEnabledPhrases(): List<String>

    /**
     * Inserts a new ignore rule. If a rule with the same phrase already exists,
     * it will be ignored.
     * @param rule The IgnoreRule object to insert.
     */
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insert(rule: IgnoreRule)

    /**
     * Inserts a list of ignore rules. Used for seeding the database.
     * @param rules The list of IgnoreRule objects to insert.
     */
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insertAll(rules: List<IgnoreRule>)

    /**
     * Updates an existing ignore rule.
     * @param rule The IgnoreRule object to update.
     */
    @Update
    suspend fun update(rule: IgnoreRule)

    /**
     * Deletes a specific ignore rule from the database.
     * @param rule The IgnoreRule object to delete.
     */
    @Delete
    suspend fun delete(rule: IgnoreRule)
}
-e 


================== FILE: ./app/src/main/java/BudgetViewModel.kt ==================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

class BudgetViewModel(application: Application) : AndroidViewModel(application) {
    private val budgetRepository: BudgetRepository
    private val settingsRepository: SettingsRepository
    private val categoryRepository: CategoryRepository

    private val calendar: Calendar = Calendar.getInstance()
    private val currentMonth: Int
    private val currentYear: Int

    val budgetsForCurrentMonth: StateFlow<List<BudgetWithSpending>>
    val overallBudget: StateFlow<Float>
    val allCategories: Flow<List<Category>>
    val availableCategoriesForNewBudget: Flow<List<Category>>
    val totalSpending: StateFlow<Double>

    init {
        val db = AppDatabase.getInstance(application)
        budgetRepository = BudgetRepository(db.budgetDao())
        settingsRepository = SettingsRepository(application)
        categoryRepository = CategoryRepository(db.categoryDao())

        currentMonth = calendar.get(Calendar.MONTH) + 1
        currentYear = calendar.get(Calendar.YEAR)

        val yearMonthString = SimpleDateFormat("yyyy-MM", Locale.getDefault()).format(calendar.time)

        // --- FIX: Corrected the method name from getBudgetsWithSpendingForMonth to getBudgetsForMonthWithSpending ---
        // This resolves the compilation error.
        budgetsForCurrentMonth = budgetRepository.getBudgetsForMonthWithSpending(yearMonthString, currentMonth, currentYear)
            .stateIn(
                scope = viewModelScope,
                started = SharingStarted.WhileSubscribed(5000),
                initialValue = emptyList()
            )

        allCategories = categoryRepository.allCategories

        overallBudget =
            settingsRepository.getOverallBudgetForMonth(currentYear, currentMonth)
                .stateIn(
                    scope = viewModelScope,
                    started = SharingStarted.WhileSubscribed(5000),
                    initialValue = 0f,
                )

        availableCategoriesForNewBudget =
            combine(allCategories, budgetsForCurrentMonth) { categories, budgets ->
                val budgetedCategoryNames = budgets.map { it.budget.categoryName }.toSet()
                categories.filter { category -> category.name !in budgetedCategoryNames }
            }

        totalSpending = budgetsForCurrentMonth.flatMapLatest { budgets ->
            if (budgets.isEmpty()) {
                flowOf(0.0)
            } else {
                val spendingFlows = budgets.map {
                    getActualSpending(it.budget.categoryName)
                }
                combine(spendingFlows) { amounts ->
                    amounts.sum()
                }
            }
        }.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = 0.0
        )
    }

    fun getActualSpending(categoryName: String): Flow<Double> {
        return budgetRepository.getActualSpendingForCategory(categoryName, currentMonth, currentYear)
            .map { spending -> spending ?: 0.0 }
    }

    fun addCategoryBudget(
        categoryName: String,
        amountStr: String,
    ) {
        val amount = amountStr.toDoubleOrNull() ?: return
        if (amount <= 0 || categoryName.isBlank()) {
            return
        }
        val newBudget =
            Budget(
                categoryName = categoryName,
                amount = amount,
                month = currentMonth,
                year = currentYear,
            )
        viewModelScope.launch {
            budgetRepository.insert(newBudget)
        }
    }

    fun saveOverallBudget(budgetStr: String) {
        val budgetFloat = budgetStr.toFloatOrNull() ?: 0f
        settingsRepository.saveOverallBudgetForCurrentMonth(budgetFloat)
    }

    fun getBudgetById(id: Int): Flow<Budget?> {
        return budgetRepository.getBudgetById(id)
    }

    fun updateBudget(budget: Budget) =
        viewModelScope.launch {
            budgetRepository.update(budget)
        }

    fun deleteBudget(budget: Budget) =
        viewModelScope.launch {
            budgetRepository.delete(budget)
        }

    fun getCurrentMonthYearString(): String {
        return SimpleDateFormat("MMMM yyyy", Locale.getDefault()).format(calendar.time)
    }
}
-e 


================== FILE: ./app/src/main/java/AppDatabase.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/AppDatabase.kt
// REASON: REFACTOR - The database version has been incremented to 25. A new
// migration, MIGRATION_24_25, has been added to rebuild the `accounts`,
// `categories`, and `merchant_rename_rules` tables. This migration applies
// case-insensitive (`NOCASE`) constraints to their respective `name` and
// `originalName` columns, ensuring data consistency and preventing duplicates.
// =================================================================================
package io.pm.finlight

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import java.util.Calendar

@Database(
    entities = [
        Transaction::class,
        Account::class,
        Category::class,
        Budget::class,
        MerchantMapping::class,
        RecurringTransaction::class,
        Tag::class,
        TransactionTagCrossRef::class,
        TransactionImage::class,
        CustomSmsRule::class,
        MerchantRenameRule::class,
        MerchantCategoryMapping::class,
        IgnoreRule::class,
        Goal::class
    ],
    version = 25, // --- UPDATED: Incremented version number for schema change ---
    exportSchema = true,
)
abstract class AppDatabase : RoomDatabase() {
    abstract fun transactionDao(): TransactionDao
    abstract fun accountDao(): AccountDao
    abstract fun categoryDao(): CategoryDao
    abstract fun budgetDao(): BudgetDao
    abstract fun merchantMappingDao(): MerchantMappingDao
    abstract fun recurringTransactionDao(): RecurringTransactionDao
    abstract fun tagDao(): TagDao
    abstract fun customSmsRuleDao(): CustomSmsRuleDao
    abstract fun merchantRenameRuleDao(): MerchantRenameRuleDao
    abstract fun merchantCategoryMappingDao(): MerchantCategoryMappingDao
    abstract fun ignoreRuleDao(): IgnoreRuleDao
    abstract fun goalDao(): GoalDao

    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null

        private val DEFAULT_IGNORE_PHRASES = listOf(
            "invoice of",
            "payment of.*is successful",
            "has been credited to",
            "payment of.*has been received towards",
            "credited to your.*card",
            "Payment of.*has been received on your.*Credit Card"
        ).map { IgnoreRule(phrase = it, isDefault = true) }

        val MIGRATION_1_2 = object : Migration(1, 2) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE transactions ADD COLUMN transactionType TEXT NOT NULL DEFAULT 'expense'")
                db.execSQL("UPDATE transactions SET transactionType = 'income' WHERE amount > 0")
                db.execSQL("UPDATE transactions SET amount = ABS(amount)")
            }
        }
        val MIGRATION_2_3 = object : Migration(2, 3) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("CREATE TABLE IF NOT EXISTS `merchant_mappings` (`smsSender` TEXT NOT NULL, `merchantName` TEXT NOT NULL, PRIMARY KEY(`smsSender`))")
            }
        }
        val MIGRATION_3_4 = object : Migration(3, 4) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE transactions ADD COLUMN sourceSmsId INTEGER")
            }
        }
        val MIGRATION_4_5 = object : Migration(4, 5) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("CREATE TABLE IF NOT EXISTS `recurring_transactions` (`id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, `description` TEXT NOT NULL, `amount` REAL NOT NULL, `transactionType` TEXT NOT NULL, `recurrenceInterval` TEXT NOT NULL, `startDate` INTEGER NOT NULL, `accountId` INTEGER NOT NULL, `categoryId` INTEGER, FOREIGN KEY(`accountId`) REFERENCES `accounts`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE, FOREIGN KEY(`categoryId`) REFERENCES `categories`(`id`) ON UPDATE NO ACTION ON DELETE SET NULL)")
                db.execSQL("CREATE INDEX IF NOT EXISTS `index_recurring_transactions_accountId` ON `recurring_transactions` (`accountId`)")
                db.execSQL("CREATE INDEX IF NOT EXISTS `index_recurring_transactions_categoryId` ON `recurring_transactions` (`categoryId`)")
            }
        }
        val MIGRATION_5_6 = object : Migration(5, 6) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("CREATE TABLE IF NOT EXISTS `tags` (`id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, `name` TEXT NOT NULL)")
                db.execSQL("CREATE UNIQUE INDEX IF NOT EXISTS `index_tags_name` ON `tags` (`name`)")
                db.execSQL("CREATE TABLE IF NOT EXISTS `transaction_tag_cross_ref` (`transactionId` INTEGER NOT NULL, `tagId` INTEGER NOT NULL, PRIMARY KEY(`transactionId`, `tagId`), FOREIGN KEY(`transactionId`) REFERENCES `transactions`(`id`) ON DELETE CASCADE, FOREIGN KEY(`tagId`) REFERENCES `tags`(`id`) ON DELETE CASCADE)")
            }
        }
        val MIGRATION_6_7 = object : Migration(6, 7) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE transactions ADD COLUMN sourceSmsHash TEXT")
            }
        }
        val MIGRATION_7_8 = object : Migration(7, 8) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE transactions ADD COLUMN source TEXT NOT NULL DEFAULT 'Manual Entry'")
                db.execSQL("UPDATE transactions SET source = 'Reviewed Import' WHERE sourceSmsId IS NOT NULL")
            }
        }
        val MIGRATION_8_9 = object : Migration(8, 9) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE categories ADD COLUMN iconKey TEXT NOT NULL DEFAULT 'category'")
            }
        }
        val MIGRATION_9_10 = object : Migration(9, 10) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE categories ADD COLUMN colorKey TEXT NOT NULL DEFAULT 'gray_light'")
            }
        }
        val MIGRATION_10_11 = object : Migration(10, 11) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("""
                    CREATE TABLE IF NOT EXISTS `transaction_images` (
                        `id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                        `transactionId` INTEGER NOT NULL,
                        `imageUri` TEXT NOT NULL,
                        FOREIGN KEY(`transactionId`) REFERENCES `transactions`(`id`) ON DELETE CASCADE
                    )
                """)
                db.execSQL("CREATE INDEX IF NOT EXISTS `index_transaction_images_transactionId` ON `transaction_images` (`transactionId`)")
            }
        }

        val MIGRATION_11_12 = object : Migration(11, 12) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("""
                    CREATE TABLE IF NOT EXISTS `custom_sms_rules` (
                        `id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                        `smsSender` TEXT NOT NULL,
                        `ruleType` TEXT NOT NULL,
                        `regexPattern` TEXT NOT NULL,
                        `priority` INTEGER NOT NULL
                    )
                """)
            }
        }

        val MIGRATION_12_13 = object : Migration(12, 13) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("DROP TABLE IF EXISTS `custom_sms_rules`")
                db.execSQL("""
                    CREATE TABLE IF NOT EXISTS `custom_sms_rules` (
                        `id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                        `triggerPhrase` TEXT NOT NULL,
                        `merchantRegex` TEXT,
                        `amountRegex` TEXT,
                        `priority` INTEGER NOT NULL
                    )
                """)
                db.execSQL("CREATE UNIQUE INDEX IF NOT EXISTS `index_custom_sms_rules_triggerPhrase` ON `custom_sms_rules` (`triggerPhrase`)")
            }
        }

        val MIGRATION_13_14 = object : Migration(13, 14) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE `custom_sms_rules` ADD COLUMN `merchantNameExample` TEXT")
                db.execSQL("ALTER TABLE `custom_sms_rules` ADD COLUMN `amountExample` TEXT")
            }
        }

        val MIGRATION_14_15 = object : Migration(14, 15) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE `custom_sms_rules` ADD COLUMN `accountRegex` TEXT")
                db.execSQL("ALTER TABLE `custom_sms_rules` ADD COLUMN `accountNameExample` TEXT")
            }
        }

        val MIGRATION_15_16 = object : Migration(15, 16) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE transactions ADD COLUMN originalDescription TEXT")
                db.execSQL("CREATE TABLE IF NOT EXISTS `merchant_rename_rules` (`originalName` TEXT NOT NULL, `newName` TEXT NOT NULL, PRIMARY KEY(`originalName`))")
            }
        }

        val MIGRATION_16_17 = object : Migration(16, 17) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE transactions ADD COLUMN isExcluded INTEGER NOT NULL DEFAULT 0")
            }
        }

        val MIGRATION_17_18 = object : Migration(17, 18) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("CREATE TABLE IF NOT EXISTS `merchant_category_mapping` (`parsedName` TEXT NOT NULL, `categoryId` INTEGER NOT NULL, PRIMARY KEY(`parsedName`))")
            }
        }

        val MIGRATION_18_19 = object : Migration(18, 19) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("CREATE TABLE IF NOT EXISTS `ignore_rules` (`id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, `phrase` TEXT NOT NULL)")
                db.execSQL("CREATE UNIQUE INDEX IF NOT EXISTS `index_ignore_rules_phrase` ON `ignore_rules` (`phrase`)")
            }
        }

        val MIGRATION_19_20 = object : Migration(19, 20) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE `ignore_rules` ADD COLUMN `isEnabled` INTEGER NOT NULL DEFAULT 1")
                db.execSQL("ALTER TABLE `ignore_rules` ADD COLUMN `isDefault` INTEGER NOT NULL DEFAULT 0")
            }
        }

        val MIGRATION_20_21 = object : Migration(20, 21) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE `custom_sms_rules` ADD COLUMN `sourceSmsBody` TEXT NOT NULL DEFAULT ''")
            }
        }

        val MIGRATION_21_22 = object : Migration(21, 22) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("INSERT OR IGNORE INTO categories (id, name, iconKey, colorKey) VALUES (16, 'Bike', 'two_wheeler', 'red_light')")
                db.execSQL("INSERT OR IGNORE INTO categories (id, name, iconKey, colorKey) VALUES (17, 'Car', 'directions_car', 'blue_light')")
                db.execSQL("INSERT OR IGNORE INTO categories (id, name, iconKey, colorKey) VALUES (18, 'Debt', 'credit_score', 'brown_light')")
                db.execSQL("INSERT OR IGNORE INTO categories (id, name, iconKey, colorKey) VALUES (19, 'Family', 'people', 'pink_light')")
                db.execSQL("INSERT OR IGNORE INTO categories (id, name, iconKey, colorKey) VALUES (20, 'Friends', 'group', 'cyan_light')")
                db.execSQL("INSERT OR IGNORE INTO categories (id, name, iconKey, colorKey) VALUES (21, 'Gift', 'card_giftcard', 'purple_light')")
                db.execSQL("INSERT OR IGNORE INTO categories (id, name, iconKey, colorKey) VALUES (22, 'Fitness', 'fitness_center', 'green_light')")
                db.execSQL("INSERT OR IGNORE INTO categories (id, name, iconKey, colorKey) VALUES (23, 'Home Maintenance', 'home', 'teal_light')")
                db.execSQL("INSERT OR IGNORE INTO categories (id, name, iconKey, colorKey) VALUES (24, 'Insurance', 'shield', 'indigo_light')")
                db.execSQL("INSERT OR IGNORE INTO categories (id, name, iconKey, colorKey) VALUES (25, 'Learning & Education', 'school', 'orange_light')")
                db.execSQL("INSERT OR IGNORE INTO categories (id, name, iconKey, colorKey) VALUES (26, 'Rent', 'house', 'deep_purple_light')")
            }
        }

        val MIGRATION_22_23 = object : Migration(22, 23) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE `recurring_transactions` ADD COLUMN `lastRunDate` INTEGER")
            }
        }

        val MIGRATION_23_24 = object : Migration(23, 24) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("""
                    CREATE TABLE IF NOT EXISTS `goals` (
                        `id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, 
                        `name` TEXT NOT NULL, 
                        `targetAmount` REAL NOT NULL, 
                        `savedAmount` REAL NOT NULL, 
                        `targetDate` INTEGER, 
                        `accountId` INTEGER NOT NULL, 
                        FOREIGN KEY(`accountId`) REFERENCES `accounts`(`id`) ON DELETE CASCADE
                    )
                """)
                db.execSQL("CREATE INDEX IF NOT EXISTS `index_goals_accountId` ON `goals` (`accountId`)")
            }
        }

        // --- NEW: Migration to enforce case-insensitive names ---
        val MIGRATION_24_25 = object : Migration(24, 25) {
            override fun migrate(db: SupportSQLiteDatabase) {
                // Recreate accounts table with NOCASE
                db.execSQL("""
                    CREATE TABLE `accounts_new` (
                        `id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, 
                        `name` TEXT NOT NULL COLLATE NOCASE, 
                        `type` TEXT NOT NULL
                    )
                """)
                db.execSQL("CREATE UNIQUE INDEX `index_accounts_name_nocase` ON `accounts_new` (`name`)")
                db.execSQL("INSERT INTO `accounts_new` (id, name, type) SELECT id, name, type FROM accounts")
                db.execSQL("DROP TABLE `accounts`")
                db.execSQL("ALTER TABLE `accounts_new` RENAME TO `accounts`")

                // Recreate categories table with NOCASE
                db.execSQL("""
                    CREATE TABLE `categories_new` (
                        `id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, 
                        `name` TEXT NOT NULL COLLATE NOCASE, 
                        `iconKey` TEXT NOT NULL, 
                        `colorKey` TEXT NOT NULL
                    )
                """)
                db.execSQL("CREATE UNIQUE INDEX `index_categories_name_nocase` ON `categories_new` (`name`)")
                db.execSQL("INSERT INTO `categories_new` (id, name, iconKey, colorKey) SELECT id, name, iconKey, colorKey FROM categories")
                db.execSQL("DROP TABLE `categories`")
                db.execSQL("ALTER TABLE `categories_new` RENAME TO `categories`")

                // Recreate merchant_rename_rules table with NOCASE
                db.execSQL("""
                    CREATE TABLE `merchant_rename_rules_new` (
                        `originalName` TEXT NOT NULL COLLATE NOCASE, 
                        `newName` TEXT NOT NULL, 
                        PRIMARY KEY(`originalName`)
                    )
                """)
                db.execSQL("INSERT INTO `merchant_rename_rules_new` (originalName, newName) SELECT originalName, newName FROM merchant_rename_rules")
                db.execSQL("DROP TABLE `merchant_rename_rules`")
                db.execSQL("ALTER TABLE `merchant_rename_rules_new` RENAME TO `merchant_rename_rules`")
            }
        }


        fun getInstance(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance =
                    Room.databaseBuilder(context.applicationContext, AppDatabase::class.java, "finance_database")
                        .addMigrations(MIGRATION_1_2, MIGRATION_2_3, MIGRATION_3_4, MIGRATION_4_5, MIGRATION_5_6, MIGRATION_6_7, MIGRATION_7_8, MIGRATION_8_9, MIGRATION_9_10, MIGRATION_10_11, MIGRATION_11_12, MIGRATION_12_13, MIGRATION_13_14, MIGRATION_14_15, MIGRATION_15_16, MIGRATION_16_17, MIGRATION_17_18, MIGRATION_18_19, MIGRATION_19_20, MIGRATION_20_21, MIGRATION_21_22, MIGRATION_22_23, MIGRATION_23_24, MIGRATION_24_25)
                        .addCallback(DatabaseCallback(context))
                        .build()
                INSTANCE = instance
                instance
            }
        }

        private class DatabaseCallback(private val context: Context) : RoomDatabase.Callback() {
            override fun onCreate(db: SupportSQLiteDatabase) {
                super.onCreate(db)
                CoroutineScope(Dispatchers.IO).launch {
                    populateDatabase(getInstance(context))
                }
            }

            override fun onOpen(db: SupportSQLiteDatabase) {
                super.onOpen(db)
            }

            suspend fun populateDatabase(db: AppDatabase) {
                val accountDao = db.accountDao()
                val categoryDao = db.categoryDao()
                val transactionDao = db.transactionDao()
                val budgetDao = db.budgetDao()
                val ignoreRuleDao = db.ignoreRuleDao()

                categoryDao.insertAll(CategoryIconHelper.predefinedCategories)
                ignoreRuleDao.insertAll(DEFAULT_IGNORE_PHRASES)

                accountDao.insertAll(
                    listOf(
                        Account(id = 1, name = "Cash Spends", type = "Cash"),
                        Account(id = 2, name = "SBI", type = "Savings"),
                        Account(id = 3, name = "HDFC", type = "Credit Card"),
                        Account(id = 4, name = "ICICI", type = "Savings"),
                    ),
                )

                val calendar = Calendar.getInstance()
                calendar.set(Calendar.DAY_OF_MONTH, 5)
                val incomeDate = calendar.timeInMillis
                calendar.set(Calendar.DAY_OF_MONTH, 10)
                val expenseDate1 = calendar.timeInMillis
                calendar.set(Calendar.DAY_OF_MONTH, 15)
                val expenseDate2 = calendar.timeInMillis

                transactionDao.insertAll(
                    listOf(
                        Transaction(
                            description = "Monthly Salary",
                            categoryId = 12, // "Salary"
                            amount = 75000.0,
                            date = incomeDate,
                            accountId = 2, // SBI
                            notes = "Paycheck",
                            transactionType = "income",
                        ),
                        Transaction(
                            description = "Grocery Shopping",
                            categoryId = 6, // "Groceries"
                            amount = 4500.0,
                            date = expenseDate1,
                            accountId = 3, // HDFC
                            notes = "Weekly groceries",
                            transactionType = "expense",
                        ),
                        Transaction(
                            description = "Dinner with friends",
                            categoryId = 4, // "Food & Drinks"
                            amount = 1200.0,
                            date = expenseDate2,
                            accountId = 3, // HDFC
                            notes = null,
                            transactionType = "expense",
                        )
                    )
                )

                val month = calendar.get(Calendar.MONTH) + 1
                val year = calendar.get(Calendar.YEAR)

                budgetDao.insertAll(
                    listOf(
                        Budget(categoryName = "Groceries", amount = 10000.0, month = month, year = year),
                        Budget(categoryName = "Food & Drinks", amount = 5000.0, month = month, year = year),
                        Budget(categoryName = "Bills", amount = 2000.0, month = month, year = year),
                    ),
                )
            }
        }
    }
}-e 


================== FILE: ./app/src/main/java/SmsParser.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/SmsParser.kt
// REASON: FEATURE - The parser now accepts a `MerchantCategoryMappingDao` and
// uses it to look up a learned category for the parsed merchant name. If a
// mapping is found, the category ID is included in the returned
// `PotentialTransaction`, enabling automatic categorization of new SMS messages.
// =================================================================================
package io.pm.finlight

import android.util.Log
import kotlinx.coroutines.flow.first
import java.util.regex.Pattern
import java.util.regex.PatternSyntaxException

data class PotentialAccount(
    val formattedName: String,
    val accountType: String,
)

object SmsParser {
    private val CURRENCY_AMOUNT_REGEX = "(?:rs|inr|rs\\.?)\\s*([\\d,]+\\.?\\d*)".toRegex(RegexOption.IGNORE_CASE)
    private val KEYWORD_AMOUNT_REGEX = "(?:purchase of|payment of|spent|charged|credited with|debited for|credit of|for)\\s+([\\d,]+\\.?\\d*)".toRegex(RegexOption.IGNORE_CASE)
    private val EXPENSE_KEYWORDS_REGEX = "\\b(spent|debited|paid|charged|payment of|purchase of)\\b".toRegex(RegexOption.IGNORE_CASE)
    private val INCOME_KEYWORDS_REGEX = "\\b(credited|received|deposited|refund of)\\b".toRegex(RegexOption.IGNORE_CASE)
    private val ACCOUNT_PATTERNS =
        listOf(
            "(ICICI Bank) Account XX(\\d{3,4}) credited".toRegex(RegexOption.IGNORE_CASE),
            "(HDFC Bank) : NEFT money transfer".toRegex(RegexOption.IGNORE_CASE),
            "spent from (Pluxee)\\s*(Meal Card wallet), card no\\.\\s*xx(\\d{4})".toRegex(RegexOption.IGNORE_CASE),
            "on your (SBI) (Credit Card) ending with (\\d{4})".toRegex(RegexOption.IGNORE_CASE),
            "On (HDFC Bank) (Card) (\\d{4})".toRegex(RegexOption.IGNORE_CASE),
            "(ICICI Bank) Acct XX(\\d{3,4}) debited".toRegex(RegexOption.IGNORE_CASE),
            "Acct XX(\\d{3,4}) is credited.*-(ICICI Bank)".toRegex(RegexOption.IGNORE_CASE)
        )
    private val MERCHANT_REGEX_PATTERNS =
        listOf(
            "(?:credited|received).*from\\s+([A-Za-z0-9\\s.&'-]+?)(?:\\.|$)".toRegex(RegexOption.IGNORE_CASE),
            "at\\s*\\.\\.\\s*([A-Za-z0-9_\\s]+)\\s*on".toRegex(RegexOption.IGNORE_CASE),
            ";\\s*([A-Za-z0-9\\s.&'-]+?)\\s*credited".toRegex(RegexOption.IGNORE_CASE),
            "UPI.*(?:to|\\bat\\b)\\s+([A-Za-z0-9\\s.&'()]+?)(?:\\s+on|\\s+Ref|$)".toRegex(RegexOption.IGNORE_CASE),
            "to\\s+([a-zA-Z0-9.\\-_]+@[a-zA-Z0-9]+)".toRegex(RegexOption.IGNORE_CASE),
            "(?:\\bat\\b|to\\s+)([A-Za-z0-9\\s.&'-]+?)(?:\\s+on\\s+|\\s+for\\s+|\\.|$|\\s+was\\s+)".toRegex(RegexOption.IGNORE_CASE),
            "Info:?\\s*([A-Za-z0-9\\s.&'-]+?)(?:\\.|$)".toRegex(RegexOption.IGNORE_CASE)
        )

    private fun parseAccount(smsBody: String, sender: String): PotentialAccount? {
        for (pattern in ACCOUNT_PATTERNS) {
            val match = pattern.find(smsBody)
            if (match != null) {
                return when (pattern.pattern) {
                    "(ICICI Bank) Account XX(\\d{3,4}) credited" ->
                        PotentialAccount(formattedName = "${match.groupValues[1].trim()} - xx${match.groupValues[2].trim()}", accountType = "Bank Account")
                    "(HDFC Bank) : NEFT money transfer" ->
                        PotentialAccount(formattedName = match.groupValues[1].trim(), accountType = "Bank Account")
                    "spent from (Pluxee)\\s*(Meal Card wallet), card no\\.\\s*xx(\\d{4})" ->
                        PotentialAccount(formattedName = "${match.groupValues[1].trim()} - xx${match.groupValues[3].trim()}", accountType = match.groupValues[2].trim())
                    "on your (SBI) (Credit Card) ending with (\\d{4})" ->
                        PotentialAccount(formattedName = "${match.groupValues[1].trim()} - xx${match.groupValues[3].trim()}", accountType = match.groupValues[2].trim())
                    "On (HDFC Bank) (Card) (\\d{4})" ->
                        PotentialAccount(formattedName = "${match.groupValues[1].trim()} - xx${match.groupValues[3].trim()}", accountType = match.groupValues[2].trim())
                    "(ICICI Bank) Acct XX(\\d{3,4}) debited" ->
                        PotentialAccount(formattedName = "${match.groupValues[1].trim()} - xx${match.groupValues[2].trim()}", accountType = "Savings Account")
                    "Acct XX(\\d{3,4}) is credited.*-(ICICI Bank)" ->
                        PotentialAccount(formattedName = "${match.groupValues[2].trim()} - xx${match.groupValues[1].trim()}", accountType = "Savings Account")
                    else -> null
                }
            }
        }
        return null
    }

    suspend fun parse(
        sms: SmsMessage,
        mappings: Map<String, String>,
        customSmsRuleDao: CustomSmsRuleDao,
        merchantRenameRuleDao: MerchantRenameRuleDao,
        ignoreRuleDao: IgnoreRuleDao,
        // --- NEW: Add DAO for learned category mappings ---
        merchantCategoryMappingDao: MerchantCategoryMappingDao
    ): PotentialTransaction? {
        val messageBody = sms.body
        Log.d("SmsParser", "--- Parsing SMS from: ${sms.sender} ---")

        val ignorePhrases = ignoreRuleDao.getEnabledPhrases()
        for (phrase in ignorePhrases) {
            try {
                if (phrase.toRegex(RegexOption.IGNORE_CASE).containsMatchIn(messageBody)) {
                    Log.d("SmsParser", "Message contains ignore phrase '$phrase'. Ignoring.")
                    return null
                }
            } catch (e: PatternSyntaxException) {
                Log.e("SmsParser", "Invalid regex pattern in ignore phrase: '$phrase'", e)
            }
        }

        var extractedMerchant: String? = null
        var extractedAmount: Double? = null
        var extractedAccount: PotentialAccount? = null

        val allRules = customSmsRuleDao.getAllRules().first()
        val renameRules = merchantRenameRuleDao.getAllRules().first().associateBy({ it.originalName }, { it.newName })
        Log.d("SmsParser", "Found ${allRules.size} custom rules and ${renameRules.size} rename rules.")


        for (rule in allRules) {
            if (messageBody.contains(rule.triggerPhrase, ignoreCase = true)) {
                Log.d("SmsParser", "SUCCESS: Found matching trigger phrase '${rule.triggerPhrase}' for rule ID ${rule.id}.")

                rule.merchantRegex?.let { regexStr ->
                    try {
                        val match = regexStr.toRegex().find(messageBody)
                        if (match != null && match.groupValues.size > 1) {
                            extractedMerchant = match.groupValues[1].trim()
                        }
                    } catch (e: PatternSyntaxException) { /* Ignore */ }
                }

                rule.amountRegex?.let { regexStr ->
                    try {
                        val match = regexStr.toRegex().find(messageBody)
                        if (match != null && match.groupValues.size > 1) {
                            extractedAmount = match.groupValues[1].replace(",", "").toDoubleOrNull()
                        }
                    } catch (e: PatternSyntaxException) { /* Ignore */ }
                }

                rule.accountRegex?.let { regexStr ->
                    try {
                        val match = regexStr.toRegex().find(messageBody)
                        if (match != null && match.groupValues.size > 1) {
                            val accountName = match.groupValues[1].trim()
                            extractedAccount = PotentialAccount(formattedName = accountName, accountType = "Custom")
                            Log.d("SmsParser", "Extracted Account: '$accountName' using custom rule.")
                        }
                    } catch (e: PatternSyntaxException) {
                        Log.e("SmsParser", "Invalid account regex for rule ID ${rule.id}", e)
                    }
                }
                break
            }
        }

        val amount = extractedAmount
            ?: CURRENCY_AMOUNT_REGEX.find(messageBody)?.groups?.get(1)?.value?.replace(",", "")?.toDoubleOrNull()
            ?: KEYWORD_AMOUNT_REGEX.find(messageBody)?.groups?.get(1)?.value?.replace(",", "")?.toDoubleOrNull()
            ?: return null

        val transactionType =
            when {
                EXPENSE_KEYWORDS_REGEX.containsMatchIn(messageBody) -> "expense"
                INCOME_KEYWORDS_REGEX.containsMatchIn(messageBody) -> "income"
                else -> return null
            }

        var merchantName = extractedMerchant ?: mappings[sms.sender]

        if (merchantName == null) {
            for (pattern in MERCHANT_REGEX_PATTERNS) {
                val match = pattern.find(messageBody)
                if (match != null) {
                    val potentialName = match.groups[1]?.value?.replace("_", " ")?.replace(Regex("\\s+"), " ")?.trim()
                    if (!potentialName.isNullOrBlank() && !potentialName.contains("call", ignoreCase = true)) {
                        if (potentialName.startsWith("NEFT", ignoreCase = true) || !potentialName.matches(Regex(".*\\d{6,}.*"))) {
                            merchantName = potentialName
                            break
                        }
                    }
                }
            }
        }

        if (merchantName != null && renameRules.containsKey(merchantName)) {
            val originalName = merchantName
            merchantName = renameRules[merchantName]
            Log.d("SmsParser", "Applied rename rule: '$originalName' -> '$merchantName'")
        }

        // --- NEW: Look up the learned category ID ---
        var learnedCategoryId: Int? = null
        if (merchantName != null) {
            learnedCategoryId = merchantCategoryMappingDao.getCategoryIdForMerchant(merchantName)
            if (learnedCategoryId != null) {
                Log.d("SmsParser", "Found learned category ID $learnedCategoryId for merchant '$merchantName'")
            }
        }

        val potentialAccount = extractedAccount ?: parseAccount(messageBody, sms.sender)
        val normalizedSender = sms.sender.filter { it.isDigit() }.takeLast(10)
        val normalizedBody = sms.body.trim().replace(Regex("\\s+"), " ")
        val smsHash = (normalizedSender + normalizedBody).hashCode().toString()

        return PotentialTransaction(
            sourceSmsId = sms.id,
            smsSender = sms.sender,
            amount = amount,
            transactionType = transactionType,
            merchantName = merchantName,
            originalMessage = messageBody,
            potentialAccount = potentialAccount,
            sourceSmsHash = smsHash,
            // --- NEW: Pass the learned category ID ---
            categoryId = learnedCategoryId
        )
    }
}-e 


================== FILE: ./app/src/main/java/PeriodTotal.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/PeriodTotal.kt
// REASON: NEW FILE - This data class is required by the new DAO queries to hold
// the aggregated results for weekly and monthly spending totals.
// =================================================================================
package io.pm.finlight

/**
 * A simple data class to hold the results of a GROUP BY query for weekly or monthly totals.
 *
 * @param period The period identifier (e.g., "2025-27" for week 27, or "2025-07" for July).
 * @param totalAmount The sum of all expenses for this period.
 */
data class PeriodTotal(
    val period: String,
    val totalAmount: Double
)
-e 


================== FILE: ./app/src/main/java/AppDataBackup.kt ==================
package io.pm.finlight

import kotlinx.serialization.Serializable

/**
 * A top-level container for all application data to be exported.
 * This class is designed to be easily converted to a single JSON object.
 */
@Serializable
data class AppDataBackup(
    val transactions: List<Transaction>,
    val accounts: List<Account>,
    val categories: List<Category>,
    val budgets: List<Budget>,
    val merchantMappings: List<MerchantMapping>,
)
-e 


================== FILE: ./app/src/main/java/SettingsRepository.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/SettingsRepository.kt
// REASON: REFACTOR - Changed the default time for the daily report notification
// from 9 AM to 11 PM (23:00), enabled the daily report by default, and set the
// weekly report default day to Sunday to improve the out-of-the-box user experience.
// =================================================================================
package io.pm.finlight

import android.content.Context
import android.content.SharedPreferences
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import io.pm.finlight.ui.theme.AppTheme
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import java.util.Calendar

class SettingsRepository(context: Context) {

    private val prefs: SharedPreferences =
        context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE)
    private val gson = Gson()

    companion object {
        private const val PREF_NAME = "finance_app_settings"
        private const val KEY_USER_NAME = "user_name"
        private const val KEY_PROFILE_PICTURE_URI = "profile_picture_uri"
        private const val KEY_BUDGET_PREFIX = "overall_budget_"
        private const val KEY_APP_LOCK_ENABLED = "app_lock_enabled"
        private const val KEY_WEEKLY_SUMMARY_ENABLED = "weekly_summary_enabled"
        private const val KEY_UNKNOWN_TRANSACTION_POPUP_ENABLED = "unknown_transaction_popup_enabled"
        private const val KEY_DAILY_REPORT_ENABLED = "daily_report_enabled"
        private const val KEY_SMS_SCAN_START_DATE = "sms_scan_start_date"
        private const val KEY_HAS_SEEN_ONBOARDING = "has_seen_onboarding"
        private const val KEY_BACKUP_ENABLED = "google_drive_backup_enabled"
        private const val KEY_DAILY_REPORT_HOUR = "daily_report_hour"
        private const val KEY_DAILY_REPORT_MINUTE = "daily_report_minute"
        private const val KEY_WEEKLY_REPORT_DAY = "weekly_report_day"
        private const val KEY_WEEKLY_REPORT_HOUR = "weekly_report_hour"
        private const val KEY_WEEKLY_REPORT_MINUTE = "weekly_report_minute"
        private const val KEY_MONTHLY_REPORT_DAY = "monthly_report_day"
        private const val KEY_MONTHLY_REPORT_HOUR = "monthly_report_hour"
        private const val KEY_MONTHLY_REPORT_MINUTE = "monthly_report_minute"
        private const val KEY_MONTHLY_SUMMARY_ENABLED = "monthly_summary_enabled"
        private const val KEY_DASHBOARD_CARD_ORDER = "dashboard_card_order"
        private const val KEY_DASHBOARD_VISIBLE_CARDS = "dashboard_visible_cards"
        private const val KEY_SELECTED_THEME = "selected_app_theme"
    }

    fun saveSelectedTheme(theme: AppTheme) {
        prefs.edit().putString(KEY_SELECTED_THEME, theme.key).apply()
    }

    fun getSelectedTheme(): Flow<AppTheme> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sp, key ->
                if (key == KEY_SELECTED_THEME) {
                    val themeKey = sp.getString(key, AppTheme.SYSTEM_DEFAULT.key)
                    trySend(AppTheme.fromKey(themeKey))
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            val initialThemeKey = prefs.getString(KEY_SELECTED_THEME, AppTheme.SYSTEM_DEFAULT.key)
            trySend(AppTheme.fromKey(initialThemeKey))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }


    fun saveDashboardLayout(order: List<DashboardCardType>, visible: Set<DashboardCardType>) {
        val orderJson = gson.toJson(order.map { it.name })
        val visibleJson = gson.toJson(visible.map { it.name })
        prefs.edit()
            .putString(KEY_DASHBOARD_CARD_ORDER, orderJson)
            .putString(KEY_DASHBOARD_VISIBLE_CARDS, visibleJson)
            .apply()
    }

    fun getDashboardCardOrder(): Flow<List<DashboardCardType>> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sp, key ->
                if (key == KEY_DASHBOARD_CARD_ORDER) {
                    trySend(loadCardOrder(sp))
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(loadCardOrder(prefs))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }

    fun getDashboardVisibleCards(): Flow<Set<DashboardCardType>> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sp, key ->
                if (key == KEY_DASHBOARD_VISIBLE_CARDS) {
                    trySend(loadVisibleCards(sp))
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(loadVisibleCards(prefs))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }

    private fun loadCardOrder(sp: SharedPreferences): List<DashboardCardType> {
        val json = sp.getString(KEY_DASHBOARD_CARD_ORDER, null)
        return if (json != null) {
            val type = object : TypeToken<List<String>>() {}.type
            val names: List<String> = gson.fromJson(json, type)
            names.mapNotNull { runCatching { DashboardCardType.valueOf(it) }.getOrNull() }
        } else {
            listOf(
                DashboardCardType.HERO_BUDGET,
                DashboardCardType.QUICK_ACTIONS,
                DashboardCardType.NET_WORTH,
                DashboardCardType.RECENT_ACTIVITY,
                DashboardCardType.ACCOUNTS_CAROUSEL,
                DashboardCardType.BUDGET_WATCH
            )
        }
    }

    private fun loadVisibleCards(sp: SharedPreferences): Set<DashboardCardType> {
        val json = sp.getString(KEY_DASHBOARD_VISIBLE_CARDS, null)
        return if (json != null) {
            val type = object : TypeToken<Set<String>>() {}.type
            val names: Set<String> = gson.fromJson(json, type)
            names.mapNotNull { runCatching { DashboardCardType.valueOf(it) }.getOrNull() }.toSet()
        } else {
            DashboardCardType.values().toSet()
        }
    }


    fun saveBackupEnabled(isEnabled: Boolean) {
        prefs.edit().putBoolean(KEY_BACKUP_ENABLED, isEnabled).apply()
    }

    fun getBackupEnabled(): Flow<Boolean> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sharedPreferences, changedKey ->
                if (changedKey == KEY_BACKUP_ENABLED) {
                    trySend(sharedPreferences.getBoolean(KEY_BACKUP_ENABLED, true))
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(prefs.getBoolean(KEY_BACKUP_ENABLED, true))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }


    fun saveUserName(name: String) {
        prefs.edit().putString(KEY_USER_NAME, name).apply()
    }

    fun getUserName(): Flow<String> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sharedPreferences, changedKey ->
                if (changedKey == KEY_USER_NAME) {
                    trySend(sharedPreferences.getString(KEY_USER_NAME, "User") ?: "User")
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(prefs.getString(KEY_USER_NAME, "User") ?: "User")
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }

    fun saveProfilePictureUri(uriString: String?) {
        prefs.edit().putString(KEY_PROFILE_PICTURE_URI, uriString).apply()
    }

    fun getProfilePictureUri(): Flow<String?> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sharedPreferences, changedKey ->
                if (changedKey == KEY_PROFILE_PICTURE_URI) {
                    trySend(sharedPreferences.getString(KEY_PROFILE_PICTURE_URI, null))
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(prefs.getString(KEY_PROFILE_PICTURE_URI, null))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }

    fun hasSeenOnboarding(): Boolean {
        return prefs.getBoolean(KEY_HAS_SEEN_ONBOARDING, false)
    }

    fun setHasSeenOnboarding(hasSeen: Boolean) {
        prefs.edit().putBoolean(KEY_HAS_SEEN_ONBOARDING, hasSeen).apply()
    }

    private fun getBudgetKey(year: Int, month: Int): String {
        return String.format("%s%d_%02d", KEY_BUDGET_PREFIX, year, month)
    }

    fun saveOverallBudgetForCurrentMonth(amount: Float) {
        val calendar = Calendar.getInstance()
        val year = calendar.get(Calendar.YEAR)
        val month = calendar.get(Calendar.MONTH) + 1
        val key = getBudgetKey(year, month)
        prefs.edit().putFloat(key, amount).apply()
    }

    fun saveSmsScanStartDate(date: Long) {
        prefs.edit().putLong(KEY_SMS_SCAN_START_DATE, date).apply()
    }

    fun getSmsScanStartDate(): Flow<Long> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sharedPreferences, changedKey ->
                if (changedKey == KEY_SMS_SCAN_START_DATE) {
                    trySend(sharedPreferences.getLong(KEY_SMS_SCAN_START_DATE, 0L))
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            val thirtyDaysAgo = Calendar.getInstance().apply { add(Calendar.DAY_OF_YEAR, -30) }.timeInMillis
            trySend(prefs.getLong(KEY_SMS_SCAN_START_DATE, thirtyDaysAgo))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }

    fun saveAppLockEnabled(isEnabled: Boolean) {
        prefs.edit().putBoolean(KEY_APP_LOCK_ENABLED, isEnabled).apply()
    }
    fun saveDailyReportEnabled(isEnabled: Boolean) {
        prefs.edit().putBoolean(KEY_DAILY_REPORT_ENABLED, isEnabled).apply()
    }
    fun getDailyReportEnabled(): Flow<Boolean> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { _, key ->
                if (key == KEY_DAILY_REPORT_ENABLED) {
                    trySend(prefs.getBoolean(key, true))
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(prefs.getBoolean(KEY_DAILY_REPORT_ENABLED, true))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }

    fun getAppLockEnabled(): Flow<Boolean> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sharedPreferences, changedKey ->
                if (changedKey == KEY_APP_LOCK_ENABLED) {
                    trySend(sharedPreferences.getBoolean(KEY_APP_LOCK_ENABLED, false))
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(prefs.getBoolean(KEY_APP_LOCK_ENABLED, false))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }
    fun isAppLockEnabledBlocking(): Boolean {
        return prefs.getBoolean(KEY_APP_LOCK_ENABLED, false)
    }

    fun getOverallBudgetForMonth(year: Int, month: Int): Flow<Float> {
        return callbackFlow {
            val currentMonthKey = getBudgetKey(year, month)

            val previousMonthCalendar = Calendar.getInstance().apply {
                set(Calendar.YEAR, year)
                set(Calendar.MONTH, month - 1) // Calendar month is 0-indexed
                add(Calendar.MONTH, -1)
            }
            val previousMonthKey = getBudgetKey(
                previousMonthCalendar.get(Calendar.YEAR),
                previousMonthCalendar.get(Calendar.MONTH) + 1
            )

            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sharedPreferences, changedKey ->
                if (changedKey == currentMonthKey) {
                    trySend(sharedPreferences.getFloat(currentMonthKey, 0f))
                } else if (changedKey == previousMonthKey && !sharedPreferences.contains(currentMonthKey)) {
                    trySend(sharedPreferences.getFloat(previousMonthKey, 0f))
                }
            }

            prefs.registerOnSharedPreferenceChangeListener(listener)

            val budget = if (prefs.contains(currentMonthKey)) {
                prefs.getFloat(currentMonthKey, 0f)
            } else {
                prefs.getFloat(previousMonthKey, 0f)
            }
            trySend(budget)

            awaitClose {
                prefs.unregisterOnSharedPreferenceChangeListener(listener)
            }
        }
    }

    fun saveWeeklySummaryEnabled(isEnabled: Boolean) {
        prefs.edit().putBoolean(KEY_WEEKLY_SUMMARY_ENABLED, isEnabled).apply()
    }
    fun getWeeklySummaryEnabled(): Flow<Boolean> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { _, key ->
                if (key == KEY_WEEKLY_SUMMARY_ENABLED) { trySend(prefs.getBoolean(key, true)) }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(prefs.getBoolean(KEY_WEEKLY_SUMMARY_ENABLED, true))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }

    fun saveMonthlySummaryEnabled(isEnabled: Boolean) {
        prefs.edit().putBoolean(KEY_MONTHLY_SUMMARY_ENABLED, isEnabled).apply()
    }

    fun getMonthlySummaryEnabled(): Flow<Boolean> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { _, key ->
                if (key == KEY_MONTHLY_SUMMARY_ENABLED) { trySend(prefs.getBoolean(key, true)) }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(prefs.getBoolean(KEY_MONTHLY_SUMMARY_ENABLED, true))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }

    fun saveUnknownTransactionPopupEnabled(isEnabled: Boolean) {
        prefs.edit().putBoolean(KEY_UNKNOWN_TRANSACTION_POPUP_ENABLED, isEnabled).apply()
    }
    fun getUnknownTransactionPopupEnabled(): Flow<Boolean> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { _, key ->
                if (key == KEY_UNKNOWN_TRANSACTION_POPUP_ENABLED) { trySend(prefs.getBoolean(key, true)) }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(prefs.getBoolean(KEY_UNKNOWN_TRANSACTION_POPUP_ENABLED, true))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }

    fun isUnknownTransactionPopupEnabledBlocking(): Boolean {
        return prefs.getBoolean(KEY_UNKNOWN_TRANSACTION_POPUP_ENABLED, true)
    }

    fun saveDailyReportTime(hour: Int, minute: Int) {
        prefs.edit()
            .putInt(KEY_DAILY_REPORT_HOUR, hour)
            .putInt(KEY_DAILY_REPORT_MINUTE, minute)
            .apply()
    }

    fun getDailyReportTime(): Flow<Pair<Int, Int>> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sharedPreferences, changedKey ->
                if (changedKey == KEY_DAILY_REPORT_HOUR || changedKey == KEY_DAILY_REPORT_MINUTE) {
                    trySend(
                        Pair(
                            sharedPreferences.getInt(KEY_DAILY_REPORT_HOUR, 23),
                            sharedPreferences.getInt(KEY_DAILY_REPORT_MINUTE, 0)
                        )
                    )
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(
                Pair(
                    prefs.getInt(KEY_DAILY_REPORT_HOUR, 23),
                    prefs.getInt(KEY_DAILY_REPORT_MINUTE, 0)
                )
            )
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }

    fun saveWeeklyReportTime(dayOfWeek: Int, hour: Int, minute: Int) {
        prefs.edit()
            .putInt(KEY_WEEKLY_REPORT_DAY, dayOfWeek)
            .putInt(KEY_WEEKLY_REPORT_HOUR, hour)
            .putInt(KEY_WEEKLY_REPORT_MINUTE, minute)
            .apply()
    }

    fun getWeeklyReportTime(): Flow<Triple<Int, Int, Int>> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sp, key ->
                if (key == KEY_WEEKLY_REPORT_DAY || key == KEY_WEEKLY_REPORT_HOUR || key == KEY_WEEKLY_REPORT_MINUTE) {
                    trySend(Triple(
                        sp.getInt(KEY_WEEKLY_REPORT_DAY, Calendar.SUNDAY),
                        sp.getInt(KEY_WEEKLY_REPORT_HOUR, 9),
                        sp.getInt(KEY_WEEKLY_REPORT_MINUTE, 0)
                    ))
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            // --- FIX: Changed default day to Sunday ---
            trySend(Triple(
                prefs.getInt(KEY_WEEKLY_REPORT_DAY, Calendar.SUNDAY),
                prefs.getInt(KEY_WEEKLY_REPORT_HOUR, 9),
                prefs.getInt(KEY_WEEKLY_REPORT_MINUTE, 0)
            ))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }

    fun saveMonthlyReportTime(dayOfMonth: Int, hour: Int, minute: Int) {
        prefs.edit()
            .putInt(KEY_MONTHLY_REPORT_DAY, dayOfMonth)
            .putInt(KEY_MONTHLY_REPORT_HOUR, hour)
            .putInt(KEY_MONTHLY_REPORT_MINUTE, minute)
            .apply()
    }

    fun getMonthlyReportTime(): Flow<Triple<Int, Int, Int>> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sp, key ->
                if (key == KEY_MONTHLY_REPORT_DAY || key == KEY_MONTHLY_REPORT_HOUR || key == KEY_MONTHLY_REPORT_MINUTE) {
                    trySend(Triple(
                        sp.getInt(KEY_MONTHLY_REPORT_DAY, 1),
                        sp.getInt(KEY_MONTHLY_REPORT_HOUR, 9),
                        sp.getInt(KEY_MONTHLY_REPORT_MINUTE, 0)
                    ))
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(Triple(
                prefs.getInt(KEY_MONTHLY_REPORT_DAY, 1),
                prefs.getInt(KEY_MONTHLY_REPORT_HOUR, 9),
                prefs.getInt(KEY_MONTHLY_REPORT_MINUTE, 0)
            ))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/SearchViewModelFactory.kt ==================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider

class SearchViewModelFactory(private val application: Application) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(SearchViewModel::class.java)) {
            val database = AppDatabase.getInstance(application)
            @Suppress("UNCHECKED_CAST")
            return SearchViewModel(
                transactionDao = database.transactionDao(),
                accountDao = database.accountDao(),
                categoryDao = database.categoryDao(),
            ) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
-e 


================== FILE: ./app/src/main/java/ReportsViewModel.kt ==================
package io.pm.finlight

import android.app.Application
import androidx.compose.ui.graphics.toArgb
import androidx.lifecycle.AndroidViewModel
import com.github.mikephil.charting.data.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Date
import java.util.Locale

class ReportsViewModel(application: Application) : AndroidViewModel(application) {
    private val transactionRepository: TransactionRepository
    val spendingByCategoryPieData: Flow<PieData>
    val monthYear: String
    val monthlyTrendData: Flow<Pair<BarData, List<String>>>

    init {
        val db = AppDatabase.getInstance(application)
        transactionRepository = TransactionRepository(db.transactionDao())

        val calendar = Calendar.getInstance()
        // --- FIX: Corrected the invalid date format pattern ---
        monthYear = SimpleDateFormat("MMMM yyyy", Locale.getDefault()).format(calendar.time)

        val monthStart = Calendar.getInstance().apply { set(Calendar.DAY_OF_MONTH, 1); set(Calendar.HOUR_OF_DAY, 0) }.timeInMillis
        val monthEnd = Calendar.getInstance().apply { add(Calendar.MONTH, 1); set(Calendar.DAY_OF_MONTH, 1); add(Calendar.DAY_OF_MONTH, -1); set(Calendar.HOUR_OF_DAY, 23) }.timeInMillis

        spendingByCategoryPieData =
            transactionRepository.getSpendingByCategoryForMonth(
                startDate = monthStart,
                endDate = monthEnd,
                keyword = null,
                accountId = null,
                categoryId = null
            ).map { spendingList ->
                val entries = spendingList.map { PieEntry(it.totalAmount.toFloat(), it.categoryName) }
                val colors = spendingList.map {
                    (CategoryIconHelper.getIconBackgroundColor(it.colorKey ?: "gray_light")).toArgb()
                }
                val dataSet =
                    PieDataSet(entries, "Spending by Category").apply {
                        this.colors = colors
                        valueTextSize = 12f
                    }
                PieData(dataSet)
            }

        val sixMonthsAgo = Calendar.getInstance().apply { add(Calendar.MONTH, -6) }.timeInMillis
        monthlyTrendData =
            transactionRepository.getMonthlyTrends(sixMonthsAgo)
                .map { trends ->
                    val incomeEntries = ArrayList<BarEntry>()
                    val expenseEntries = ArrayList<BarEntry>()
                    val labels = ArrayList<String>()

                    trends.forEachIndexed { index, trend ->
                        incomeEntries.add(BarEntry(index.toFloat(), trend.totalIncome.toFloat()))
                        expenseEntries.add(BarEntry(index.toFloat(), trend.totalExpenses.toFloat()))
                        val date = SimpleDateFormat("yyyy-MM", Locale.getDefault()).parse(trend.monthYear)
                        labels.add(SimpleDateFormat("MMM", Locale.getDefault()).format(date ?: Date()))
                    }

                    val incomeDataSet = BarDataSet(incomeEntries, "Income").apply { color = android.graphics.Color.rgb(102, 187, 106) }
                    val expenseDataSet = BarDataSet(expenseEntries, "Expense").apply { color = android.graphics.Color.rgb(239, 83, 80) }

                    val barData = BarData(incomeDataSet, expenseDataSet)
                    Pair(barData, labels)
                }
    }
}
-e 


================== FILE: ./app/src/main/java/TagViewModel.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/TagViewModel.kt
// REASON: UX REFINEMENT - The `addTag` function now checks if a tag with the
// same name already exists (case-insensitively). If a duplicate is found, it
// sends a feedback message to the UI via the `uiEvent` channel, improving the
// user experience by preventing silent failures.
// =================================================================================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.receiveAsFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

class TagViewModel(application: Application) : AndroidViewModel(application) {
    private val tagRepository: TagRepository
    private val tagDao: TagDao // Expose DAO for direct checks
    private val _uiEvent = Channel<String>()
    val uiEvent = _uiEvent.receiveAsFlow()

    val allTags: StateFlow<List<Tag>>

    init {
        val database = AppDatabase.getInstance(application)
        tagDao = database.tagDao() // Initialize DAO
        val transactionDao = database.transactionDao()
        tagRepository = TagRepository(tagDao, transactionDao)

        allTags = tagRepository.allTags.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )
    }

    /**
     * Called from the 'Manage Tags' screen. Inserts a new tag into the database.
     */
    fun addTag(tagName: String) {
        if (tagName.isNotBlank()) {
            viewModelScope.launch {
                // Check if a tag with this name already exists
                val existingTag = tagDao.findByName(tagName)
                if (existingTag != null) {
                    _uiEvent.send("A tag named '$tagName' already exists.")
                } else {
                    tagRepository.insert(Tag(name = tagName))
                    _uiEvent.send("Tag '$tagName' created.")
                }
            }
        }
    }

    fun updateTag(tag: Tag) {
        if (tag.name.isNotBlank()) {
            viewModelScope.launch {
                tagRepository.update(tag)
            }
        }
    }

    fun deleteTag(tag: Tag) {
        viewModelScope.launch {
            if (tagRepository.isTagInUse(tag.id)) {
                _uiEvent.send("Cannot delete '${tag.name}'. It is attached to one or more transactions.")
            } else {
                tagRepository.delete(tag)
                _uiEvent.send("Tag '${tag.name}' deleted.")
            }
        }
    }
}-e 


================== FILE: ./app/src/main/java/SettingsViewModel.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/SettingsViewModel.kt
// REASON: FEATURE - The `commitCsvImport` logic has been significantly enhanced
// to handle tags. It now parses a "Tags" column from the CSV, splits the string
// by a pipe delimiter, and for each tag name, it either finds the existing tag
// or creates a new one. These tags are then associated with the newly created
// transaction, completing the tag import feature.
// =================================================================================
package io.pm.finlight

import android.Manifest
import android.app.Application
import android.app.backup.BackupManager
import android.content.pm.PackageManager
import android.net.Uri
import android.util.Log
import androidx.core.content.ContextCompat
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import io.pm.finlight.ui.theme.AppTheme
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.text.SimpleDateFormat
import java.util.*

sealed class ScanResult {
    data class Success(val count: Int) : ScanResult()
    object Error : ScanResult()
}


class SettingsViewModel(application: Application) : AndroidViewModel(application) {
    private val settingsRepository = SettingsRepository(application)
    private val db = AppDatabase.getInstance(application)
    private val transactionRepository = TransactionRepository(db.transactionDao())
    private val merchantMappingRepository = MerchantMappingRepository(db.merchantMappingDao())
    private val context = application
    private val accountRepository = AccountRepository(db.accountDao())
    private val categoryRepository = CategoryRepository(db.categoryDao())
    // --- NEW: Add TagDao for direct access during import ---
    private val tagDao = db.tagDao()

    val smsScanStartDate: StateFlow<Long>

    private val _scanEvent = Channel<ScanResult>()
    val scanEvent = _scanEvent.receiveAsFlow()

    private val _csvValidationReport = MutableStateFlow<CsvValidationReport?>(null)
    val csvValidationReport: StateFlow<CsvValidationReport?> = _csvValidationReport.asStateFlow()

    val overallBudget: StateFlow<Float>

    val dailyReportEnabled: StateFlow<Boolean> =
        settingsRepository.getDailyReportEnabled().stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = false,
        )

    val weeklySummaryEnabled: StateFlow<Boolean> =
        settingsRepository.getWeeklySummaryEnabled().stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = true,
        )

    val monthlySummaryEnabled: StateFlow<Boolean> =
        settingsRepository.getMonthlySummaryEnabled().stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = true
        )

    val appLockEnabled: StateFlow<Boolean> =
        settingsRepository.getAppLockEnabled().stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = false,
        )

    val unknownTransactionPopupEnabled: StateFlow<Boolean> =
        settingsRepository.getUnknownTransactionPopupEnabled().stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = true,
        )

    val backupEnabled: StateFlow<Boolean> =
        settingsRepository.getBackupEnabled().stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = true,
        )

    private val _potentialTransactions = MutableStateFlow<List<PotentialTransaction>>(emptyList())
    val potentialTransactions: StateFlow<List<PotentialTransaction>> = _potentialTransactions.asStateFlow()

    private val _isScanning = MutableStateFlow(false)
    val isScanning: StateFlow<Boolean> = _isScanning.asStateFlow()

    val dailyReportTime: StateFlow<Pair<Int, Int>> =
        settingsRepository.getDailyReportTime().stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = Pair(9, 0)
        )

    val weeklyReportTime: StateFlow<Triple<Int, Int, Int>> =
        settingsRepository.getWeeklyReportTime().stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = Triple(Calendar.MONDAY, 9, 0)
        )

    val monthlyReportTime: StateFlow<Triple<Int, Int, Int>> =
        settingsRepository.getMonthlyReportTime().stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = Triple(1, 9, 0)
        )

    val selectedTheme: StateFlow<AppTheme> =
        settingsRepository.getSelectedTheme().stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = AppTheme.SYSTEM_DEFAULT
        )

    init {
        smsScanStartDate =
            settingsRepository.getSmsScanStartDate()
                .stateIn(
                    scope = viewModelScope,
                    started = SharingStarted.WhileSubscribed(5000),
                    initialValue = 0L,
                )

        val calendar = Calendar.getInstance()
        val currentYear = calendar.get(Calendar.YEAR)
        val currentMonth = calendar.get(Calendar.MONTH) + 1

        overallBudget =
            settingsRepository.getOverallBudgetForMonth(currentYear, currentMonth).stateIn(
                scope = viewModelScope,
                started = SharingStarted.WhileSubscribed(5000),
                initialValue = 0f,
            )
    }

    fun saveSelectedTheme(theme: AppTheme) {
        settingsRepository.saveSelectedTheme(theme)
    }

    fun setBackupEnabled(enabled: Boolean) {
        settingsRepository.saveBackupEnabled(enabled)
        val backupManager = BackupManager(context)
        backupManager.dataChanged()
    }

    fun rescanSmsForReview(startDate: Long?) {
        if (ContextCompat.checkSelfPermission(context, Manifest.permission.READ_SMS) != PackageManager.PERMISSION_GRANTED) {
            return
        }

        viewModelScope.launch {
            _isScanning.value = true
            try {
                val rawMessages = withContext(Dispatchers.IO) {
                    SmsRepository(context).fetchAllSms(startDate)
                }

                val existingMappings = withContext(Dispatchers.IO) {
                    merchantMappingRepository.allMappings.first().associateBy({ it.smsSender }, { it.merchantName })
                }

                val existingSmsHashes = withContext(Dispatchers.IO) {
                    transactionRepository.getAllSmsHashes().first().toSet()
                }

                val parsedList = withContext(Dispatchers.Default) {
                    rawMessages.mapNotNull { sms ->
                        SmsParser.parse(
                            sms,
                            existingMappings,
                            db.customSmsRuleDao(),
                            db.merchantRenameRuleDao(),
                            db.ignoreRuleDao(),
                            db.merchantCategoryMappingDao()
                        )
                    }
                }

                val newPotentialTransactions = parsedList.filter { potential ->
                    !existingSmsHashes.contains(potential.sourceSmsHash)
                }

                _potentialTransactions.value = newPotentialTransactions
                _scanEvent.send(ScanResult.Success(newPotentialTransactions.size))
            } catch (e: Exception) {
                Log.e("SettingsViewModel", "Error during SMS scan for review", e)
                _scanEvent.send(ScanResult.Error)
            } finally {
                _isScanning.value = false
            }
        }
    }

    fun dismissPotentialTransaction(transaction: PotentialTransaction) {
        _potentialTransactions.value = _potentialTransactions.value.filter { it != transaction }
    }

    fun onTransactionApproved(smsId: Long) {
        _potentialTransactions.update { currentList ->
            currentList.filterNot { it.sourceSmsId == smsId }
        }
    }

    fun onTransactionLinked(smsId: Long) {
        _potentialTransactions.update { currentList ->
            currentList.filterNot { it.sourceSmsId == smsId }
        }
    }

    fun saveMerchantRenameRule(originalName: String, newName: String) {
        if (originalName.isBlank() || newName.isBlank()) return
        viewModelScope.launch(Dispatchers.IO) {
            if (originalName.equals(newName, ignoreCase = true)) {
                db.merchantRenameRuleDao().deleteByOriginalName(originalName)
                Log.d("SettingsViewModel", "Deleted rename rule for: '$originalName'")
            } else {
                val rule = MerchantRenameRule(originalName = originalName, newName = newName)
                db.merchantRenameRuleDao().insert(rule)
                Log.d("SettingsViewModel", "Saved rename rule: '$originalName' -> '$newName'")
            }
        }
    }

    fun saveSmsScanStartDate(date: Long) {
        viewModelScope.launch {
            settingsRepository.saveSmsScanStartDate(date)
        }
    }

    fun saveOverallBudget(budget: String) {
        val budgetFloat = budget.toFloatOrNull() ?: 0f
        settingsRepository.saveOverallBudgetForCurrentMonth(budgetFloat)
    }

    fun setDailyReportEnabled(enabled: Boolean) {
        settingsRepository.saveDailyReportEnabled(enabled)
        if (enabled) ReminderManager.scheduleDailyReport(context) else ReminderManager.cancelDailyReport(context)
    }

    fun saveDailyReportTime(hour: Int, minute: Int) {
        settingsRepository.saveDailyReportTime(hour, minute)
        if (dailyReportEnabled.value) {
            ReminderManager.scheduleDailyReport(context)
        }
    }

    fun setWeeklySummaryEnabled(enabled: Boolean) {
        settingsRepository.saveWeeklySummaryEnabled(enabled)
        if (enabled) ReminderManager.scheduleWeeklySummary(context) else ReminderManager.cancelWeeklySummary(context)
    }

    fun saveWeeklyReportTime(dayOfWeek: Int, hour: Int, minute: Int) {
        settingsRepository.saveWeeklyReportTime(dayOfWeek, hour, minute)
        if (weeklySummaryEnabled.value) {
            ReminderManager.scheduleWeeklySummary(context)
        }
    }

    fun setMonthlySummaryEnabled(enabled: Boolean) {
        settingsRepository.saveMonthlySummaryEnabled(enabled)
        if (enabled) {
            ReminderManager.scheduleMonthlySummary(context)
        } else {
            ReminderManager.cancelMonthlySummary(context)
        }
    }

    fun saveMonthlyReportTime(dayOfMonth: Int, hour: Int, minute: Int) {
        settingsRepository.saveMonthlyReportTime(dayOfMonth, hour, minute)
        if (monthlySummaryEnabled.value) {
            ReminderManager.scheduleMonthlySummary(context)
        }
    }

    fun setAppLockEnabled(enabled: Boolean) {
        settingsRepository.saveAppLockEnabled(enabled)
    }

    fun setUnknownTransactionPopupEnabled(enabled: Boolean) {
        viewModelScope.launch {
            settingsRepository.saveUnknownTransactionPopupEnabled(enabled)
        }
    }

    fun validateCsvFile(uri: Uri) {
        viewModelScope.launch {
            _csvValidationReport.value = null
            withContext(Dispatchers.IO) {
                try {
                    val report = generateValidationReport(uri)
                    _csvValidationReport.value = report
                } catch (e: Exception) {
                    Log.e("SettingsViewModel", "CSV validation failed", e)
                }
            }
        }
    }

    private suspend fun generateValidationReport(
        uri: Uri,
        initialData: List<ReviewableRow>? = null,
    ): CsvValidationReport {
        val accountsMap = db.accountDao().getAllAccounts().first().associateBy { it.name }
        val categoriesMap = db.categoryDao().getAllCategories().first().associateBy { it.name }

        if (initialData != null) {
            val revalidatedRows =
                initialData.map {
                    createReviewableRow(it.lineNumber, it.rowData, accountsMap, categoriesMap)
                }
            return CsvValidationReport(revalidatedRows, revalidatedRows.size)
        }

        val reviewableRows = mutableListOf<ReviewableRow>()
        var lineNumber = 1

        getApplication<Application>().contentResolver.openInputStream(uri)?.bufferedReader()?.useLines { lines ->
            lines.drop(1).forEach { line ->
                lineNumber++
                val tokens = line.split(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)".toRegex()).map { it.trim().removeSurrounding("\"") }
                reviewableRows.add(createReviewableRow(lineNumber, tokens, accountsMap, categoriesMap))
            }
        }
        return CsvValidationReport(reviewableRows, lineNumber - 1)
    }

    private fun createReviewableRow(
        lineNumber: Int,
        tokens: List<String>,
        accounts: Map<String, Account>,
        categories: Map<String, Category>,
    ): ReviewableRow {
        // --- UPDATED: Loosen column count check for optional tags ---
        if (tokens.size < 8) return ReviewableRow(lineNumber, tokens, CsvRowStatus.INVALID_COLUMN_COUNT, "Invalid column count. Expected at least 8.")

        val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
        try {
            dateFormat.parse(tokens[0])
        } catch (
            e: Exception,
        ) {
            return ReviewableRow(lineNumber, tokens, CsvRowStatus.INVALID_DATE, "Invalid date format.")
        }

        val amount = tokens[2].toDoubleOrNull()
        if (amount == null || amount <= 0) return ReviewableRow(lineNumber, tokens, CsvRowStatus.INVALID_AMOUNT, "Invalid amount.")

        val categoryName = tokens[4]
        val accountName = tokens[5]

        val categoryExists = categories.containsKey(categoryName)
        val accountExists = accounts.containsKey(accountName)

        val status =
            when {
                !accountExists && !categoryExists -> CsvRowStatus.NEEDS_BOTH_CREATION
                !accountExists -> CsvRowStatus.NEEDS_ACCOUNT_CREATION
                !categoryExists -> CsvRowStatus.NEEDS_CATEGORY_CREATION
                else -> CsvRowStatus.VALID
            }
        val message =
            when (status) {
                CsvRowStatus.VALID -> "Ready to import."
                CsvRowStatus.NEEDS_BOTH_CREATION -> "New Account & Category will be created."
                CsvRowStatus.NEEDS_ACCOUNT_CREATION -> "New Account '$accountName' will be created."
                CsvRowStatus.NEEDS_CATEGORY_CREATION -> "New Category '$categoryName' will be created."
                else -> "This row has errors and will be skipped."
            }
        return ReviewableRow(lineNumber, tokens, status, message)
    }

    fun removeRowFromReport(rowToRemove: ReviewableRow) {
        _csvValidationReport.value?.let { currentReport ->
            val updatedRows = currentReport.reviewableRows.filter { it.lineNumber != rowToRemove.lineNumber }
            _csvValidationReport.value = currentReport.copy(reviewableRows = updatedRows)
        }
    }

    fun updateAndRevalidateRow(
        lineNumber: Int,
        correctedData: List<String>,
    ) {
        viewModelScope.launch {
            _csvValidationReport.value?.let { currentReport ->
                val currentRows = currentReport.reviewableRows.toMutableList()
                val indexToUpdate = currentRows.indexOfFirst { it.lineNumber == lineNumber }

                if (indexToUpdate != -1) {
                    val revalidatedRow =
                        withContext(Dispatchers.IO) {
                            val accountsMap = db.accountDao().getAllAccounts().first().associateBy { it.name }
                            val categoriesMap = db.categoryDao().getAllCategories().first().associateBy { it.name }
                            createReviewableRow(lineNumber, correctedData, accountsMap, categoriesMap)
                        }
                    currentRows[indexToUpdate] = revalidatedRow
                    _csvValidationReport.value = currentReport.copy(reviewableRows = currentRows)
                }
            }
        }
    }

    // --- UPDATED: Logic to handle tag creation and association ---
    fun commitCsvImport(rowsToImport: List<ReviewableRow>) {
        viewModelScope.launch(Dispatchers.IO) {
            val allAccounts = accountRepository.allAccounts.first()
            val allCategories = categoryRepository.allCategories.first()
            val accountMap = allAccounts.associateBy { it.name.lowercase() }.toMutableMap()
            val categoryMap = allCategories.associateBy { it.name.lowercase() }.toMutableMap()

            val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())

            for (row in rowsToImport) {
                try {
                    val columns = row.rowData
                    val date = dateFormat.parse(columns[0]) ?: Date()
                    val description = columns[1]
                    val amount = columns[2].toDouble()
                    val type = columns[3].lowercase(Locale.getDefault())
                    val categoryName = columns[4]
                    val accountName = columns[5]
                    val notes = columns.getOrNull(6)
                    val isExcluded = columns.getOrNull(7)?.toBoolean() ?: false
                    // --- NEW: Parse tags from the 9th column ---
                    val tagsString = columns.getOrNull(8)

                    var category = categoryMap[categoryName.lowercase()]
                    if (category == null) {
                        val newCategory = Category(name = categoryName)
                        categoryRepository.insert(newCategory)
                        val updatedCategories = categoryRepository.allCategories.first()
                        category = updatedCategories.find { it.name.equals(categoryName, ignoreCase = true) }
                        if (category != null) {
                            categoryMap[categoryName.lowercase()] = category
                        } else {
                            continue
                        }
                    }

                    var account = accountMap[accountName.lowercase()]
                    if (account == null) {
                        val newAccount = Account(name = accountName, type = "Imported")
                        accountRepository.insert(newAccount)
                        val updatedAccounts = accountRepository.allAccounts.first()
                        account = updatedAccounts.find { it.name.equals(accountName, ignoreCase = true) }
                        if (account != null) {
                            accountMap[accountName.lowercase()] = account
                        } else {
                            continue
                        }
                    }

                    if (account == null || category == null) {
                        continue
                    }

                    // --- NEW: Process tags ---
                    val tagsToAssociate = mutableSetOf<Tag>()
                    if (!tagsString.isNullOrBlank()) {
                        val tagNames = tagsString.split('|').map { it.trim() }.filter { it.isNotEmpty() }
                        for (tagName in tagNames) {
                            var tag = tagDao.findByName(tagName)
                            if (tag == null) {
                                val newTagId = tagDao.insert(Tag(name = tagName))
                                tag = Tag(id = newTagId.toInt(), name = tagName)
                            }
                            tagsToAssociate.add(tag)
                        }
                    }

                    val transaction =
                        Transaction(
                            date = date.time,
                            amount = amount,
                            description = description,
                            notes = notes,
                            transactionType = type,
                            accountId = account.id,
                            categoryId = category.id,
                            isExcluded = isExcluded,
                            source = "Imported"
                        )
                    // --- UPDATED: Use the repository function that handles tags ---
                    transactionRepository.insertTransactionWithTags(transaction, tagsToAssociate)
                } catch (e: Exception) {
                    Log.e("CsvImportDebug", "ViewModel: Failed to parse or insert row ${row.lineNumber}. Data: ${row.rowData}", e)
                }
            }
        }
    }

    fun clearCsvValidationReport() {
        _csvValidationReport.value = null
    }
}-e 


================== FILE: ./app/src/main/java/AccountViewModel.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/AccountViewModel.kt
// REASON: UX REFINEMENT - The `addAccount` function now checks if an account
// with the same name already exists (case-insensitively) before attempting to
// insert. If a duplicate is found, it sends a message to the UI via the new
// `uiEvent` channel, providing clear feedback to the user instead of failing
// silently.
// =================================================================================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.firstOrNull
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.receiveAsFlow
import kotlinx.coroutines.launch

class AccountViewModel(application: Application) : AndroidViewModel(application) {
    private val repository: AccountRepository
    private val transactionRepository: TransactionRepository
    private val accountDao: AccountDao // Expose DAO for direct checks

    // --- NEW: Channel for sending one-time UI events like snackbars ---
    private val _uiEvent = Channel<String>()
    val uiEvent = _uiEvent.receiveAsFlow()

    val accountsWithBalance: Flow<List<AccountWithBalance>>

    init {
        val db = AppDatabase.getInstance(application)
        accountDao = db.accountDao() // Initialize DAO
        repository = AccountRepository(accountDao)
        transactionRepository = TransactionRepository(db.transactionDao())

        accountsWithBalance = repository.accountsWithBalance
    }

    fun getAccountById(accountId: Int): Flow<Account?> = repository.getAccountById(accountId)

    fun getAccountBalance(accountId: Int): Flow<Double> {
        return transactionRepository.getTransactionsForAccount(accountId).map { transactions ->
            transactions.sumOf { if (it.transactionType == "income") it.amount else -it.amount }
        }
    }

    fun getTransactionsForAccount(accountId: Int): Flow<List<TransactionDetails>> {
        return transactionRepository.getTransactionsForAccountDetails(accountId)
    }

    // --- UPDATED: Add pre-check and user feedback for duplicates ---
    fun addAccount(
        name: String,
        type: String,
    ) = viewModelScope.launch {
        if (name.isNotBlank() && type.isNotBlank()) {
            // Check if an account with this name already exists
            val existingAccount = accountDao.findByName(name)
            if (existingAccount != null) {
                _uiEvent.send("An account named '$name' already exists.")
            } else {
                repository.insert(Account(name = name, type = type))
                _uiEvent.send("Account '$name' created.")
            }
        }
    }

    fun updateAccount(account: Account) =
        viewModelScope.launch {
            repository.update(account)
        }

    fun renameAccount(accountId: Int, newName: String) {
        if (newName.isBlank()) return
        viewModelScope.launch {
            val accountToUpdate = repository.getAccountById(accountId).firstOrNull()
            accountToUpdate?.let {
                updateAccount(it.copy(name = newName))
            }
        }
    }


    fun deleteAccount(account: Account) =
        viewModelScope.launch {
            repository.delete(account)
        }
}-e 


================== FILE: ./app/src/main/java/TransactionTagCrossRef.kt ==================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.ForeignKey

/**
 * This is a "join table" to create a many-to-many relationship
 * between the 'transactions' table and the 'tags' table.
 */
@Entity(
    tableName = "transaction_tag_cross_ref",
    primaryKeys = ["transactionId", "tagId"],
    foreignKeys = [
        ForeignKey(
            entity = Transaction::class,
            parentColumns = ["id"],
            childColumns = ["transactionId"],
            onDelete = ForeignKey.CASCADE // If a transaction is deleted, remove its tag links
        ),
        ForeignKey(
            entity = Tag::class,
            parentColumns = ["id"],
            childColumns = ["tagId"],
            onDelete = ForeignKey.CASCADE // If a tag is deleted, remove its links from transactions
        )
    ]
)
data class TransactionTagCrossRef(
    val transactionId: Int,
    val tagId: Int
)-e 


================== FILE: ./app/src/main/java/PotentialTransaction.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/PotentialTransaction.kt
// REASON: FEATURE - A new nullable `categoryId` field has been added. This
// allows the SmsParser to include the ID of a learned category when it creates
// a potential transaction, enabling automatic categorization.
// =================================================================================
package io.pm.finlight

/**
 * A data class to hold the structured information extracted from an SMS message.
 * This is a temporary object, created before a full 'Transaction' is saved to the database.
 *
 * @param amount The monetary value of the transaction.
 * @param transactionType The type of transaction, either 'expense' or 'income'.
 * @param merchantName The name of the merchant, if it can be determined.
 * @param originalMessage The original SMS body, for reference and debugging.
 * @param potentialAccount Holds the parsed account name and type, if found.
 * @param categoryId The ID of a learned category, if a mapping exists for the merchant.
 */
data class PotentialTransaction(
    val sourceSmsId: Long,
    val smsSender: String,
    val amount: Double,
    val transactionType: String,
    val merchantName: String?,
    val originalMessage: String,
    val potentialAccount: PotentialAccount? = null,
    val sourceSmsHash: String? = null,
    // --- NEW: Add field for learned category ---
    val categoryId: Int? = null
)-e 


================== FILE: ./app/src/main/java/TransactionImage.kt ==================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "transaction_images",
    foreignKeys = [
        ForeignKey(
            entity = Transaction::class,
            parentColumns = ["id"],
            childColumns = ["transactionId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    // --- FIX: Explicitly declare the index that Room creates for the foreign key ---
    indices = [Index(value = ["transactionId"])]
)
data class TransactionImage(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val transactionId: Int,
    val imageUri: String // Stores the URI of the image in the app's internal storage
)
-e 


================== FILE: ./app/src/main/java/IgnoreRule.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/IgnoreRule.kt
// REASON: FEATURE - The entity has been updated with `isEnabled` and `isDefault`
// fields. This allows the app to distinguish between pre-populated default
// rules and user-added rules, and gives users the ability to toggle the
// default rules on or off without deleting them.
// =================================================================================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.Index
import androidx.room.PrimaryKey

/**
 * Represents a user-defined rule to ignore an SMS based on a specific phrase.
 * If this phrase is found in an SMS body, the parser will skip it.
 *
 * @param id The unique identifier for the rule.
 * @param phrase The text that, if found, will cause the SMS to be ignored (e.g., "invoice of").
 * @param isEnabled Whether this rule is currently active.
 * @param isDefault True if this is a pre-populated rule, false if user-added.
 */
@Entity(
    tableName = "ignore_rules",
    indices = [Index(value = ["phrase"], unique = true)]
)
data class IgnoreRule(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val phrase: String,
    var isEnabled: Boolean = true,
    val isDefault: Boolean = false
)
-e 


================== FILE: ./app/src/main/java/TransactionDao.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/TransactionDao.kt
// REASON: FEATURE - Added the `getTagsForTransactionSimple` suspend function.
// This provides a non-Flow, one-shot method to fetch tags for a given
// transaction, which is necessary for the CSV export process to efficiently
// gather and append tag data for each row.
// =================================================================================
package io.pm.finlight

import androidx.room.*
import kotlinx.coroutines.flow.Flow

@Dao
interface TransactionDao {

    @Query(
        """
        SELECT
            C.name as categoryName,
            SUM(T.amount) as totalAmount,
            C.iconKey as iconKey,
            C.colorKey as categoryColorKey
        FROM transactions AS T
        INNER JOIN categories AS C ON T.categoryId = C.id
        WHERE T.transactionType = 'expense' AND T.date BETWEEN :startDate AND :endDate
          AND T.isExcluded = 0
        GROUP BY C.name
        ORDER BY totalAmount DESC
        LIMIT 3
    """
    )
    suspend fun getTopSpendingCategoriesForRange(startDate: Long, endDate: Long): List<CategorySpending>


    @Query("UPDATE transactions SET isExcluded = :isExcluded WHERE id = :id")
    suspend fun updateExclusionStatus(id: Int, isExcluded: Boolean)

    @Query(
        """
        SELECT
            T.*,
            A.name as accountName,
            C.name as categoryName,
            C.iconKey as categoryIconKey,
            C.colorKey as categoryColorKey
        FROM
            transactions AS T
        LEFT JOIN
            accounts AS A ON T.accountId = A.id
        LEFT JOIN
            categories AS C ON T.categoryId = C.id
        ORDER BY
            T.date DESC
    """
    )
    fun getAllTransactions(): Flow<List<TransactionDetails>>

    @Query("""
        SELECT
            T.*,
            A.name as accountName,
            C.name as categoryName,
            C.iconKey as categoryIconKey,
            C.colorKey as categoryColorKey
        FROM
            transactions AS T
        LEFT JOIN
            accounts AS A ON T.accountId = A.id
        LEFT JOIN
            categories AS C ON T.categoryId = C.id
        WHERE T.transactionType = 'income' AND T.date BETWEEN :startDate AND :endDate
          AND T.isExcluded = 0
          AND (:keyword IS NULL OR LOWER(T.description) LIKE '%' || LOWER(:keyword) || '%' OR LOWER(T.notes) LIKE '%' || LOWER(:keyword) || '%')
          AND (:accountId IS NULL OR T.accountId = :accountId)
          AND (:categoryId IS NULL OR T.categoryId = :categoryId)
        ORDER BY
            T.date DESC
    """)
    fun getIncomeTransactionsForRange(startDate: Long, endDate: Long, keyword: String?, accountId: Int?, categoryId: Int?): Flow<List<TransactionDetails>>

    @Query("""
        SELECT 
            C.name as categoryName, 
            SUM(T.amount) as totalAmount,
            C.iconKey as iconKey,
            C.colorKey as colorKey
        FROM transactions AS T
        INNER JOIN categories AS C ON T.categoryId = C.id
        WHERE T.transactionType = 'income' AND T.date BETWEEN :startDate AND :endDate
          AND T.isExcluded = 0
          AND (:keyword IS NULL OR LOWER(T.description) LIKE '%' || LOWER(:keyword) || '%' OR LOWER(T.notes) LIKE '%' || LOWER(:keyword) || '%')
          AND (:accountId IS NULL OR T.accountId = :accountId)
          AND (:categoryId IS NULL OR T.categoryId = :categoryId)
        GROUP BY C.name
        ORDER BY totalAmount DESC
    """)
    fun getIncomeByCategoryForMonth(startDate: Long, endDate: Long, keyword: String?, accountId: Int?, categoryId: Int?): Flow<List<CategorySpending>>

    @Query("""
        SELECT
            description as merchantName,
            SUM(amount) as totalAmount,
            COUNT(id) as transactionCount
        FROM transactions
        WHERE transactionType = 'expense' AND date BETWEEN :startDate AND :endDate
          AND isExcluded = 0
          AND (:keyword IS NULL OR LOWER(description) LIKE '%' || LOWER(:keyword) || '%' OR LOWER(notes) LIKE '%' || LOWER(:keyword) || '%')
          AND (:accountId IS NULL OR accountId = :accountId)
          AND (:categoryId IS NULL OR categoryId = :categoryId)
        GROUP BY LOWER(description)
        ORDER BY totalAmount DESC
    """)
    fun getSpendingByMerchantForMonth(startDate: Long, endDate: Long, keyword: String?, accountId: Int?, categoryId: Int?): Flow<List<MerchantSpendingSummary>>

    @Insert
    suspend fun insertImage(transactionImage: TransactionImage)

    @Delete
    suspend fun deleteImage(transactionImage: TransactionImage)

    @Query("SELECT * FROM transaction_images WHERE transactionId = :transactionId")
    fun getImagesForTransaction(transactionId: Int): Flow<List<TransactionImage>>


    @Query("UPDATE transactions SET description = :description WHERE id = :id")
    suspend fun updateDescription(id: Int, description: String)

    @Query("UPDATE transactions SET amount = :amount WHERE id = :id")
    suspend fun updateAmount(id: Int, amount: Double)

    @Query("UPDATE transactions SET notes = :notes WHERE id = :id")
    suspend fun updateNotes(id: Int, notes: String?)

    @Query("UPDATE transactions SET categoryId = :categoryId WHERE id = :id")
    suspend fun updateCategoryId(id: Int, categoryId: Int?)

    @Query("UPDATE transactions SET accountId = :accountId WHERE id = :id")
    suspend fun updateAccountId(id: Int, accountId: Int)

    @Query("UPDATE transactions SET date = :date WHERE id = :id")
    suspend fun updateDate(id: Int, date: Long)


    @Query(
        """
        SELECT
            T.*,
            A.name as accountName,
            C.name as categoryName,
            C.iconKey as categoryIconKey,
            C.colorKey as categoryColorKey
        FROM
            transactions AS T
        LEFT JOIN
            accounts AS A ON T.accountId = A.id
        LEFT JOIN
            categories AS C ON T.categoryId = C.id
        WHERE T.id = :id
    """
    )
    fun getTransactionDetailsById(id: Int): Flow<TransactionDetails?>


    @Query(
        """
        SELECT
            T.*,
            A.name as accountName,
            C.name as categoryName,
            C.iconKey as categoryIconKey,
            C.colorKey as categoryColorKey
        FROM
            transactions AS T
        LEFT JOIN
            accounts AS A ON T.accountId = A.id
        LEFT JOIN
            categories AS C ON T.categoryId = C.id
        ORDER BY
            T.date DESC
        LIMIT 5
    """
    )
    fun getRecentTransactionDetails(): Flow<List<TransactionDetails>>

    @Query("SELECT sourceSmsHash FROM transactions WHERE sourceSmsHash IS NOT NULL")
    fun getAllSmsHashes(): Flow<List<String>>

    @Query(
        """
        SELECT
            T.*,
            A.name as accountName,
            C.name as categoryName,
            C.iconKey as categoryIconKey,
            C.colorKey as categoryColorKey
        FROM
            transactions AS T
        LEFT JOIN
            accounts AS A ON T.accountId = A.id
        LEFT JOIN
            categories AS C ON T.categoryId = C.id
        WHERE T.date BETWEEN :startDate AND :endDate
          AND (:keyword IS NULL OR LOWER(T.description) LIKE '%' || LOWER(:keyword) || '%' OR LOWER(T.notes) LIKE '%' || LOWER(:keyword) || '%')
          AND (:accountId IS NULL OR T.accountId = :accountId)
          AND (:categoryId IS NULL OR T.categoryId = :categoryId)
        ORDER BY
            T.date DESC
    """
    )
    fun getTransactionDetailsForRange(
        startDate: Long,
        endDate: Long,
        keyword: String?,
        accountId: Int?,
        categoryId: Int?
    ): Flow<List<TransactionDetails>>

    @Query(
        """
        SELECT t.*, a.name as accountName, c.name as categoryName, c.iconKey as categoryIconKey, c.colorKey as categoryColorKey
        FROM transactions t
        LEFT JOIN accounts a ON t.accountId = a.id
        LEFT JOIN categories c ON t.categoryId = c.id
        WHERE t.accountId = :accountId
        ORDER BY t.date DESC
    """
    )
    fun getTransactionsForAccountDetails(accountId: Int): Flow<List<TransactionDetails>>

    @Query("SELECT * FROM transactions")
    fun getAllTransactionsSimple(): Flow<List<Transaction>>

    @Query("SELECT * FROM transactions WHERE date BETWEEN :startDate AND :endDate ORDER BY date DESC")
    fun getAllTransactionsForRange(
        startDate: Long,
        endDate: Long,
    ): Flow<List<Transaction>>

    @Query("SELECT * FROM transactions WHERE id = :id")
    fun getTransactionById(id: Int): Flow<Transaction?>

    @Query("SELECT * FROM transactions WHERE accountId = :accountId ORDER BY date DESC")
    fun getTransactionsForAccount(accountId: Int): Flow<List<Transaction>>

    @Query(
        """
        SELECT SUM(T.amount) FROM transactions AS T
        INNER JOIN categories AS C ON T.categoryId = C.id
        WHERE C.name = :categoryName AND T.date BETWEEN :startDate AND :endDate AND T.transactionType = 'expense' AND T.isExcluded = 0
    """
    )
    fun getSpendingForCategory(
        categoryName: String,
        startDate: Long,
        endDate: Long,
    ): Flow<Double?>

    @Query(
        """
        SELECT 
            C.name as categoryName, 
            SUM(T.amount) as totalAmount,
            C.iconKey as iconKey,
            C.colorKey as colorKey
        FROM transactions AS T
        INNER JOIN categories AS C ON T.categoryId = C.id
        WHERE T.transactionType = 'expense' AND T.date BETWEEN :startDate AND :endDate
          AND T.isExcluded = 0
          AND (:keyword IS NULL OR LOWER(T.description) LIKE '%' || LOWER(:keyword) || '%' OR LOWER(T.notes) LIKE '%' || LOWER(:keyword) || '%')
          AND (:accountId IS NULL OR T.accountId = :accountId)
          AND (:categoryId IS NULL OR T.categoryId = :categoryId)
        GROUP BY C.name
        ORDER BY totalAmount ASC
    """
    )
    fun getSpendingByCategoryForMonth(
        startDate: Long,
        endDate: Long,
        keyword: String?,
        accountId: Int?,
        categoryId: Int?
    ): Flow<List<CategorySpending>>

    @Query(
        """
        SELECT
            strftime('%Y-%m', date / 1000, 'unixepoch', 'localtime') as monthYear,
            SUM(CASE WHEN transactionType = 'income' THEN amount ELSE 0 END) as totalIncome,
            SUM(CASE WHEN transactionType = 'expense' THEN amount ELSE 0 END) as totalExpenses
        FROM transactions
        WHERE date >= :startDate AND isExcluded = 0
        GROUP BY monthYear
        ORDER BY monthYear ASC
    """
    )
    fun getMonthlyTrends(startDate: Long): Flow<List<MonthlyTrend>>

    @Query("SELECT COUNT(*) FROM transactions WHERE categoryId = :categoryId")
    suspend fun countTransactionsForCategory(categoryId: Int): Int

    @Query("SELECT COUNT(*) FROM transaction_tag_cross_ref WHERE tagId = :tagId")
    suspend fun countTransactionsForTag(tagId: Int): Int

    @Query("""
        SELECT
            SUM(CASE WHEN transactionType = 'income' THEN amount ELSE 0 END) as totalIncome,
            SUM(CASE WHEN transactionType = 'expense' THEN amount ELSE 0 END) as totalExpenses
        FROM transactions
        WHERE date BETWEEN :startDate AND :endDate AND isExcluded = 0
    """)
    suspend fun getFinancialSummaryForRange(startDate: Long, endDate: Long): FinancialSummary?


    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(transactions: List<Transaction>)

    @Query("DELETE FROM transactions")
    suspend fun deleteAll()

    @Insert
    suspend fun insert(transaction: Transaction): Long

    @Update
    suspend fun update(transaction: Transaction)

    @Delete
    suspend fun delete(transaction: Transaction)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun addTagsToTransaction(crossRefs: List<TransactionTagCrossRef>)

    @Query("DELETE FROM transaction_tag_cross_ref WHERE transactionId = :transactionId")
    suspend fun clearTagsForTransaction(transactionId: Int)

    @Query("SELECT T.* FROM tags T INNER JOIN transaction_tag_cross_ref TTCR ON T.id = TTCR.tagId WHERE TTCR.transactionId = :transactionId")
    fun getTagsForTransaction(transactionId: Int): Flow<List<Tag>>

    // --- NEW: Non-flow version for one-shot queries like CSV export ---
    @Query("SELECT T.* FROM tags T INNER JOIN transaction_tag_cross_ref TTCR ON T.id = TTCR.tagId WHERE TTCR.transactionId = :transactionId")
    suspend fun getTagsForTransactionSimple(transactionId: Int): List<Tag>

    @Query("""
        SELECT T.*, A.name as accountName, C.name as categoryName, C.iconKey as categoryIconKey, C.colorKey as categoryColorKey
        FROM transactions AS T
        LEFT JOIN accounts AS A ON T.accountId = A.id
        LEFT JOIN categories AS C ON T.categoryId = C.id
        WHERE T.date BETWEEN :startDate AND :endDate
        ORDER BY T.date DESC
    """)
    fun getTransactionsForDateRange(startDate: Long, endDate: Long): Flow<List<TransactionDetails>>

    @Query("""
        SELECT
            strftime('%Y-%m-%d', date / 1000, 'unixepoch', 'localtime') as date,
            SUM(CASE WHEN transactionType = 'expense' THEN amount ELSE 0 END) as totalAmount
        FROM transactions
        WHERE date BETWEEN :startDate AND :endDate AND isExcluded = 0
        GROUP BY date
        ORDER BY date ASC
    """)
    fun getDailySpendingForDateRange(startDate: Long, endDate: Long): Flow<List<DailyTotal>>

    @Query("""
        SELECT
            strftime('%Y-%W', date / 1000, 'unixepoch', 'localtime') as period,
            SUM(CASE WHEN transactionType = 'expense' THEN amount ELSE 0 END) as totalAmount
        FROM transactions
        WHERE date BETWEEN :startDate AND :endDate AND isExcluded = 0
        GROUP BY period
        ORDER BY period ASC
    """)
    fun getWeeklySpendingForDateRange(startDate: Long, endDate: Long): Flow<List<PeriodTotal>>

    @Query("""
        SELECT
            strftime('%Y-%m', date / 1000, 'unixepoch', 'localtime') as period,
            SUM(CASE WHEN transactionType = 'expense' THEN amount ELSE 0 END) as totalAmount
        FROM transactions
        WHERE date BETWEEN :startDate AND :endDate AND isExcluded = 0
        GROUP BY period
        ORDER BY period ASC
    """)
    fun getMonthlySpendingForDateRange(startDate: Long, endDate: Long): Flow<List<PeriodTotal>>

    @Query("UPDATE transactions SET sourceSmsHash = :smsHash WHERE id = :transactionId")
    suspend fun setSmsHash(transactionId: Int, smsHash: String)

    @Query("""
        SELECT * FROM transactions
        WHERE sourceSmsHash IS NULL
          AND date BETWEEN :startDate AND :endDate
          AND amount BETWEEN :minAmount AND :maxAmount
          AND transactionType = :transactionType
        ORDER BY ABS(date - :smsDate) ASC
    """)
    suspend fun findLinkableTransactions(
        startDate: Long,
        endDate: Long,
        minAmount: Double,
        maxAmount: Double,
        smsDate: Long,
        transactionType: String
    ): List<Transaction>

    @Query("""
        SELECT COUNT(*) FROM transactions
        WHERE LOWER(description) = LOWER(:description) OR LOWER(originalDescription) = LOWER(:description)
        AND isExcluded = 0
    """)
    fun getTransactionCountForMerchant(description: String): Flow<Int>

    @Query("""
        SELECT * FROM transactions
        WHERE (LOWER(description) = LOWER(:description) OR LOWER(originalDescription) = LOWER(:description))
        AND id != :excludeId
        AND isExcluded = 0
    """)
    suspend fun findSimilarTransactions(description: String, excludeId: Int): List<Transaction>

    @Query("UPDATE transactions SET categoryId = :categoryId WHERE id IN (:ids)")
    suspend fun updateCategoryForIds(ids: List<Int>, categoryId: Int)

    @Query("UPDATE transactions SET description = :newDescription WHERE id IN (:ids)")
    suspend fun updateDescriptionForIds(ids: List<Int>, newDescription: String)

    @Query("""
        SELECT t.*, a.name as accountName, c.name as categoryName, c.iconKey as categoryIconKey, c.colorKey as categoryColorKey
        FROM transactions t
        LEFT JOIN accounts a ON t.accountId = a.id
        LEFT JOIN categories c ON t.categoryId = c.id
        WHERE
            (:keyword = '' OR LOWER(t.description) LIKE '%' || LOWER(:keyword) || '%' OR LOWER(t.notes) LIKE '%' || LOWER(:keyword) || '%') AND
            (:accountId IS NULL OR t.accountId = :accountId) AND
            (:categoryId IS NULL OR t.categoryId = :categoryId) AND
            (:transactionType IS NULL OR t.transactionType = :transactionType) AND
            (:startDate IS NULL OR t.date >= :startDate) AND
            (:endDate IS NULL OR t.date <= :endDate)
        ORDER BY t.date DESC
    """)
    suspend fun searchTransactions(
        keyword: String,
        accountId: Int?,
        categoryId: Int?,
        transactionType: String?,
        startDate: Long?,
        endDate: Long?,
    ): List<TransactionDetails>
}-e 


================== FILE: ./app/src/main/java/RecurringTransactionViewModel.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/RecurringTransactionViewModel.kt
// REASON: FEATURE - The ViewModel is updated to support full CRUD operations.
// It now includes `getRuleById`, `deleteRule`, and a comprehensive `saveRule`
// function that handles both creating new rules and updating existing ones.
// =================================================================================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.launch

class RecurringTransactionViewModel(application: Application) : AndroidViewModel(application) {
    private val repository: RecurringTransactionRepository
    val allRecurringTransactions: Flow<List<RecurringTransaction>>

    init {
        val recurringDao = AppDatabase.getInstance(application).recurringTransactionDao()
        repository = RecurringTransactionRepository(recurringDao)
        allRecurringTransactions = repository.getAll()
    }

    fun getRuleById(id: Int): Flow<RecurringTransaction?> = repository.getById(id)

    fun saveRule(
        ruleId: Int?, // Null for new rules
        description: String,
        amount: Double,
        transactionType: String,
        recurrenceInterval: String,
        startDate: Long,
        accountId: Int,
        categoryId: Int?,
        lastRunDate: Long? // Preserve last run date on edit
    ) = viewModelScope.launch {
        val rule = RecurringTransaction(
            id = ruleId ?: 0,
            description = description,
            amount = amount,
            transactionType = transactionType,
            recurrenceInterval = recurrenceInterval,
            startDate = startDate,
            accountId = accountId,
            categoryId = categoryId,
            lastRunDate = lastRunDate
        )

        if (ruleId != null) {
            repository.update(rule)
        } else {
            repository.insert(rule)
            // Only schedule the worker when a new rule is added for the first time
            ReminderManager.scheduleRecurringTransactionWorker(getApplication())
        }
    }

    fun deleteRule(rule: RecurringTransaction) = viewModelScope.launch {
        repository.delete(rule)
    }
}
-e 


================== FILE: ./app/src/main/java/CategoryIconHelper.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/CategoryIconHelper.kt
// REASON: FEATURE - A new, more comprehensive set of default categories has been
// added to the `predefinedCategories` list. The helper maps have also been
// updated with the corresponding new icons and background drawable mappings to
// support this expanded default set.
// =================================================================================
package io.pm.finlight

import androidx.annotation.DrawableRes
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.HelpOutline
import androidx.compose.material.icons.automirrored.filled.ReceiptLong
import androidx.compose.material.icons.automirrored.filled.Redo
import androidx.compose.material.icons.automirrored.filled.TrendingUp
import androidx.compose.material.icons.filled.*
import androidx.compose.material.icons.filled.HelpOutline
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import io.pm.finlight.R

/**
 * A helper object to manage category icons and colors, and provide a predefined list of categories.
 */
object CategoryIconHelper {

    private val iconColors = mapOf(
        "green_light" to Color(0xFFA5D6A7),
        "blue_light" to Color(0xFF90CAF9),
        "purple_light" to Color(0xFFCE93D8),
        "orange_light" to Color(0xFFFFCC80),
        "red_light" to Color(0xFFEF9A9A),
        "teal_light" to Color(0xFF80CBC4),
        "pink_light" to Color(0xFFF48FB1),
        "brown_light" to Color(0xFFBCAAA4),
        "cyan_light" to Color(0xFF80DEEA),
        "indigo_light" to Color(0xFF9FA8DA),
        "deep_purple_light" to Color(0xFFB39DDB),
        "yellow_light" to Color(0xFFFFF59D),
        "gray_light" to Color(0xFFE0E0E0),
    )

    private val categoryBackgrounds = mapOf(
        "receipt_long" to R.drawable.bg_cat_bills,
        "trending_up" to R.drawable.bg_cat_investment,
        "star" to R.drawable.bg_cat_entertainment,
        "restaurant" to R.drawable.bg_cat_food,
        "local_gas_station" to R.drawable.bg_cat_fuel,
        "shopping_cart" to R.drawable.bg_cat_groceries,
        "favorite" to R.drawable.bg_cat_health,
        "business" to R.drawable.bg_cat_investment,
        "shopping_bag" to R.drawable.bg_cat_shopping,
        "swap_horiz" to R.drawable.bg_cat_transfer,
        "travel_explore" to R.drawable.bg_cat_travel,
        "work" to R.drawable.bg_cat_salary,
        "redo" to R.drawable.bg_cat_refund,
        "add_card" to R.drawable.bg_cat_card,
        "more_horiz" to R.drawable.bg_cat_general,
        "schedule" to R.drawable.bg_cat_emi,
        // --- NEW: Mappings for new default categories ---
        "two_wheeler" to R.drawable.bg_cat_bike,
        "directions_car" to R.drawable.bg_cat_car,
        "credit_score" to R.drawable.bg_cat_debt,
        "people" to R.drawable.bg_cat_family,
        "group" to R.drawable.bg_cat_friends,
        "card_giftcard" to R.drawable.bg_cat_gift,
        "fitness_center" to R.drawable.bg_cat_fitness,
        "home" to R.drawable.bg_cat_home,
        "shield" to R.drawable.bg_cat_insurance,
        "school" to R.drawable.bg_cat_learning,
        "house" to R.drawable.bg_cat_rent,
        "help_outline" to R.drawable.bg_cat_general,
        "default" to R.drawable.bg_cat_general
    )

    @DrawableRes
    fun getCategoryBackground(categoryIconKey: String?): Int {
        return categoryBackgrounds[categoryIconKey] ?: R.drawable.bg_cat_general
    }


    fun getIconBackgroundColor(colorKey: String): Color {
        return iconColors[colorKey] ?: Color.LightGray
    }

    fun getAllIconColors(): Map<String, Color> {
        return iconColors
    }

    fun getNextAvailableColor(usedColorKeys: List<String>): String {
        return iconColors.keys.firstOrNull { it !in usedColorKeys }
            ?: iconColors.keys.firstOrNull()
            ?: "gray_light"
    }

    val predefinedCategories = listOf(
        Category(id = 1, name = "Bills", iconKey = "receipt_long", colorKey = "green_light"),
        Category(id = 2, name = "EMI", iconKey = "schedule", colorKey = "blue_light"),
        Category(id = 3, name = "Entertainment", iconKey = "star", colorKey = "purple_light"),
        Category(id = 4, name = "Food & Drinks", iconKey = "restaurant", colorKey = "orange_light"),
        Category(id = 5, name = "Fuel", iconKey = "local_gas_station", colorKey = "red_light"),
        Category(id = 6, name = "Groceries", iconKey = "shopping_cart", colorKey = "teal_light"),
        Category(id = 7, name = "Health", iconKey = "favorite", colorKey = "pink_light"),
        Category(id = 8, name = "Investment", iconKey = "business", colorKey = "brown_light"),
        Category(id = 9, name = "Shopping", iconKey = "shopping_bag", colorKey = "cyan_light"),
        Category(id = 10, name = "Transfer", iconKey = "swap_horiz", colorKey = "indigo_light"),
        Category(id = 11, name = "Travel", iconKey = "travel_explore", colorKey = "deep_purple_light"),
        Category(id = 12, name = "Salary", iconKey = "work", colorKey = "yellow_light"),
        Category(id = 13, name = "Other", iconKey = "more_horiz", colorKey = "gray_light"),
        Category(id = 14, name = "Refund", iconKey = "redo", colorKey = "green_light"),
        Category(id = 15, name = "Credit", iconKey = "add_card", colorKey = "blue_light"),
        // --- NEW: Added new set of default categories ---
        Category(id = 16, name = "Bike", iconKey = "two_wheeler", colorKey = "red_light"),
        Category(id = 17, name = "Car", iconKey = "directions_car", colorKey = "blue_light"),
        Category(id = 18, name = "Debt", iconKey = "credit_score", colorKey = "brown_light"),
        Category(id = 19, name = "Family", iconKey = "people", colorKey = "pink_light"),
        Category(id = 20, name = "Friends", iconKey = "group", colorKey = "cyan_light"),
        Category(id = 21, name = "Gift", iconKey = "card_giftcard", colorKey = "purple_light"),
        Category(id = 22, name = "Fitness", iconKey = "fitness_center", colorKey = "green_light"),
        Category(id = 23, name = "Home Maintenance", iconKey = "home", colorKey = "teal_light"),
        Category(id = 24, name = "Insurance", iconKey = "shield", colorKey = "indigo_light"),
        Category(id = 25, name = "Learning & Education", iconKey = "school", colorKey = "orange_light"),
        Category(id = 26, name = "Rent", iconKey = "house", colorKey = "deep_purple_light"),
    )

    fun getIcon(iconKey: String): ImageVector {
        return when (iconKey) {
            "receipt_long" -> Icons.AutoMirrored.Filled.ReceiptLong
            "trending_up" -> Icons.AutoMirrored.Filled.TrendingUp
            "star" -> Icons.Default.Star
            "restaurant" -> Icons.Default.Restaurant
            "local_gas_station" -> Icons.Default.LocalGasStation
            "shopping_cart" -> Icons.Default.ShoppingCart
            "favorite" -> Icons.Default.Favorite
            "business" -> Icons.Default.Business
            "shopping_bag" -> Icons.Default.ShoppingBag
            "swap_horiz" -> Icons.Default.SwapHoriz
            "travel_explore" -> Icons.Default.TravelExplore
            "account_balance" -> Icons.Default.AccountBalance
            "more_horiz" -> Icons.Default.MoreHoriz
            "card_giftcard" -> Icons.Default.CardGiftcard
            "school" -> Icons.Default.School
            "pets" -> Icons.Default.Pets
            "fastfood" -> Icons.Default.Fastfood
            "directions_car" -> Icons.Default.DirectionsCar
            "work" -> Icons.Default.Work
            "redo" -> Icons.Default.Redo
            "add_card" -> Icons.Default.AddCard
            "schedule" -> Icons.Default.Schedule
            // --- NEW: Mappings for new category icons ---
            "two_wheeler" -> Icons.Default.TwoWheeler
            "credit_score" -> Icons.Default.CreditScore
            "people" -> Icons.Default.People
            "group" -> Icons.Default.Group
            "fitness_center" -> Icons.Default.FitnessCenter
            "home" -> Icons.Default.Home
            "shield" -> Icons.Default.Shield
            "house" -> Icons.Default.House
            "help_outline" -> Icons.AutoMirrored.Filled.HelpOutline
            else -> Icons.Default.Category
        }
    }

    fun getAllIcons(): Map<String, ImageVector> {
        return mapOf(
            "receipt_long" to Icons.AutoMirrored.Filled.ReceiptLong,
            "trending_up" to Icons.AutoMirrored.Filled.TrendingUp,
            "star" to Icons.Default.Star,
            "restaurant" to Icons.Default.Restaurant,
            "local_gas_station" to Icons.Default.LocalGasStation,
            "shopping_cart" to Icons.Default.ShoppingCart,
            "favorite" to Icons.Default.Favorite,
            "business" to Icons.Default.Business,
            "shopping_bag" to Icons.Default.ShoppingBag,
            "swap_horiz" to Icons.Default.SwapHoriz,
            "travel_explore" to Icons.Default.TravelExplore,
            "account_balance" to Icons.Default.AccountBalance,
            "more_horiz" to Icons.Default.MoreHoriz,
            "card_giftcard" to Icons.Default.CardGiftcard,
            "school" to Icons.Default.School,
            "pets" to Icons.Default.Pets,
            "fastfood" to Icons.Default.Fastfood,
            "directions_car" to Icons.Default.DirectionsCar,
            "category" to Icons.Default.Category,
            "work" to Icons.Default.Work,
            "redo" to Icons.AutoMirrored.Filled.Redo,
            "add_card" to Icons.Default.AddCard,
            "schedule" to Icons.Default.Schedule,
            // --- NEW: Mappings for new category icons ---
            "two_wheeler" to Icons.Default.TwoWheeler,
            "credit_score" to Icons.Default.CreditScore,
            "people" to Icons.Default.People,
            "group" to Icons.Default.Group,
            "fitness_center" to Icons.Default.FitnessCenter,
            "home" to Icons.Default.Home,
            "shield" to Icons.Default.Shield,
            "house" to Icons.Default.House,
            "help_outline" to Icons.AutoMirrored.Filled.HelpOutline,
        )
    }
}
-e 


================== FILE: ./app/src/main/java/CategoryDao.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/CategoryDao.kt
// REASON: REFACTOR - The `findByName` query has been updated to use `COLLATE
// NOCASE`. This ensures that all direct lookups for a category by its name are
// case-insensitive, matching the new schema constraint.
// =================================================================================
package io.pm.finlight

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import kotlinx.coroutines.flow.Flow

@Dao
interface CategoryDao {

    @Query("SELECT * FROM categories ORDER BY name ASC")
    fun getAllCategories(): Flow<List<Category>>

    @Query("SELECT * FROM categories WHERE id = :categoryId")
    suspend fun getCategoryById(categoryId: Int): Category?

    // --- UPDATED: Use COLLATE NOCASE for explicit case-insensitive matching ---
    @Query("SELECT * FROM categories WHERE name = :name COLLATE NOCASE LIMIT 1")
    suspend fun findByName(name: String): Category?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(categories: List<Category>)

    @Query("DELETE FROM categories")
    suspend fun deleteAll()

    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insert(category: Category): Long

    @Update
    suspend fun update(category: Category)

    @Delete
    suspend fun delete(category: Category)
}-e 


================== FILE: ./app/src/main/java/MerchantCategoryMappingRepository.kt ==================
package io.pm.finlight

/**
 * Repository that abstracts access to the MerchantCategoryMapping data source.
 * This provides a clean API for the ViewModel to interact with the learning feature.
 */
class MerchantCategoryMappingRepository(private val dao: MerchantCategoryMappingDao) {

    /**
     * Inserts or updates a merchant-category mapping.
     *
     * @param mapping The mapping to save.
     */
    suspend fun insert(mapping: MerchantCategoryMapping) {
        dao.insert(mapping)
    }

    /**
     * Retrieves the learned category ID for a given merchant name.
     *
     * @param parsedName The name of the merchant.
     * @return The associated category ID, or null if none is found.
     */
    suspend fun getCategoryIdForMerchant(parsedName: String): Int? {
        return dao.getCategoryIdForMerchant(parsedName)
    }
}
-e 


================== FILE: ./app/src/main/java/BudgetDao.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/BudgetDao.kt
// REASON: BUG FIX - All `strftime` date functions have been updated to use the
// 'localtime' modifier. This ensures that all date-based grouping is performed
// using the device's local timezone instead of UTC. This corrects the bug where
// spending was being attributed to the wrong month, fixing budget calculations.
// =================================================================================
package io.pm.finlight

import androidx.room.*
import kotlinx.coroutines.flow.Flow

@Dao
interface BudgetDao {
    @Query("SELECT * FROM budgets WHERE month = :month AND year = :year")
    fun getBudgetsForMonth(
        month: Int,
        year: Int,
    ): Flow<List<Budget>>

    @Query(
        """
        SELECT
            B.*,
            IFNULL(TxSums.totalSpent, 0.0) as spent,
            Cat.iconKey as iconKey,
            Cat.colorKey as colorKey
        FROM
            budgets AS B
        LEFT JOIN
            (SELECT
                C.name as categoryName,
                SUM(T.amount) as totalSpent
             FROM transactions AS T
             JOIN categories AS C ON T.categoryId = C.id
             WHERE T.transactionType = 'expense' AND strftime('%Y-%m', T.date / 1000, 'unixepoch', 'localtime') = :yearMonth AND T.isExcluded = 0
             GROUP BY C.name) AS TxSums
        ON B.categoryName = TxSums.categoryName
        LEFT JOIN categories AS Cat ON B.categoryName = Cat.name
        WHERE B.month = :month AND B.year = :year
    """
    )
    fun getBudgetsWithSpendingForMonth(yearMonth: String, month: Int, year: Int): Flow<List<BudgetWithSpending>>


    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(budgets: List<Budget>)

    @Query("DELETE FROM budgets")
    suspend fun deleteAll()

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(budget: Budget)

    @Query(
        "SELECT SUM(amount) FROM transactions WHERE categoryId = (SELECT id FROM categories WHERE name = :categoryName) AND strftime('%m', date / 1000, 'unixepoch', 'localtime') + 0 = :month AND strftime('%Y', date / 1000, 'unixepoch', 'localtime') + 0 = :year AND transactionType = 'expense' AND isExcluded = 0",
    )
    fun getActualSpendingForCategory(
        categoryName: String,
        month: Int,
        year: Int,
    ): Flow<Double?>

    @Query("SELECT * FROM budgets")
    fun getAllBudgets(): Flow<List<Budget>>

    @Query("SELECT * FROM budgets WHERE id = :id")
    fun getById(id: Int): Flow<Budget?>

    @Update
    suspend fun update(budget: Budget)

    @Delete
    suspend fun delete(budget: Budget)
}
-e 


================== FILE: ./app/src/main/java/TimePeriod.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/TimePeriod.kt
// REASON: NEW FILE - Defines a simple enum to represent the different time
// periods for reporting, making the new generic report system type-safe.
// =================================================================================
package io.pm.finlight

enum class TimePeriod {
    DAILY,
    WEEKLY,
    MONTHLY
}-e 


================== FILE: ./app/src/main/java/DailyReportWorker.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/DailyReportWorker.kt
// REASON: BUG FIX - The worker's date calculation logic has been completely
// corrected. It now calculates a true rolling 24-hour window from the moment
// it executes. This ensures that the data gathered for the notification
// perfectly matches the data the user sees when they click the deep link,
// resolving the "no transactions" bug.
// =================================================================================
package io.pm.finlight

import android.content.Context
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.util.Calendar
import kotlin.math.roundToInt

class DailyReportWorker(
    private val context: Context,
    workerParams: WorkerParameters,
) : CoroutineWorker(context, workerParams) {
    override suspend fun doWork(): Result {
        return withContext(Dispatchers.IO) {
            try {
                Log.d("DailyReportWorker", "Worker starting for daily report...")
                val transactionDao = AppDatabase.getInstance(context).transactionDao()

                // --- FIX: Calculate a true rolling 24-hour window from now ---
                val endDate = Calendar.getInstance().timeInMillis
                val startDate = Calendar.getInstance().apply { add(Calendar.HOUR_OF_DAY, -24) }.timeInMillis

                // --- FIX: Calculate the comparison period as the 24 hours prior to the current period ---
                val previousPeriodEndDate = Calendar.getInstance().apply { add(Calendar.HOUR_OF_DAY, -24) }.timeInMillis
                val previousPeriodStartDate = Calendar.getInstance().apply { add(Calendar.HOUR_OF_DAY, -48) }.timeInMillis


                val currentPeriodSummary = transactionDao.getFinancialSummaryForRange(startDate, endDate)
                val currentPeriodExpenses = currentPeriodSummary?.totalExpenses ?: 0.0

                val previousPeriodSummary = transactionDao.getFinancialSummaryForRange(previousPeriodStartDate, previousPeriodEndDate)
                val previousPeriodExpenses = previousPeriodSummary?.totalExpenses ?: 0.0

                val topCategories = transactionDao.getTopSpendingCategoriesForRange(startDate, endDate)

                val percentageChange = if (previousPeriodExpenses > 0) {
                    ((currentPeriodExpenses - previousPeriodExpenses) / previousPeriodExpenses * 100).roundToInt()
                } else null

                // --- FIX: Pass the correct end date (now) to the notification helper ---
                NotificationHelper.showDailyReportNotification(context, currentPeriodExpenses, percentageChange, topCategories, endDate)

                ReminderManager.scheduleDailyReport(context)
                Log.d("DailyReportWorker", "Worker finished and rescheduled.")
                Result.success()
            } catch (e: Exception) {
                Log.e("DailyReportWorker", "Worker failed", e)
                Result.retry()
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/MerchantRenameRuleRepository.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/MerchantRenameRuleRepository.kt
// REASON: NEW FILE - This repository centralizes access to merchant renaming
// rules. It provides a clean, reusable way for different ViewModels to get all
// aliases as a simple Map, avoiding code duplication and promoting a clean
// architecture.
// =================================================================================
package io.pm.finlight

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

/**
 * Repository that abstracts access to the MerchantRenameRule data source.
 */
class MerchantRenameRuleRepository(private val dao: MerchantRenameRuleDao) {
    /**
     * Retrieves all rename rules from the database.
     */
    fun getAllRules(): Flow<List<MerchantRenameRule>> = dao.getAllRules()

    /**
     * Retrieves all rename rules and transforms them into a key-value map
     * for efficient lookups at display time.
     * @return A Flow emitting a Map where the key is the original name and the value is the new name.
     */
    fun getAliasesAsMap(): Flow<Map<String, String>> {
        return dao.getAllRules().map { rules ->
            rules.associate { it.originalName to it.newName }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/MerchantCategoryMapping.kt ==================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * Stores a user-defined mapping between a parsed merchant name and a specific category.
 * This allows the app to "learn" user preferences and auto-categorize future transactions.
 *
 * @param parsedName The merchant name as it was originally parsed from an SMS or other source. This is the key.
 * @param categoryId The ID of the Category the user has associated with this merchant.
 */
@Entity(tableName = "merchant_category_mapping")
data class MerchantCategoryMapping(
    @PrimaryKey
    val parsedName: String,
    val categoryId: Int
)
-e 


================== FILE: ./app/src/main/java/AccountDao.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/AccountDao.kt
// REASON: FIX - No changes were needed here. The `isExcluded = 0` filter was
// already correctly applied to the subquery in `getAccountsWithBalance`. This
// ensures that excluded transactions do not affect balance calculations, which
// is the desired behavior for this financial aggregation.
// =================================================================================
package io.pm.finlight

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Transaction
import androidx.room.Update
import kotlinx.coroutines.flow.Flow

@Dao
interface AccountDao {
    @Transaction
    @Query(
        """
        SELECT
            A.*,
            IFNULL(TxSums.balance, 0.0) as balance
        FROM
            accounts AS A
        LEFT JOIN
            (SELECT
                accountId,
                SUM(CASE WHEN transactionType = 'income' THEN amount ELSE -amount END) as balance
             FROM transactions
             WHERE isExcluded = 0 -- This is correct for a balance calculation
             GROUP BY accountId) AS TxSums
        ON A.id = TxSums.accountId
        ORDER BY
            A.name ASC
    """
    )
    fun getAccountsWithBalance(): Flow<List<AccountWithBalance>>

    @Query("SELECT * FROM accounts ORDER BY name ASC")
    fun getAllAccounts(): Flow<List<Account>>

    @Query("SELECT * FROM accounts WHERE name = :name COLLATE NOCASE LIMIT 1")
    suspend fun findByName(name: String): Account?

    @Query("SELECT * FROM accounts WHERE id = :accountId")
    fun getAccountById(accountId: Int): Flow<Account?>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(accounts: List<Account>)

    @Query("DELETE FROM accounts")
    suspend fun deleteAll()

    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insert(account: Account): Long

    @Update
    suspend fun update(account: Account)

    @Delete
    suspend fun delete(account: Account)
}
-e 


================== FILE: ./app/src/main/java/TagDao.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/TagDao.kt
// REASON: REFACTOR - Added a new `findByName` function that performs a
// case-insensitive search. This is essential for the ViewModel to check if a
// tag already exists before attempting to insert a new one, allowing for
// proper user feedback on duplicates.
// =================================================================================
package io.pm.finlight

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import kotlinx.coroutines.flow.Flow

@Dao
interface TagDao {
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insert(tag: Tag): Long

    @Query("SELECT * FROM tags ORDER BY name ASC")
    fun getAllTags(): Flow<List<Tag>>

    // --- NEW: Function to find a tag by name, case-insensitively ---
    @Query("SELECT * FROM tags WHERE name = :name COLLATE NOCASE LIMIT 1")
    suspend fun findByName(name: String): Tag?

    @Update
    suspend fun update(tag: Tag)

    @Delete
    suspend fun delete(tag: Tag)
}-e 


================== FILE: ./app/src/main/java/LoginResponse.kt ==================
package io.pm.finlight

data class LoginResponse(
    val message: String,
    // We can add a 'token' field later, e.g., val token: String
)
-e 


================== FILE: ./app/src/main/java/MerchantSpendingSummary.kt ==================
package io.pm.finlight

/**
 * A data class to hold aggregated spending data for a specific merchant.
 *
 * @param merchantName The name of the merchant (from the transaction description).
 * @param totalAmount The sum of all expenses for this merchant in a given period.
 * @param transactionCount The number of transactions (visits) for this merchant.
 */
data class MerchantSpendingSummary(
    val merchantName: String,
    val totalAmount: Double,
    val transactionCount: Int
)
-e 


================== FILE: ./app/src/main/java/BudgetWithSpending.kt ==================
package io.pm.finlight

import androidx.room.Embedded

data class BudgetWithSpending(
    @Embedded
    val budget: Budget,
    val spent: Double,
    // --- NEW: Add fields for category icon and color ---
    val iconKey: String?,
    val colorKey: String?
)
-e 


================== FILE: ./app/src/main/java/BootReceiver.kt ==================
package io.pm.finlight

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.util.Log

/**
 * A BroadcastReceiver that listens for the device boot completion event.
 * Its purpose is to re-schedule all necessary background workers (like daily,
 * weekly, and monthly reports) to ensure they persist across device reboots.
 */
class BootReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action == Intent.ACTION_BOOT_COMPLETED) {
            Log.d("BootReceiver", "Device boot completed. Re-scheduling workers.")
            // Re-schedule all workers based on their enabled status in SharedPreferences.
            val settings = context.getSharedPreferences("finance_app_settings", Context.MODE_PRIVATE)

            if (settings.getBoolean("daily_report_enabled", false)) {
                ReminderManager.scheduleDailyReport(context)
            }
            if (settings.getBoolean("weekly_summary_enabled", true)) {
                ReminderManager.scheduleWeeklySummary(context)
            }
            // You would also add the check for the monthly summary here once its toggle exists.
            // For now, we assume it's always on if scheduled.
            ReminderManager.scheduleMonthlySummary(context)
        }
    }
}
-e 


================== FILE: ./app/src/main/java/MainApplication.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/MainApplication.kt
// REASON: Added a new notification channel ID and a corresponding creation
// function to support the new monthly summary notifications.
// =================================================================================
package io.pm.finlight

import android.app.Application
import android.app.NotificationChannel
import android.app.NotificationManager
import android.os.Build
import com.github.mikephil.charting.utils.Utils

class MainApplication : Application() {
    companion object {
        const val TRANSACTION_CHANNEL_ID = "transaction_channel"
        const val DAILY_REPORT_CHANNEL_ID = "daily_report_channel"
        const val SUMMARY_CHANNEL_ID = "summary_channel"
        // --- NEW: Add a channel ID for monthly summaries ---
        const val MONTHLY_SUMMARY_CHANNEL_ID = "monthly_summary_channel"
    }

    override fun onCreate() {
        super.onCreate()
        Utils.init(this)

        createTransactionNotificationChannel()
        createDailyReportNotificationChannel()
        createSummaryNotificationChannel()
        // --- NEW: Call the creation function for the new channel ---
        createMonthlySummaryNotificationChannel()
    }

    private fun createTransactionNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val name = "Transactions"
            val descriptionText = "Notifications for newly detected transactions"
            val importance = NotificationManager.IMPORTANCE_DEFAULT
            val channel =
                NotificationChannel(TRANSACTION_CHANNEL_ID, name, importance).apply {
                    description = descriptionText
                }
            val notificationManager: NotificationManager =
                getSystemService(NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
    }

    private fun createDailyReportNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val name = "Daily Reports"
            val descriptionText = "Daily summary of your spending."
            val importance = NotificationManager.IMPORTANCE_DEFAULT
            val channel =
                NotificationChannel(DAILY_REPORT_CHANNEL_ID, name, importance).apply {
                    description = descriptionText
                }
            val notificationManager: NotificationManager =
                getSystemService(NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
    }

    private fun createSummaryNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val name = "Weekly Summaries"
            val descriptionText = "A weekly summary of your financial activity."
            val importance = NotificationManager.IMPORTANCE_DEFAULT
            val channel =
                NotificationChannel(SUMMARY_CHANNEL_ID, name, importance).apply {
                    description = descriptionText
                }
            val notificationManager: NotificationManager =
                getSystemService(NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
    }

    // --- NEW: Function to create the monthly summary notification channel ---
    private fun createMonthlySummaryNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val name = "Monthly Summaries"
            val descriptionText = "A monthly summary of your financial activity."
            val importance = NotificationManager.IMPORTANCE_DEFAULT
            val channel =
                NotificationChannel(MONTHLY_SUMMARY_CHANNEL_ID, name, importance).apply {
                    description = descriptionText
                }
            val notificationManager: NotificationManager =
                getSystemService(NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
    }
}
-e 


================== FILE: ./app/src/main/java/Budget.kt ==================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

@Serializable
@Entity(tableName = "budgets")
data class Budget(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val categoryName: String,
    val amount: Double,
    val month: Int, // e.g., 6 for June
    val year: Int, // e.g., 2024
)
-e 


================== FILE: ./app/src/main/java/Transaction.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/Transaction.kt
// REASON: FEATURE - Added a new Boolean field, `isExcluded`, with a default value
// of false. This field will be used to mark transactions that should be
// ignored in all financial calculations (e.g., summaries, budgets, net worth).
// =================================================================================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

@Serializable
@Entity(
    tableName = "transactions",
    indices = [
        Index(value = ["categoryId"]),
        Index(value = ["accountId"]),
    ],
    foreignKeys = [
        ForeignKey(
            entity = Category::class,
            parentColumns = ["id"],
            childColumns = ["categoryId"],
            onDelete = ForeignKey.SET_NULL,
        ),
        ForeignKey(
            entity = Account::class,
            parentColumns = ["id"],
            childColumns = ["accountId"],
            onDelete = ForeignKey.CASCADE,
        ),
    ],
)
data class Transaction(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val description: String,
    val categoryId: Int?,
    val amount: Double,
    val date: Long,
    val accountId: Int,
    val notes: String?,
    val transactionType: String = "expense",
    val sourceSmsId: Long? = null,
    val sourceSmsHash: String? = null,
    val source: String = "Manual Entry",
    val originalDescription: String? = null,
    val isExcluded: Boolean = false
)-e 


================== FILE: ./app/src/main/java/SmsReceiver.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/SmsReceiver.kt
// REASON: FEATURE - The receiver now passes the `merchantCategoryMappingDao`
// to the SmsParser. It then uses the `categoryId` from the resulting
// `PotentialTransaction` when creating the new `Transaction` object, enabling
// fully automatic categorization for known merchants.
// =================================================================================
package io.pm.finlight

import android.Manifest
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.provider.Telephony
import android.telephony.SmsMessage as TelephonySmsMessage
import android.util.Log
import androidx.core.app.ActivityCompat
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch

class SmsReceiver : BroadcastReceiver() {
    private val TAG = "SmsReceiver"

    override fun onReceive(
        context: Context,
        intent: Intent,
    ) {
        if (intent.action == Telephony.Sms.Intents.SMS_RECEIVED_ACTION) {
            val pendingResult = goAsync()
            CoroutineScope(Dispatchers.IO).launch {
                try {
                    val messages = Telephony.Sms.Intents.getMessagesFromIntent(intent)
                    val messagesBySender = messages.groupBy { it.originatingAddress }

                    for ((sender, parts) in messagesBySender) {
                        if (sender == null) continue

                        val fullBody = parts.joinToString("") { it.messageBody }
                        val smsId = parts.first().timestampMillis

                        val db = AppDatabase.getInstance(context)
                        val transactionDao = db.transactionDao()
                        val accountDao = db.accountDao()
                        val mappingRepository = MerchantMappingRepository(db.merchantMappingDao())
                        val merchantCategoryMappingDao = db.merchantCategoryMappingDao()
                        val ignoreRuleDao = db.ignoreRuleDao()
                        val settingsRepository = SettingsRepository(context)

                        val existingMappings = mappingRepository.allMappings.first().associateBy({ it.smsSender }, { it.merchantName })
                        val existingSmsHashes = transactionDao.getAllSmsHashes().first().toSet()

                        val smsMessage = SmsMessage(id = smsId, sender = sender, body = fullBody, date = smsId)
                        // --- UPDATED: Pass the merchantCategoryMappingDao to the parser ---
                        val potentialTxn = SmsParser.parse(
                            sms = smsMessage,
                            mappings = existingMappings,
                            customSmsRuleDao = db.customSmsRuleDao(),
                            merchantRenameRuleDao = db.merchantRenameRuleDao(),
                            ignoreRuleDao = ignoreRuleDao,
                            merchantCategoryMappingDao = merchantCategoryMappingDao
                        )

                        if (potentialTxn != null && !existingSmsHashes.contains(potentialTxn.sourceSmsHash)) {
                            Log.d(TAG, "New potential transaction found: $potentialTxn. Saving automatically.")

                            val accountName = potentialTxn.potentialAccount?.formattedName ?: "Unknown Account"
                            val accountType = potentialTxn.potentialAccount?.accountType ?: "General"

                            var account = accountDao.findByName(accountName)
                            if (account == null) {
                                val newAccount = Account(name = accountName, type = accountType)
                                accountDao.insert(newAccount)
                                account = accountDao.findByName(accountName)
                            }

                            if (account != null) {
                                val newTransaction = Transaction(
                                    description = potentialTxn.merchantName ?: "Unknown Merchant",
                                    originalDescription = potentialTxn.merchantName,
                                    amount = potentialTxn.amount,
                                    date = System.currentTimeMillis(),
                                    accountId = account.id,
                                    // --- UPDATED: Use the categoryId from the parser result ---
                                    categoryId = potentialTxn.categoryId,
                                    notes = "",
                                    transactionType = potentialTxn.transactionType,
                                    sourceSmsId = potentialTxn.sourceSmsId,
                                    sourceSmsHash = potentialTxn.sourceSmsHash,
                                    source = "Auto-Captured"
                                )
                                val newTransactionId = transactionDao.insert(newTransaction)
                                Log.d(TAG, "Transaction saved successfully with ID: $newTransactionId")

                                if (ActivityCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) == PackageManager.PERMISSION_GRANTED) {
                                    val savedTransaction = newTransaction.copy(id = newTransactionId.toInt())
                                    // --- UPDATED: Check if the parser found a category ---
                                    if (potentialTxn.categoryId == null && settingsRepository.isUnknownTransactionPopupEnabledBlocking()) {
                                        NotificationHelper.showTransactionNotification(context, savedTransaction)
                                    } else {
                                        NotificationHelper.showAutoSaveConfirmationNotification(context, savedTransaction)
                                    }
                                }

                            } else {
                                Log.e(TAG, "Failed to find or create an account for the transaction.")
                            }
                        }
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Error processing SMS", e)
                } finally {
                    pendingResult.finish()
                }
            }
        }
    }
}-e 


================== FILE: ./app/src/main/java/NotificationHelper.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/NotificationHelper.kt
// REASON: FEATURE - Added showRecurringTransactionDueNotification. This new
// function creates a specific notification for due recurring payments, with a
// deep link to the new LinkTransactionScreen. This is a core component of the
// new user-driven recurring transaction workflow.
// =================================================================================
package io.pm.finlight

import android.Manifest
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.app.TaskStackBuilder
import androidx.core.net.toUri
import com.google.gson.Gson
import java.net.URLEncoder
import java.text.NumberFormat
import java.util.Calendar
import java.util.Locale
import kotlin.math.abs

object NotificationHelper {
    private const val DEEP_LINK_URI_APPROVE = "app://finlight.pm.io/approve_sms"
    private const val DEEP_LINK_URI_EDIT = "app://finlight.pm.io/transaction_detail"
    private const val DEEP_LINK_URI_REPORT_BASE = "app://finlight.pm.io/report"
    // --- NEW: Deep link for the new recurring transaction flow ---
    private const val DEEP_LINK_URI_LINK_RECURRING = "app://finlight.pm.io/link_recurring"


    // --- NEW: Notification for when a recurring transaction is due ---
    fun showRecurringTransactionDueNotification(
        context: Context,
        potentialTxn: PotentialTransaction
    ) {
        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
            return
        }

        val json = Gson().toJson(potentialTxn)
        val encodedJson = URLEncoder.encode(json, "UTF-8")
        val deepLinkUri = "$DEEP_LINK_URI_LINK_RECURRING/$encodedJson".toUri()

        val intent = Intent(Intent.ACTION_VIEW, deepLinkUri).apply {
            `package` = context.packageName
        }

        val pendingIntent: PendingIntent? = TaskStackBuilder.create(context).run {
            addNextIntentWithParentStack(intent)
            getPendingIntent(potentialTxn.sourceSmsId.toInt(), PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
        }

        val currencyFormat = NumberFormat.getCurrencyInstance(Locale("en", "IN"))
        val contentText = "Your payment of ${currencyFormat.format(potentialTxn.amount)} for ${potentialTxn.merchantName} is due. Tap to confirm."

        val builder = NotificationCompat.Builder(context, MainApplication.TRANSACTION_CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_launcher_foreground)
            .setContentTitle("Recurring Payment Due")
            .setContentText(contentText)
            .setStyle(NotificationCompat.BigTextStyle().bigText(contentText))
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .addAction(0, "Confirm Payment", pendingIntent)

        with(NotificationManagerCompat.from(context)) {
            notify(potentialTxn.sourceSmsId.toInt(), builder.build())
        }
    }


    private fun createEnhancedSummaryNotification(
        context: Context,
        channelId: String,
        notificationId: Int,
        title: String, // Changed from periodText to full title for more flexibility
        totalExpenses: Double,
        percentageChange: Int?, // Kept for logic, but title is now pre-formatted
        topCategories: List<CategorySpending>,
        deepLinkUri: String
    ) {
        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
            return
        }

        val intent = Intent(Intent.ACTION_VIEW, deepLinkUri.toUri())
        intent.`package` = context.packageName

        val pendingIntent: PendingIntent? = TaskStackBuilder.create(context).run {
            addNextIntentWithParentStack(intent)
            getPendingIntent(notificationId, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
        }

        val currencyFormat = NumberFormat.getCurrencyInstance(Locale("en", "IN"))
        val bigContentText = "You spent ${currencyFormat.format(totalExpenses)} in total."

        val inboxStyle = NotificationCompat.InboxStyle()
            .setBigContentTitle(title)
            .setSummaryText("Got 2 mins to review?")

        if (topCategories.isNotEmpty()) {
            inboxStyle.addLine("Top spends:")
            for (category in topCategories) {
                inboxStyle.addLine(" ${category.categoryName}: ${currencyFormat.format(category.totalAmount)}")
            }
        } else {
            inboxStyle.addLine("No expenses recorded for this period.")
        }

        val builder = NotificationCompat.Builder(context, channelId)
            .setSmallIcon(R.drawable.ic_launcher_foreground)
            .setContentTitle(title)
            .setContentText(bigContentText)
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setContentIntent(pendingIntent)
            .setStyle(inboxStyle)
            .setAutoCancel(true)
            .addAction(android.R.drawable.ic_menu_view, "Review", pendingIntent)

        with(NotificationManagerCompat.from(context)) {
            notify(notificationId, builder.build())
        }
    }


    fun showDailyReportNotification(
        context: Context,
        totalExpenses: Double,
        percentageChange: Int?,
        topCategories: List<CategorySpending>,
        dateMillis: Long
    ) {
        val title = when {
            percentageChange == null -> "Yesterday's Summary"
            percentageChange == 0 -> "Spending same as day before"
            percentageChange > 0 -> "Spending up by $percentageChange% yesterday"
            else -> "Spending down by ${abs(percentageChange)}% yesterday"
        }
        val deepLinkUri = "$DEEP_LINK_URI_REPORT_BASE/${TimePeriod.DAILY}?date=$dateMillis"

        createEnhancedSummaryNotification(
            context,
            MainApplication.DAILY_REPORT_CHANNEL_ID,
            2,
            title,
            totalExpenses,
            null,
            topCategories,
            deepLinkUri
        )
    }

    fun showWeeklySummaryNotification(
        context: Context,
        totalExpenses: Double,
        percentageChange: Int?,
        topCategories: List<CategorySpending>
    ) {
        val title = when {
            percentageChange == null -> "Your Weekly Summary"
            percentageChange == 0 -> "Spends same as last week"
            percentageChange > 0 -> "Spends up by $percentageChange% this week"
            else -> "Spends down by ${abs(percentageChange)}% this week"
        }
        createEnhancedSummaryNotification(
            context,
            MainApplication.SUMMARY_CHANNEL_ID,
            3,
            title,
            totalExpenses,
            null,
            topCategories,
            "$DEEP_LINK_URI_REPORT_BASE/${TimePeriod.WEEKLY}"
        )
    }

    fun showMonthlySummaryNotification(
        context: Context,
        calendar: Calendar,
        totalExpenses: Double,
        percentageChange: Int?,
        topCategories: List<CategorySpending>
    ) {
        val monthName = calendar.getDisplayName(Calendar.MONTH, Calendar.LONG, Locale.getDefault()) ?: "Month"
        val title = when {
            percentageChange == null -> "Your $monthName Summary"
            percentageChange == 0 -> "Spends same as last month"
            percentageChange > 0 -> "Spends up by $percentageChange% in $monthName"
            else -> "Spends down by ${abs(percentageChange)}% in $monthName"
        }
        createEnhancedSummaryNotification(
            context,
            MainApplication.MONTHLY_SUMMARY_CHANNEL_ID,
            4,
            title,
            totalExpenses,
            null,
            topCategories,
            "$DEEP_LINK_URI_REPORT_BASE/${TimePeriod.MONTHLY}"
        )
    }


    fun showAutoSaveConfirmationNotification(
        context: Context,
        transaction: Transaction
    ) {
        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
            return
        }

        val detailIntent = Intent(
            Intent.ACTION_VIEW,
            "$DEEP_LINK_URI_EDIT/${transaction.id}".toUri(),
            context,
            MainActivity::class.java
        )

        val pendingIntent: PendingIntent? = TaskStackBuilder.create(context).run {
            addNextIntentWithParentStack(detailIntent)
            getPendingIntent(transaction.id, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
        }

        val groupKey = "finlight_transaction_group_${transaction.id}"

        val builder = NotificationCompat.Builder(context, MainApplication.TRANSACTION_CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_launcher_foreground)
            .setContentTitle("Transaction Auto-Saved")
            .setContentText("Saved ${transaction.description} (${"%.2f".format(transaction.amount)}). Tap to edit or categorize.")
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .setGroup(groupKey)
            .addAction(android.R.drawable.ic_menu_edit, "Edit", pendingIntent)

        with(NotificationManagerCompat.from(context)) {
            notify(transaction.id, builder.build())
        }
    }

    fun showTransactionNotification(
        context: Context,
        transaction: Transaction,
    ) {
        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
            return
        }

        val detailUri = "$DEEP_LINK_URI_EDIT/${transaction.id}".toUri()

        val intent = Intent(Intent.ACTION_VIEW, detailUri).apply {
            `package` = context.packageName
        }

        val pendingIntent: PendingIntent? = TaskStackBuilder.create(context).run {
            addNextIntentWithParentStack(intent)
            getPendingIntent(transaction.id, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
        }

        val notificationIcon = android.R.drawable.ic_dialog_info
        val typeText = transaction.transactionType.replaceFirstChar { it.uppercase() }
        val bigText = "$typeText of ${"%.2f".format(transaction.amount)} from ${transaction.description} detected. Tap to review and categorize."

        val builder = NotificationCompat.Builder(context, MainApplication.TRANSACTION_CHANNEL_ID)
            .setSmallIcon(notificationIcon)
            .setContentTitle("New Transaction Found")
            .setContentText("Tap to review a transaction from ${transaction.description}.")
            .setStyle(NotificationCompat.BigTextStyle().bigText(bigText))
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .addAction(notificationIcon, "Review & Categorize", pendingIntent)

        with(NotificationManagerCompat.from(context)) {
            notify(transaction.id, builder.build())
        }
    }
}
-e 


================== FILE: ./app/src/main/java/RecurringTransactionWorker.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/RecurringTransactionWorker.kt
// REASON: REFACTOR - The worker's core logic has been completely overhauled.
// Instead of creating a new transaction, it now calls a new function in
// NotificationHelper to show a notification for each due rule. This aligns
// with the new user-driven workflow. The isDue function is updated to be more
// robust, checking for missed runs.
// =================================================================================
package io.pm.finlight

import android.content.Context
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.google.gson.Gson
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.util.Calendar

class RecurringTransactionWorker(
    private val context: Context,
    workerParams: WorkerParameters
) : CoroutineWorker(context, workerParams) {

    override suspend fun doWork(): Result {
        Log.d("RecurringTxnWorker", "Worker starting to check for due recurring rules...")
        return withContext(Dispatchers.IO) {
            try {
                val db = AppDatabase.getInstance(context)
                val recurringDao = db.recurringTransactionDao()

                val allRules = recurringDao.getAllRulesList()
                Log.d("RecurringTxnWorker", "Found ${allRules.size} rules to check.")

                allRules.forEach { rule ->
                    if (isDue(rule)) {
                        Log.d("RecurringTxnWorker", "Rule '${rule.description}' is due. Sending notification.")
                        // --- NEW: Instead of creating a transaction, show a notification ---
                        val potentialTxn = PotentialTransaction(
                            sourceSmsId = rule.id.toLong(), // Re-using this field for the rule ID
                            smsSender = "Recurring Rule",
                            amount = rule.amount,
                            transactionType = rule.transactionType,
                            merchantName = rule.description,
                            originalMessage = "Recurring payment for ${rule.description}",
                            sourceSmsHash = "recurring_${rule.id}"
                        )
                        NotificationHelper.showRecurringTransactionDueNotification(context, potentialTxn)
                    }
                }

                // Reschedule for the next day
                ReminderManager.scheduleRecurringTransactionWorker(context)
                Log.d("RecurringTxnWorker", "Worker finished and rescheduled for tomorrow.")
                Result.success()
            } catch (e: Exception) {
                Log.e("RecurringTxnWorker", "Worker failed", e)
                Result.retry()
            }
        }
    }

    /**
     * Determines if a recurring transaction rule is due to be executed today.
     */
    private fun isDue(rule: RecurringTransaction): Boolean {
        val today = Calendar.getInstance()
        val ruleStartCal = Calendar.getInstance().apply { timeInMillis = rule.startDate }

        // If the rule's start date is in the future, it's not due yet.
        if (today.before(ruleStartCal)) {
            return false
        }

        // If the rule has never run, it's due.
        if (rule.lastRunDate == null) {
            return true
        }

        val lastRunCal = Calendar.getInstance().apply { timeInMillis = rule.lastRunDate }
        val nextDueDate = (lastRunCal.clone() as Calendar).apply {
            when (rule.recurrenceInterval) {
                "Daily" -> add(Calendar.DAY_OF_YEAR, 1)
                "Weekly" -> add(Calendar.WEEK_OF_YEAR, 1)
                "Monthly" -> add(Calendar.MONTH, 1)
                "Yearly" -> add(Calendar.YEAR, 1)
            }
            // Set to beginning of the day for consistent comparison
            set(Calendar.HOUR_OF_DAY, 0)
            set(Calendar.MINUTE, 0)
            set(Calendar.SECOND, 0)
            set(Calendar.MILLISECOND, 0)
        }

        val todayStartOfDay = (today.clone() as Calendar).apply {
            set(Calendar.HOUR_OF_DAY, 0)
            set(Calendar.MINUTE, 0)
            set(Calendar.SECOND, 0)
            set(Calendar.MILLISECOND, 0)
        }

        // Check if today is on or after the calculated next due date.
        // We use 'on or after' to catch up on any missed runs (e.g., if the device was off).
        return !todayStartOfDay.before(nextDueDate)
    }
}
-e 


================== FILE: ./app/src/main/java/TransactionRepository.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/TransactionRepository.kt
// REASON: FEATURE - The repository now exposes the new DAO functions for the
// Retrospective Update feature. `findSimilarTransactions`,
// `updateCategoryForIds`, and `updateDescriptionForIds` are now available to
// be called by the ViewModel layer, providing a clean abstraction over the
// database operations.
// =================================================================================
package io.pm.finlight

import android.net.Uri
import android.util.Log
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.onEach

class TransactionRepository(private val transactionDao: TransactionDao) {
    val allTransactions: Flow<List<TransactionDetails>> =
        transactionDao.getAllTransactions()
            .onEach { transactions ->
                Log.d(
                    "TransactionFlowDebug",
                    "Repository Flow Emitted. Count: ${transactions.size}. Newest: ${transactions.firstOrNull()?.transaction?.description}",
                )
            }

    fun getIncomeTransactionsForRange(startDate: Long, endDate: Long, keyword: String?, accountId: Int?, categoryId: Int?): Flow<List<TransactionDetails>> {
        return transactionDao.getIncomeTransactionsForRange(startDate, endDate, keyword, accountId, categoryId)
    }

    fun getIncomeByCategoryForMonth(startDate: Long, endDate: Long, keyword: String?, accountId: Int?, categoryId: Int?): Flow<List<CategorySpending>> {
        return transactionDao.getIncomeByCategoryForMonth(startDate, endDate, keyword, accountId, categoryId)
    }

    fun getSpendingByMerchantForMonth(startDate: Long, endDate: Long, keyword: String?, accountId: Int?, categoryId: Int?): Flow<List<MerchantSpendingSummary>> {
        return transactionDao.getSpendingByMerchantForMonth(startDate, endDate, keyword, accountId, categoryId)
    }

    suspend fun addImageToTransaction(transactionId: Int, imageUri: String) {
        val transactionImage = TransactionImage(transactionId = transactionId, imageUri = imageUri)
        transactionDao.insertImage(transactionImage)
    }

    suspend fun deleteImage(transactionImage: TransactionImage) {
        transactionDao.deleteImage(transactionImage)
    }

    fun getImagesForTransaction(transactionId: Int): Flow<List<TransactionImage>> {
        return transactionDao.getImagesForTransaction(transactionId)
    }

    suspend fun updateDescription(id: Int, description: String) = transactionDao.updateDescription(id, description)
    suspend fun updateAmount(id: Int, amount: Double) = transactionDao.updateAmount(id, amount)
    suspend fun updateNotes(id: Int, notes: String?) = transactionDao.updateNotes(id, notes)
    suspend fun updateCategoryId(id: Int, categoryId: Int?) = transactionDao.updateCategoryId(id, categoryId)
    suspend fun updateAccountId(id: Int, accountId: Int) = transactionDao.updateAccountId(id, accountId)
    suspend fun updateDate(id: Int, date: Long) = transactionDao.updateDate(id, date)
    suspend fun updateExclusionStatus(id: Int, isExcluded: Boolean) = transactionDao.updateExclusionStatus(id, isExcluded)

    fun getTransactionDetailsById(id: Int): Flow<TransactionDetails?> {
        return transactionDao.getTransactionDetailsById(id)
    }

    val recentTransactions: Flow<List<TransactionDetails>> = transactionDao.getRecentTransactionDetails()

    fun getAllSmsHashes(): Flow<List<String>> {
        return transactionDao.getAllSmsHashes()
    }

    fun getTransactionsForAccountDetails(accountId: Int): Flow<List<TransactionDetails>> {
        return transactionDao.getTransactionsForAccountDetails(accountId)
    }

    fun getTransactionDetailsForRange(
        startDate: Long,
        endDate: Long,
        keyword: String?,
        accountId: Int?,
        categoryId: Int?
    ): Flow<List<TransactionDetails>> {
        return transactionDao.getTransactionDetailsForRange(startDate, endDate, keyword, accountId, categoryId)
    }

    fun getAllTransactionsSimple(): Flow<List<Transaction>> {
        return transactionDao.getAllTransactionsSimple()
    }

    fun getAllTransactionsForRange(
        startDate: Long,
        endDate: Long,
    ): Flow<List<Transaction>> {
        return transactionDao.getAllTransactionsForRange(startDate, endDate)
    }

    fun getTransactionById(id: Int): Flow<Transaction?> {
        return transactionDao.getTransactionById(id)
    }

    fun getTransactionsForAccount(accountId: Int): Flow<List<Transaction>> {
        return transactionDao.getTransactionsForAccount(accountId)
    }

    fun getSpendingForCategory(
        categoryName: String,
        startDate: Long,
        endDate: Long,
    ): Flow<Double?> {
        return transactionDao.getSpendingForCategory(categoryName, startDate, endDate)
    }

    fun getSpendingByCategoryForMonth(
        startDate: Long,
        endDate: Long,
        keyword: String?,
        accountId: Int?,
        categoryId: Int?
    ): Flow<List<CategorySpending>> {
        return transactionDao.getSpendingByCategoryForMonth(startDate, endDate, keyword, accountId, categoryId)
    }

    fun getMonthlyTrends(startDate: Long): Flow<List<MonthlyTrend>> {
        return transactionDao.getMonthlyTrends(startDate)
    }

    suspend fun countTransactionsForCategory(categoryId: Int): Int {
        return transactionDao.countTransactionsForCategory(categoryId)
    }

    fun getTagsForTransaction(transactionId: Int): Flow<List<Tag>> {
        return transactionDao.getTagsForTransaction(transactionId)
    }

    suspend fun updateTagsForTransaction(transactionId: Int, tags: Set<Tag>) {
        transactionDao.clearTagsForTransaction(transactionId)
        if (tags.isNotEmpty()) {
            val crossRefs = tags.map { tag ->
                TransactionTagCrossRef(transactionId = transactionId, tagId = tag.id)
            }
            transactionDao.addTagsToTransaction(crossRefs)
        }
    }

    suspend fun insertTransactionWithTags(transaction: Transaction, tags: Set<Tag>) {
        val transactionId = transactionDao.insert(transaction).toInt()
        if (tags.isNotEmpty()) {
            val crossRefs = tags.map { tag ->
                TransactionTagCrossRef(transactionId = transactionId, tagId = tag.id)
            }
            transactionDao.addTagsToTransaction(crossRefs)
        }
    }

    suspend fun updateTransactionWithTags(transaction: Transaction, tags: Set<Tag>) {
        transactionDao.update(transaction)
        transactionDao.clearTagsForTransaction(transaction.id)
        if (tags.isNotEmpty()) {
            val crossRefs = tags.map { tag ->
                TransactionTagCrossRef(transactionId = transaction.id, tagId = tag.id)
            }
            transactionDao.addTagsToTransaction(crossRefs)
        }
    }

    suspend fun insertTransactionWithTagsAndImages(
        transaction: Transaction,
        tags: Set<Tag>,
        imagePaths: List<String>
    ): Long {
        val newTransactionId = transactionDao.insert(transaction)
        if (tags.isNotEmpty()) {
            val crossRefs = tags.map { tag ->
                TransactionTagCrossRef(transactionId = newTransactionId.toInt(), tagId = tag.id)
            }
            transactionDao.addTagsToTransaction(crossRefs)
        }
        imagePaths.forEach { path ->
            val imageEntity = TransactionImage(
                transactionId = newTransactionId.toInt(),
                imageUri = path
            )
            transactionDao.insertImage(imageEntity)
        }
        return newTransactionId
    }

    suspend fun insert(transaction: Transaction) {
        transactionDao.insert(transaction)
    }

    suspend fun update(transaction: Transaction) {
        transactionDao.update(transaction)
    }

    suspend fun delete(transaction: Transaction) {
        transactionDao.delete(transaction)
    }

    suspend fun setSmsHash(transactionId: Int, smsHash: String) {
        transactionDao.setSmsHash(transactionId, smsHash)
    }

    suspend fun findLinkableTransactions(
        smsDate: Long,
        smsAmount: Double,
        transactionType: String
    ): List<Transaction> {
        val sevenDaysInMillis = 7 * 24 * 60 * 60 * 1000
        val startDate = smsDate - sevenDaysInMillis
        val endDate = smsDate + sevenDaysInMillis

        val amountRange = smsAmount * 0.10
        val minAmount = smsAmount - amountRange
        val maxAmount = smsAmount + amountRange

        return transactionDao.findLinkableTransactions(
            startDate = startDate,
            endDate = endDate,
            minAmount = minAmount,
            maxAmount = maxAmount,
            smsDate = smsDate,
            transactionType = transactionType
        )
    }

    fun getTransactionCountForMerchant(description: String): Flow<Int> {
        return transactionDao.getTransactionCountForMerchant(description)
    }

    // --- NEW: Expose DAO function for finding similar transactions ---
    suspend fun findSimilarTransactions(description: String, excludeId: Int): List<Transaction> {
        return transactionDao.findSimilarTransactions(description, excludeId)
    }

    // --- NEW: Expose DAO function for batch updating category ---
    suspend fun updateCategoryForIds(ids: List<Int>, categoryId: Int) {
        transactionDao.updateCategoryForIds(ids, categoryId)
    }

    // --- NEW: Expose DAO function for batch updating description ---
    suspend fun updateDescriptionForIds(ids: List<Int>, newDescription: String) {
        transactionDao.updateDescriptionForIds(ids, newDescription)
    }
}
-e 


================== FILE: ./app/src/main/java/DailyTotal.kt ==================
package io.pm.finlight

/**
 * A simple data class to hold the results of a GROUP BY query,
 * containing a date string and the total amount spent on that day.
 */
data class DailyTotal(
    val date: String, // Format: "YYYY-MM-DD"
    val totalAmount: Double
)-e 


================== FILE: ./app/src/main/java/DashboardViewModel.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/DashboardViewModel.kt
// REASON: FEATURE - The ViewModel now fully manages card visibility. It maintains
// a separate StateFlow for the visible card set, provides `hideCard` and
// `showCard` functions to modify it, and exposes a `hiddenCards` flow for the
// "Add Card" UI. The `exitCustomizationModeAndSave` function now saves both
// the order and the visibility state.
// =================================================================================
package io.pm.finlight

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Collections
import java.util.Locale

class DashboardViewModel(
    private val transactionRepository: TransactionRepository,
    private val accountRepository: AccountRepository,
    private val budgetDao: BudgetDao,
    private val settingsRepository: SettingsRepository,
) : ViewModel() {
    val userName: StateFlow<String>
    val profilePictureUri: StateFlow<String?>

    val netWorth: StateFlow<Double>
    val monthlyIncome: StateFlow<Double>
    val monthlyExpenses: StateFlow<Double>
    val recentTransactions: StateFlow<List<TransactionDetails>>
    val budgetStatus: StateFlow<List<BudgetWithSpending>>
    val overallMonthlyBudget: StateFlow<Float>
    val amountRemaining: StateFlow<Float>
    val safeToSpendPerDay: StateFlow<Float>
    val accountsSummary: StateFlow<List<AccountWithBalance>>
    // --- NEW: Expose the current month's name ---
    val monthYear: String

    val visibleCards: StateFlow<List<DashboardCardType>>

    private val _isCustomizationMode = MutableStateFlow(false)
    val isCustomizationMode: StateFlow<Boolean> = _isCustomizationMode.asStateFlow()

    private val _cardOrder = MutableStateFlow<List<DashboardCardType>>(emptyList())
    private val _visibleCardsSet = MutableStateFlow<Set<DashboardCardType>>(emptySet())

    // --- NEW: Expose hidden cards for the "Add Card" sheet ---
    val hiddenCards: StateFlow<List<DashboardCardType>>

    // --- NEW: State to control the "Add Card" bottom sheet ---
    private val _showAddCardSheet = MutableStateFlow(false)
    val showAddCardSheet: StateFlow<Boolean> = _showAddCardSheet.asStateFlow()


    init {
        userName = settingsRepository.getUserName()
            .stateIn(
                scope = viewModelScope,
                started = SharingStarted.WhileSubscribed(5000),
                initialValue = "User"
            )

        profilePictureUri = settingsRepository.getProfilePictureUri()
            .stateIn(
                scope = viewModelScope,
                started = SharingStarted.WhileSubscribed(5000),
                initialValue = null
            )

        viewModelScope.launch {
            settingsRepository.getDashboardCardOrder().collect {
                _cardOrder.value = it
            }
        }
        viewModelScope.launch {
            settingsRepository.getDashboardVisibleCards().collect {
                _visibleCardsSet.value = it
            }
        }

        visibleCards = combine(
            _cardOrder,
            _visibleCardsSet
        ) { order, visible ->
            order.filter { it in visible }
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

        hiddenCards = combine(
            _cardOrder,
            _visibleCardsSet
        ) { order, visible ->
            order.filterNot { it in visible }
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())


        val calendar = Calendar.getInstance()
        // --- NEW: Get the full month name ---
        monthYear = SimpleDateFormat("MMMM", Locale.getDefault()).format(calendar.time)

        val monthStart =
            (calendar.clone() as Calendar).apply {
                set(Calendar.DAY_OF_MONTH, 1)
                set(Calendar.HOUR_OF_DAY, 0)
                set(Calendar.MINUTE, 0)
                set(Calendar.SECOND, 0)
                set(Calendar.MILLISECOND, 0)
            }.timeInMillis
        val monthEnd =
            (calendar.clone() as Calendar).apply {
                add(Calendar.MONTH, 1)
                set(Calendar.DAY_OF_MONTH, 1)
                add(Calendar.DAY_OF_MONTH, -1)
                set(Calendar.HOUR_OF_DAY, 23)
                set(Calendar.MINUTE, 59)
                set(Calendar.SECOND, 59)
                set(Calendar.MILLISECOND, 999)
            }.timeInMillis

        val transactionsThisMonth = transactionRepository.getTransactionDetailsForRange(
            startDate = monthStart,
            endDate = monthEnd,
            keyword = null,
            accountId = null,
            categoryId = null
        ).stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

        monthlyIncome =
            transactionsThisMonth.map { transactions ->
                transactions
                    .filter { it.transaction.transactionType == "income" && !it.transaction.isExcluded }
                    .sumOf { it.transaction.amount }
            }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0.0)

        monthlyExpenses =
            transactionsThisMonth.map { transactions ->
                transactions
                    .filter { it.transaction.transactionType == "expense" && !it.transaction.isExcluded }
                    .sumOf { it.transaction.amount }
            }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0.0)

        val currentYear = calendar.get(Calendar.YEAR)
        val currentMonth = calendar.get(Calendar.MONTH) + 1

        overallMonthlyBudget =
            settingsRepository.getOverallBudgetForMonth(currentYear, currentMonth)
                .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0f)

        amountRemaining =
            combine(overallMonthlyBudget, monthlyExpenses) { budget, expenses ->
                budget - expenses.toFloat()
            }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0f)

        safeToSpendPerDay =
            amountRemaining.map { remaining ->
                val today = Calendar.getInstance()
                val lastDayOfMonth = today.getActualMaximum(Calendar.DAY_OF_MONTH)
                val remainingDays = (lastDayOfMonth - today.get(Calendar.DAY_OF_MONTH) + 1).coerceAtLeast(1)

                if (remaining > 0) remaining / remainingDays else 0f
            }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0f)

        netWorth =
            accountRepository.accountsWithBalance.map { list ->
                list.sumOf { it.balance }
            }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0.0)

        recentTransactions =
            transactionRepository.recentTransactions
                .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

        val yearMonthString = SimpleDateFormat("yyyy-MM", Locale.getDefault()).format(calendar.time)
        budgetStatus = budgetDao.getBudgetsWithSpendingForMonth(yearMonthString, currentMonth, currentYear)
            .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

        accountsSummary =
            accountRepository.accountsWithBalance
                .stateIn(
                    scope = viewModelScope,
                    started = SharingStarted.WhileSubscribed(5000),
                    initialValue = emptyList(),
                )
    }

    fun enterCustomizationMode() {
        _isCustomizationMode.value = true
    }

    fun exitCustomizationModeAndSave() {
        viewModelScope.launch {
            // --- UPDATED: Save both order and visibility ---
            settingsRepository.saveDashboardLayout(_cardOrder.value, _visibleCardsSet.value)
            _isCustomizationMode.value = false
        }
    }

    fun updateCardOrder(from: Int, to: Int) {
        _cardOrder.update { currentList ->
            currentList.toMutableList().apply {
                add(to, removeAt(from))
            }
        }
    }

    // --- NEW: Functions to manage card visibility ---
    fun hideCard(cardType: DashboardCardType) {
        _visibleCardsSet.update { it - cardType }
    }

    fun showCard(cardType: DashboardCardType) {
        _visibleCardsSet.update { it + cardType }
    }

    fun onAddCardClick() {
        _showAddCardSheet.value = true
    }

    fun onAddCardSheetDismiss() {
        _showAddCardSheet.value = false
    }
}
-e 


================== FILE: ./app/src/main/java/MerchantRenameRule.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/MerchantRenameRule.kt
// REASON: REFACTOR - The `originalName` primary key has been updated with
// `collate = NOCASE`. This makes the rule matching case-insensitive, so a rule
// for "zomato" will correctly apply to transactions parsed as "Zomato".
// =================================================================================
package io.pm.finlight

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * Stores a user-defined rule to rename a parsed merchant name to a more
 * user-friendly one.
 * @param originalName The name originally extracted by the parser's regex.
 * @param newName The name the user wants to see instead.
 */
@Entity(tableName = "merchant_rename_rules")
data class MerchantRenameRule(
    // --- UPDATED: Make the primary key case-insensitive ---
    @PrimaryKey
    @ColumnInfo(name = "originalName", collate = ColumnInfo.NOCASE)
    val originalName: String,
    val newName: String
)-e 


---------- Instrumented Test Files (UI Tests) ----------
================== FILE: ./app/src/androidTest/java/io/pm/finlight/TransactionCrudTests.kt ==================
package io.pm.finlight

import android.Manifest
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.rule.GrantPermissionRule
import org.junit.Rule
import org.junit.Test
import org.junit.rules.RuleChain
import org.junit.runner.RunWith
import java.util.UUID

/**
 * Instrumented UI tests for the full CRUD (Create, Read, Update, Delete)
 * lifecycle of a transaction.
 */
@RunWith(AndroidJUnit4::class)
class TransactionCrudTests {
    private val composeTestRule = createAndroidComposeRule<MainActivity>()

    @get:Rule
    val ruleChain: RuleChain =
        RuleChain
            .outerRule(DisableOnboardingRule())
            .around(DisableAppLockRule())
            .around(
                GrantPermissionRule.grant(
                    Manifest.permission.READ_SMS,
                    Manifest.permission.RECEIVE_SMS,
                    Manifest.permission.POST_NOTIFICATIONS,
                ),
            )
            .around(composeTestRule)

    /**
     * A helper function to add a transaction, reducing code duplication in tests.
     * @return The unique description of the created transaction.
     */
    private fun addTransactionForTest(): String {
        val uniqueDescription = "Test Transaction ${UUID.randomUUID()}"

        composeTestRule.waitUntil(timeoutMillis = 10000) {
            composeTestRule.onAllNodesWithText("Monthly Budget").fetchSemanticsNodes().isNotEmpty()
        }
        composeTestRule.onNodeWithContentDescription("Add").performClick()

        // Wait for AddTransactionScreen to appear and fill the form
        composeTestRule.waitUntil(timeoutMillis = 5000) {
            composeTestRule.onAllNodesWithTag("description_input").fetchSemanticsNodes().isNotEmpty()
        }
        // --- FIX: Use onNodeWithTag to reliably find the text field ---
        composeTestRule.onNodeWithTag("description_input").performTextInput(uniqueDescription)
        composeTestRule.onNodeWithText("0.00").performTextInput("100.0")
        composeTestRule.onNodeWithText("Select account").performClick()
        composeTestRule.onNodeWithText("SBI").performClick()
        composeTestRule.onNodeWithText("Select category").performClick()
        composeTestRule.onNodeWithText("Food & Drinks").performClick()
        composeTestRule.onNodeWithText("Save").performClick()

        // Wait to return to the dashboard and confirm the new item is there.
        composeTestRule.waitUntil(timeoutMillis = 5000) {
            composeTestRule.onAllNodesWithText(uniqueDescription).fetchSemanticsNodes().isNotEmpty()
        }
        return uniqueDescription
    }

    /**
     * Tests that a newly created transaction appears on the dashboard.
     */
    @Test
    fun test_createTransaction_appearsOnDashboard() {
        val description = addTransactionForTest()
        composeTestRule.onNodeWithText(description, useUnmergedTree = true)
            .performScrollTo()
            .assertIsDisplayed()
    }

    /**
     * Tests that a transaction can be successfully edited and the update
     * is reflected on the dashboard.
     */
    @Test
    fun test_editTransaction_updatesSuccessfully() {
        val originalDescription = addTransactionForTest()
        val updatedDescription = "Updated UI Test Dinner"

        // 1. Find the transaction on the dashboard and click to open the detail screen.
        composeTestRule.onNodeWithText(originalDescription, useUnmergedTree = true)
            .performScrollTo()
            .performClick()

        // 2. On the detail screen, wait for it to load, then click the description to open the bottom sheet.
        composeTestRule.waitUntil(timeoutMillis = 5000) {
            composeTestRule.onAllNodesWithText(originalDescription).fetchSemanticsNodes().isNotEmpty()
        }
        composeTestRule.onNodeWithText(originalDescription).performClick()

        // 3. In the bottom sheet, edit the text field and save.
        // --- FIX: Use onNodeWithTag to reliably find the text field ---
        composeTestRule.onNodeWithTag("value_input").performTextClearance()
        composeTestRule.onNodeWithTag("value_input").performTextInput(updatedDescription)
        composeTestRule.onNodeWithText("Save").performClick()


        // 4. Verify the description is updated on the detail screen.
        composeTestRule.onNodeWithText(updatedDescription).assertIsDisplayed()

        // 5. Navigate back to the dashboard.
        composeTestRule.onNodeWithContentDescription("Back").performClick()

        // 6. Assert that the old description is gone and the new one is displayed on the dashboard.
        composeTestRule.waitUntil(timeoutMillis = 5000) {
            composeTestRule.onAllNodesWithText("Monthly Budget").fetchSemanticsNodes().isNotEmpty()
        }
        composeTestRule.onNodeWithText(originalDescription).assertDoesNotExist()
        composeTestRule.onNodeWithText(updatedDescription, useUnmergedTree = true)
            .performScrollTo()
            .assertIsDisplayed()
    }

    /**
     * Tests that a transaction can be successfully deleted from the detail screen.
     */
    @Test
    fun test_deleteTransaction_removesFromList() {
        val description = addTransactionForTest()

        // 1. Find the transaction on the dashboard and click to open the detail screen.
        composeTestRule.onNodeWithText(description, useUnmergedTree = true)
            .performScrollTo()
            .performClick()

        // 2. On the detail screen, click the 'More' menu icon.
        composeTestRule.waitUntil(timeoutMillis = 5000) {
            composeTestRule.onAllNodesWithContentDescription("More options").fetchSemanticsNodes().isNotEmpty()
        }
        composeTestRule.onNodeWithContentDescription("More options").performClick()

        // 3. Click the 'Delete' option in the dropdown menu.
        composeTestRule.onNodeWithText("Delete").performClick()

        // 4. Confirm the deletion in the dialog.
        composeTestRule.onNodeWithText("Delete Transaction?").assertIsDisplayed()
        composeTestRule.onNodeWithText("Delete").performClick()

        // 5. Wait to navigate back to the dashboard and assert the item is gone.
        composeTestRule.waitUntil(timeoutMillis = 5000) {
            composeTestRule.onAllNodesWithText("Monthly Budget").fetchSemanticsNodes().isNotEmpty()
        }
        composeTestRule.onNodeWithText(description).assertDoesNotExist()
    }
}
-e 


================== FILE: ./app/src/androidTest/java/io/pm/finlight/TestRules.kt ==================
package io.pm.finlight

import android.content.Context
import androidx.test.platform.app.InstrumentationRegistry
import org.junit.rules.TestRule
import org.junit.runner.Description
import org.junit.runners.model.Statement

/**
 * A custom JUnit Rule to disable the onboarding screen before a test runs.
 * This rule accesses the app's SharedPreferences and sets the flag to true,
 * ensuring the onboarding flow does not interfere with UI tests.
 */
class DisableOnboardingRule : TestRule {
    override fun apply(base: Statement, description: Description): Statement {
        return object : Statement() {
            override fun evaluate() {
                try {
                    val context = InstrumentationRegistry.getInstrumentation().targetContext
                    val prefs = context.getSharedPreferences("finance_app_settings", Context.MODE_PRIVATE)
                    prefs.edit().putBoolean("has_seen_onboarding", true).commit()
                    base.evaluate()
                } finally {
                    // Cleanup not needed
                }
            }
        }
    }
}

/**
 * A custom JUnit Rule to disable the app lock feature before a test runs.
 * This rule accesses the app's SharedPreferences and sets the app lock flag to false,
 * ensuring the lock screen does not interfere with UI tests.
 */
class DisableAppLockRule : TestRule {
    override fun apply(base: Statement, description: Description): Statement {
        return object : Statement() {
            override fun evaluate() {
                try {
                    val context = InstrumentationRegistry.getInstrumentation().targetContext
                    val prefs = context.getSharedPreferences("finance_app_settings", Context.MODE_PRIVATE)
                    prefs.edit().putBoolean("app_lock_enabled", false).commit()
                    base.evaluate()
                } finally {
                    // Cleanup not needed
                }
            }
        }
    }
}
-e 


================== FILE: ./app/src/androidTest/java/io/pm/finlight/DashboardAndReportsWorkflowTests.kt ==================
package io.pm.finlight

import android.Manifest
import androidx.compose.ui.semantics.SemanticsProperties
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.rule.GrantPermissionRule
import org.junit.Rule
import org.junit.Test
import org.junit.rules.RuleChain
import org.junit.runner.RunWith
import java.text.SimpleDateFormat
import java.util.*

/**
 * Instrumented UI tests for the "Project Aurora" dashboard and the new
 * time-period based reporting screens.
 */
@RunWith(AndroidJUnit4::class)
class DashboardAndReportsWorkflowTests {
    private val composeTestRule = createAndroidComposeRule<MainActivity>()

    @get:Rule
    val ruleChain: RuleChain =
        RuleChain
            .outerRule(DisableOnboardingRule())
            .around(DisableAppLockRule())
            .around(
                GrantPermissionRule.grant(
                    Manifest.permission.READ_SMS,
                    Manifest.permission.RECEIVE_SMS,
                    Manifest.permission.POST_NOTIFICATIONS,
                ),
            )
            .around(composeTestRule)

    /**
     * Verifies that the main "Project Aurora" dashboard cards are displayed on launch.
     */
    @Test
    fun test_auroraDashboard_displaysAllDefaultCards() {
        // Wait for the dashboard to load by checking for the hero card's title.
        composeTestRule.waitUntil(timeoutMillis = 10000) {
            composeTestRule.onAllNodesWithText("Monthly Budget").fetchSemanticsNodes().isNotEmpty()
        }

        // --- FIX: Create a list of expected content and scroll to each one individually ---
        // This is more robust than a single swipe, as it ensures each item is found
        // before the test proceeds.
        val expectedCardContent = listOf(
            "Monthly Budget",
            "View Trends", // Content from Quick Actions card
            "Net Worth",
            "Recent Transactions",
            "Accounts",
            "Budget Watch"
        )

        // Find the scrollable container using its test tag.
        val lazyColumn = composeTestRule.onNodeWithTag("dashboard_lazy_column")

        // Iterate through the expected content, scrolling to and verifying each one.
        expectedCardContent.forEach { contentText ->
            lazyColumn.performScrollToNode(hasText(contentText))
            composeTestRule.onNodeWithText(contentText).assertIsDisplayed()
        }
    }

    /**
     * Tests navigation from the main reports screen to the Daily Report screen
     * and verifies the header content.
     */
    @Test
    fun test_navigationToDailyReport_showsCorrectHeader() {
        // 1. Navigate from the dashboard to the Reports screen via the bottom nav.
        composeTestRule.onNodeWithText("Reports").performClick()

        // 2. On the reports screen, click the "Daily Report" card.
        composeTestRule.onNodeWithText("Daily Report").performClick()

        // 3. Verify we are on the "Daily Report" screen.
        composeTestRule.onNodeWithText("Daily Report").assertIsDisplayed()

        // 4. Verify the "Hero" card and "Insights" card are displayed.
        // We check for "Total Spent" which is in the hero card.
        composeTestRule.onNodeWithText("Total Spent").assertIsDisplayed()
        // We check for "Change" which is in the insights card.
        composeTestRule.onNodeWithText("Change").assertIsDisplayed()
    }

    /**
     * Tests the swipe gestures on the TimePeriodReportScreen to navigate
     * between different days.
     */
    @Test
    fun test_swipeGestures_onReportScreen_changeDate() {
        // 1. Navigate to the Daily Report screen.
        composeTestRule.onNodeWithText("Reports").performClick()
        composeTestRule.onNodeWithText("Daily Report").performClick()
        composeTestRule.onNodeWithText("Daily Report").assertIsDisplayed()

        // 2. Get the initial date text from the subtitle.
        val initialSubtitleNode = composeTestRule.onNodeWithText("Since", substring = true)
        val initialSubtitleText = initialSubtitleNode.fetchSemanticsNode().config[SemanticsProperties.Text].first().text

        // 3. Perform a swipe left gesture to move to the next day.
        composeTestRule.onRoot().performTouchInput { swipeLeft() }

        // 4. Verify the date in the subtitle has changed.
        val nextSubtitleNode = composeTestRule.onNodeWithText("Since", substring = true)
        val nextSubtitleText = nextSubtitleNode.fetchSemanticsNode().config[SemanticsProperties.Text].first().text
        assert(initialSubtitleText != nextSubtitleText) { "Date should have changed after swiping left." }


        // 5. Perform a swipe right gesture to move back to the previous day.
        composeTestRule.onRoot().performTouchInput { swipeRight() }

        // 6. Verify the date has returned to the initial date.
        val finalSubtitleNode = composeTestRule.onNodeWithText("Since", substring = true)
        val finalSubtitleText = finalSubtitleNode.fetchSemanticsNode().config[SemanticsProperties.Text].first().text
        assert(initialSubtitleText == finalSubtitleText) { "Date should have returned to the original after swiping right." }
    }
}
-e 


================== FILE: ./app/src/androidTest/java/io/pm/finlight/AppWorkflowTests.kt ==================
package io.pm.finlight

import android.Manifest
import android.content.Context
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.rule.GrantPermissionRule
import org.junit.Rule
import org.junit.Test
import org.junit.rules.RuleChain
import org.junit.rules.TestRule
import org.junit.runner.Description
import org.junit.runner.RunWith
import org.junit.runners.model.Statement
import java.util.UUID


/**
 * Instrumented UI test for common user workflows in the application.
 *
 * NOTE: This file has been updated to include a custom TestRule to bypass the
 * onboarding screen, ensuring tests start in a consistent state.
 */
@RunWith(AndroidJUnit4::class)
class AppWorkflowTests {
    private val composeTestRule = createAndroidComposeRule<MainActivity>()

    @get:Rule
    val ruleChain: RuleChain =
        RuleChain
            // --- NEW: This rule runs first to bypass the onboarding screen ---
            .outerRule(DisableOnboardingRule())
            .around(DisableAppLockRule())
            .around(
                GrantPermissionRule.grant(
                    Manifest.permission.READ_SMS,
                    Manifest.permission.RECEIVE_SMS,
                    Manifest.permission.POST_NOTIFICATIONS,
                ),
            )
            .around(composeTestRule)

    /**
     * Tests the "happy path" workflow of adding a new transaction and verifying
     * it appears on the dashboard.
     */
    @Test
    fun test_addNewTransaction_appearsOnDashboard() {
        val uniqueDescription = "Test Coffee Purchase ${UUID.randomUUID()}"

        // 1. Wait until the dashboard is fully loaded by checking for a stable element.
        composeTestRule.waitUntil(timeoutMillis = 10000) {
            composeTestRule.onAllNodesWithText("Monthly Budget").fetchSemanticsNodes().isNotEmpty()
        }

        // 2. Click the main FAB to add a new item.
        composeTestRule.onNodeWithContentDescription("Add").performClick()

        // 3. Verify we are on the "Add Transaction" screen and fill out the form.
        composeTestRule.onNodeWithText("Add Transaction").assertIsDisplayed()
        composeTestRule.onNodeWithText("Description").performTextInput(uniqueDescription)
        composeTestRule.onNodeWithText("Amount").performTextInput("150.0")
        composeTestRule.onNodeWithText("Select Account").performClick()
        composeTestRule.onNodeWithText("SBI").performClick()
        composeTestRule.onNodeWithText("Select Category").performClick()
        composeTestRule.onNodeWithText("Food").performClick()

        // 4. Save the transaction.
        composeTestRule.onNodeWithText("Save Transaction").performClick()

        // --- Wait for navigation back to the dashboard to complete ---
        composeTestRule.waitUntil(timeoutMillis = 5000) {
            composeTestRule.onAllNodesWithText("Monthly Budget").fetchSemanticsNodes().isNotEmpty()
        }

        // 5. Verify the new transaction appears in the "Recent Transactions" list.
        val newNode = composeTestRule.onNodeWithText(uniqueDescription, useUnmergedTree = true)
        newNode.performScrollTo()
        newNode.assertIsDisplayed()
    }

    /**
     * Tests the "sad path" workflow where a user tries to save a transaction
     * with invalid input (e.g., non-numeric amount) and sees an error.
     */
    @Test
    fun test_addTransaction_failsWithInvalidAmount_showsValidationError() {
        // 1. Wait for the dashboard and navigate to the Add Transaction Screen.
        composeTestRule.waitUntil(timeoutMillis = 10000) {
            composeTestRule.onAllNodesWithText("Monthly Budget").fetchSemanticsNodes().isNotEmpty()
        }
        composeTestRule.onNodeWithContentDescription("Add").performClick()

        // 2. Fill out the form, but with an invalid (non-numeric) amount.
        composeTestRule.onNodeWithText("Add Transaction").assertIsDisplayed()
        composeTestRule.onNodeWithText("Description").performTextInput("Test Invalid Amount")
        composeTestRule.onNodeWithText("Amount").performTextInput("not-a-number")
        composeTestRule.onNodeWithText("Select Account").performClick()
        composeTestRule.onNodeWithText("SBI").performClick()
        composeTestRule.onNodeWithText("Select Category").performClick()
        composeTestRule.onNodeWithText("Food").performClick()

        // 3. Attempt to save the invalid transaction.
        composeTestRule.onNodeWithText("Save Transaction").performClick()

        // 4. Verify the validation error.
        composeTestRule.onNodeWithText("Add Transaction").assertIsDisplayed()
        val expectedError = "Please enter a valid, positive amount."
        composeTestRule.onNodeWithText(expectedError).assertIsDisplayed()
    }
}
-e 


---------- Unit Test Files ----------
================== FILE: ./app/src/test/java/io/pm/finlight/DashboardViewModelTest.kt ==================
package io.pm.finlight

import android.app.Application
import android.os.Build
import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.test.*
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.annotation.Config
import java.util.Calendar

@ExperimentalCoroutinesApi
@RunWith(AndroidJUnit4::class)
@Config(sdk = [Build.VERSION_CODES.UPSIDE_DOWN_CAKE]) // UPSIDE_DOWN_CAKE is API 34
class DashboardViewModelTest {
    @get:Rule
    var instantTaskExecutorRule = InstantTaskExecutorRule()

    private val testDispatcher = UnconfinedTestDispatcher()

    private lateinit var database: AppDatabase
    private lateinit var viewModel: DashboardViewModel
    private lateinit var settingsRepository: SettingsRepository
    private lateinit var transactionRepository: TransactionRepository
    private lateinit var accountRepository: AccountRepository
    private lateinit var budgetDao: BudgetDao

    @Before
    fun setup() {
        Dispatchers.setMain(testDispatcher)

        val context = ApplicationProvider.getApplicationContext<Application>()

        database =
            Room.inMemoryDatabaseBuilder(context, AppDatabase::class.java)
                .allowMainThreadQueries()
                .build()

        transactionRepository = TransactionRepository(database.transactionDao())
        accountRepository = AccountRepository(database.accountDao())
        settingsRepository = SettingsRepository(context)
        budgetDao = database.budgetDao()

        viewModel =
            DashboardViewModel(
                transactionRepository = transactionRepository,
                accountRepository = accountRepository,
                budgetDao = budgetDao,
                settingsRepository = settingsRepository,
            )
    }

    @After
    fun tearDown() {
        database.close()
        Dispatchers.resetMain()
    }

    @Test
    fun test_safeToSpend_calculationIsCorrect() =
        runTest {
            // --- ARRANGE ---
            // 1. Set a budget.
            val testBudget = 30000f
            settingsRepository.saveOverallBudgetForCurrentMonth(testBudget)

            // 2. Insert test data directly inside the runTest scope.
            val accountDao = database.accountDao()
            val categoryDao = database.categoryDao()
            val transactionDao = database.transactionDao()

            accountDao.insert(Account(id = 1, name = "Test Bank", type = "Savings"))
            categoryDao.insert(Category(id = 1, name = "Food"))

            val calendar = Calendar.getInstance()
            transactionDao.insert(
                Transaction(
                    description = "Groceries",
                    amount = 2500.0,
                    date = calendar.timeInMillis,
                    accountId = 1,
                    categoryId = 1,
                    transactionType = "expense",
                    notes = "",
                ),
            )

            // --- ACT ---
            advanceUntilIdle() // Ensure all initial jobs in ViewModel are complete.
            val safeToSpend = viewModel.safeToSpendPerDay.first()

            // --- ASSERT ---
            val monthlyExpenses = viewModel.monthlyExpenses.first()
            val remainingBudget = testBudget - monthlyExpenses.toFloat()

            val lastDayOfMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH)
            val currentDay = calendar.get(Calendar.DAY_OF_MONTH)
            val remainingDays = (lastDayOfMonth - currentDay + 1).coerceAtLeast(1)

            val expectedSafeToSpend = if (remainingBudget > 0) remainingBudget / remainingDays else 0f

            assertEquals("Safe to spend calculation is incorrect", expectedSafeToSpend, safeToSpend, 0.01f)
        }
}
-e 


================== FILE: ./app/src/test/java/io/pm/finlight/ExampleUnitTest.kt ==================
package io.pm.finlight

import org.junit.Assert.*
import org.junit.Test

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}
-e 


================== FILE: ./app/src/test/java/io/pm/finlight/SmsParserTest.kt ==================
// =================================================================================
// FILE: ./app/src/test/java/io/pm/finlight/SmsParserTest.kt
// REASON: BUG FIX - The test setup has been updated to mock the new
// `MerchantCategoryMappingDao` dependency. All calls to `SmsParser.parse`
// throughout the test file have been updated to pass this new mock, resolving
// all compilation errors.
// =================================================================================
package io.pm.finlight

import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.runBlocking
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.junit.MockitoJUnitRunner

@RunWith(MockitoJUnitRunner::class)
class SmsParserTest {

    @Mock
    private lateinit var mockCustomSmsRuleDao: CustomSmsRuleDao

    @Mock
    private lateinit var mockMerchantRenameRuleDao: MerchantRenameRuleDao

    @Mock
    private lateinit var mockIgnoreRuleDao: IgnoreRuleDao

    // --- NEW: Mock for the new dependency ---
    @Mock
    private lateinit var mockMerchantCategoryMappingDao: MerchantCategoryMappingDao

    private val emptyMappings = emptyMap<String, String>()

    @Before
    fun setUp() {
        // No need to mock AppDatabase anymore
    }

    private suspend fun setupTest(
        customRules: List<CustomSmsRule> = emptyList(),
        renameRules: List<MerchantRenameRule> = emptyList(),
        ignoreRules: List<IgnoreRule> = emptyList()
    ) {
        `when`(mockCustomSmsRuleDao.getAllRules()).thenReturn(flowOf(customRules))
        `when`(mockMerchantRenameRuleDao.getAllRules()).thenReturn(flowOf(renameRules))
        // --- UPDATED: Mock the enabled phrases for the ignore rule dao ---
        `when`(mockIgnoreRuleDao.getEnabledPhrases()).thenReturn(ignoreRules.filter { it.isEnabled }.map { it.phrase })
    }

    @Test
    fun `test parses debit message successfully`() = runBlocking {
        setupTest()
        val smsBody = "Your account with HDFC Bank has been debited for Rs. 750.50 at Amazon on 22-Jun-2025."
        val mockSms = SmsMessage(id = 1L, sender = "AM-HDFCBK", body = smsBody, date = System.currentTimeMillis())

        val result = SmsParser.parse(mockSms, emptyMappings, mockCustomSmsRuleDao, mockMerchantRenameRuleDao, mockIgnoreRuleDao, mockMerchantCategoryMappingDao)

        assertNotNull("Parser should return a result for a debit message", result)
        assertEquals(750.50, result?.amount)
        assertEquals("expense", result?.transactionType)
        assertEquals("Amazon", result?.merchantName)
    }

    @Test
    fun `test parses credit message successfully`() = runBlocking {
        setupTest()
        val smsBody = "You have received a credit of INR 5,000.00 from Freelance Client."
        val mockSms = SmsMessage(id = 2L, sender = "DM-SOMEBK", body = smsBody, date = System.currentTimeMillis())

        val result = SmsParser.parse(mockSms, emptyMappings, mockCustomSmsRuleDao, mockMerchantRenameRuleDao, mockIgnoreRuleDao, mockMerchantCategoryMappingDao)

        assertNotNull("Parser should return a result for a credit message", result)
        assertEquals(5000.00, result?.amount)
        assertEquals("income", result?.transactionType)
        assertEquals("Freelance Client", result?.merchantName)
    }

    @Test
    fun `test returns null for non-financial message`() = runBlocking {
        setupTest()
        val smsBody = "Hello, just checking in. Are we still on for dinner tomorrow evening?"
        val mockSms = SmsMessage(id = 3L, sender = "+1234567890", body = smsBody, date = System.currentTimeMillis())

        val result = SmsParser.parse(mockSms, emptyMappings, mockCustomSmsRuleDao, mockMerchantRenameRuleDao, mockIgnoreRuleDao, mockMerchantCategoryMappingDao)

        assertNull("Parser should return null for a non-financial message", result)
    }

    @Test
    fun `test parses SBI Credit Card message`() = runBlocking {
        setupTest()
        val smsBody = "Rs.267.00 spent on your SBI Credit Card ending with 3201 at HALLI THOTA on 29-06-25 via UPI (Ref No. 1231230123). Trxn. Not done by you? Report at [https://sbicards.com/Dispute](https://sbicards.com/Dispute))"
        val mockSms = SmsMessage(id = 4L, sender = "VM-SBICRD", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings, mockCustomSmsRuleDao, mockMerchantRenameRuleDao, mockIgnoreRuleDao, mockMerchantCategoryMappingDao)

        assertNotNull(result)
        assertEquals(267.00, result?.amount)
        assertEquals("expense", result?.transactionType)
        assertEquals("HALLI THOTA", result?.merchantName)
        assertNotNull(result?.potentialAccount)
        assertEquals("SBI - xx3201", result?.potentialAccount?.formattedName)
        assertEquals("Credit Card", result?.potentialAccount?.accountType)
    }

    @Test
    fun `test parses ICICI debit message`() = runBlocking {
        setupTest()
        val smsBody = "ICICI Bank Acct XX823 debited for Rs 240.00 on 21-Jun-25; DAKSHIN CAFE credited. UPI: 552200221100. Call 18002661 for dispute."
        val mockSms = SmsMessage(id = 5L, sender = "DM-ICIBNK", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings, mockCustomSmsRuleDao, mockMerchantRenameRuleDao, mockIgnoreRuleDao, mockMerchantCategoryMappingDao)

        assertNotNull(result)
        assertEquals(240.00, result?.amount)
        assertEquals("expense", result?.transactionType)
        assertEquals("DAKSHIN CAFE", result?.merchantName)
        assertNotNull(result?.potentialAccount)
        assertEquals("ICICI Bank - xx823", result?.potentialAccount?.formattedName)
        assertEquals("Savings Account", result?.potentialAccount?.accountType)
    }

    @Test
    fun `test parses HDFC card message`() = runBlocking {
        setupTest()
        val smsBody = "[JD-HDFCBK-S] Spent Rs.388.19 On HDFC Bank Card 9922 At ..MC DONALDS_ on2025-06-22:08:01:24.Not You> To Block+Reissue Call 18002323232/SMS BLOCK CC 9922 to 123098123"
        val mockSms = SmsMessage(id = 6L, sender = "JD-HDFCBK", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings, mockCustomSmsRuleDao, mockMerchantRenameRuleDao, mockIgnoreRuleDao, mockMerchantCategoryMappingDao)

        assertNotNull(result)
        assertEquals(388.19, result?.amount)
        assertEquals("expense", result?.transactionType)
        assertEquals("MC DONALDS", result?.merchantName)
        assertNotNull(result?.potentialAccount)
        assertEquals("HDFC Bank - xx9922", result?.potentialAccount?.formattedName)
        assertEquals("Card", result?.potentialAccount?.accountType)
    }

    @Test
    fun `test parses Pluxee Meal Card message`() = runBlocking {
        setupTest()
        val smsBody = "Rs. 60.00 spent from Pluxee Meal Card wallet, card no.xx1345 on 30-06-2025 18:41:56 at KITCHEN AFF . Avl bal Rs.1824.65. Not you call 18002106919"
        val mockSms = SmsMessage(id = 7L, sender = "VD-PLUXEE", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings, mockCustomSmsRuleDao, mockMerchantRenameRuleDao, mockIgnoreRuleDao, mockMerchantCategoryMappingDao)

        assertNotNull(result)
        assertEquals(60.00, result?.amount)
        assertEquals("expense", result?.transactionType)
        assertEquals("KITCHEN AFF", result?.merchantName)
        assertNotNull(result?.potentialAccount)
        assertEquals("Pluxee - xx1345", result?.potentialAccount?.formattedName)
        assertEquals("Meal Card wallet", result?.potentialAccount?.accountType)
    }

    @Test
    fun `test parses ICICI credit message with tricky format`() = runBlocking {
        setupTest()
        val smsBody = "Dear Customer, Acct XX823 is credited with Rs 6000.00 on 26-Jun-25 from GANGA MANGA. UPI:5577822323232-ICICI Bank"
        val mockSms = SmsMessage(id = 8L, sender = "QP-ICIBNK", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings, mockCustomSmsRuleDao, mockMerchantRenameRuleDao, mockIgnoreRuleDao, mockMerchantCategoryMappingDao)

        assertNotNull(result)
        assertEquals(6000.00, result?.amount)
        assertEquals("income", result?.transactionType)
        assertEquals("GANGA MANGA", result?.merchantName)
        assertNotNull(result?.potentialAccount)
        assertEquals("ICICI Bank - xx823", result?.potentialAccount?.formattedName)
        assertEquals("Savings Account", result?.potentialAccount?.accountType)
    }

    @Test
    fun `test ignores successful payment confirmation`() = runBlocking {
        setupTest(ignoreRules = listOf(IgnoreRule(phrase = "payment of.*is successful", isEnabled = true)))
        val smsBody = "Your payment of Rs.330.80 for A4-108 against Water Charges is successful. Regards NoBrokerHood"
        val mockSms = SmsMessage(id = 10L, sender = "VM-NBHOOD", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings, mockCustomSmsRuleDao, mockMerchantRenameRuleDao, mockIgnoreRuleDao, mockMerchantCategoryMappingDao)
        assertNull("Parser should ignore successful payment confirmations", result)
    }

    @Test
    fun `test parses ICICI NEFT credit message`() = runBlocking {
        setupTest()
        val smsBody = "ICICI Bank Account XX823 credited:Rs. 1,133.00 on 01-Jul-25. Info NEFT-HDFCN5202507024345356218-. Available Balance is Rs. 1,858.35."
        val mockSms = SmsMessage(id = 11L, sender = "VM-ICIBNK", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings, mockCustomSmsRuleDao, mockMerchantRenameRuleDao, mockIgnoreRuleDao, mockMerchantCategoryMappingDao)

        assertNotNull(result)
        assertEquals(1133.00, result?.amount)
        assertEquals("income", result?.transactionType)
        assertEquals("NEFT-HDFCN5202507024345356218-", result?.merchantName)
        assertNotNull(result?.potentialAccount)
        assertEquals("ICICI Bank - xx823", result?.potentialAccount?.formattedName)
        assertEquals("Bank Account", result?.potentialAccount?.accountType)
    }

    @Test
    fun `test ignores HDFC NEFT credit message`() = runBlocking {
        setupTest(ignoreRules = listOf(IgnoreRule(phrase = "has been credited to", isEnabled = true)))
        val smsBody = "HDFC Bank : NEFT money transfer Txn No HDFCN520253454560344 for Rs INR 1,500.00 has been credited to Manga Penga on 01-07-2025 at 08:05:30"
        val mockSms = SmsMessage(id = 12L, sender = "VM-HDFCBK", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings, mockCustomSmsRuleDao, mockMerchantRenameRuleDao, mockIgnoreRuleDao, mockMerchantCategoryMappingDao)
        assertNull("Parser should ignore has been credited to messages", result)
    }

    @Test
    fun `test ignores credit card payment confirmation`() = runBlocking {
        setupTest(ignoreRules = listOf(IgnoreRule(phrase = "payment of.*has been received towards", isEnabled = true)))
        val smsBody = "Payment of INR 1180.01 has been received towards your SBI card XX1121"
        val mockSms = SmsMessage(id = 13L, sender = "DM-SBICRD", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings, mockCustomSmsRuleDao, mockMerchantRenameRuleDao, mockIgnoreRuleDao, mockMerchantCategoryMappingDao)
        assertNull("Parser should ignore credit card payment confirmations", result)
    }

    @Test
    fun `test ignores bharat bill pay confirmation`() = runBlocking {
        setupTest(ignoreRules = listOf(IgnoreRule(phrase = "Payment of.*has been received on your.*Credit Card", isEnabled = true)))
        val smsBody = "Payment of Rs 356.33 has been received on your ICICI Bank Credit Card XX2529 through Bharat Bill Payment System on 03-JUL-25."
        val mockSms = SmsMessage(id = 14L, sender = "DM-ICIBNK", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings, mockCustomSmsRuleDao, mockMerchantRenameRuleDao, mockIgnoreRuleDao, mockMerchantCategoryMappingDao)
        assertNull("Parser should ignore Bharat Bill Pay confirmations", result)
    }

    @Test
    fun `test ignores message with user-defined ignore phrase`() = runBlocking {
        val ignoreRules = listOf(IgnoreRule(id = 1, phrase = "invoice of", isEnabled = true))
        setupTest(ignoreRules = ignoreRules)
        val smsBody = "An Invoice of Rs.330.8 for A4 Block-108 is raised."
        val mockSms = SmsMessage(id = 9L, sender = "VM-NBHOOD", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings, mockCustomSmsRuleDao, mockMerchantRenameRuleDao, mockIgnoreRuleDao, mockMerchantCategoryMappingDao)
        assertNull("Parser should ignore messages with user-defined phrases", result)
    }
}-e 


