Project Context for Personal Finance App
Generated on: Tue Jul  1 13:33:30 IST 2025
========================================

================== FILE: ./app/build.gradle.kts ==================
import java.util.Properties
import java.io.FileInputStream

// It's good practice to define versions in one place.
val roomVersion = "2.6.1"
val lifecycleVersion = "2.8.2"
val activityComposeVersion = "1.9.0"
val coreKtxVersion = "1.13.1"
val navigationVersion = "2.7.7"
val androidxTestVersion = "1.6.1"
val testExtJunitVersion = "1.2.1"
val espressoVersion = "3.6.1"
val tracingVersion = "1.2.0"
val workVersion = "2.9.0"
val robolectricVersion = "4.13"
val coroutinesTestVersion = "1.8.1"
val gsonVersion = "2.10.1"
val coilVersion = "2.6.0"
// --- NEW: Add Image Cropper library version ---
val imageCropperVersion = "4.5.0"

// Read properties from local.properties
val keystorePropertiesFile = rootProject.file("local.properties")
val keystoreProperties = Properties()
if (keystorePropertiesFile.exists()) {
    keystoreProperties.load(FileInputStream(keystorePropertiesFile))
}


plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("com.google.devtools.ksp")
    id("org.jetbrains.kotlin.plugin.compose")
    id("org.jetbrains.kotlin.plugin.serialization")
    id("org.jlleitschuh.gradle.ktlint") version "12.1.1"
}

android {
    namespace = "io.pm.finlight"
    compileSdk = 35

    signingConfigs {
        create("release") {
            keyAlias = keystoreProperties["key.alias"] as String?
            keyPassword = keystoreProperties["key.password"] as String?
            storeFile = keystoreProperties["keystore.path"]?.let { rootProject.file(it) }
            storePassword = keystoreProperties["keystore.password"] as String?
        }
    }

    defaultConfig {
        applicationId = "io.pm.finlight"
        minSdk = 24
        targetSdk = 35
        versionCode = 1
        versionName = "1.0"
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
        ksp {
            arg("room.schemaLocation", "$projectDir/schemas")
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro",
            )
            signingConfig = signingConfigs.getByName("release")
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = "17"
    }
    buildFeatures {
        compose = true
    }
    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }
    testOptions {
        unitTests {
            isIncludeAndroidResources = true
        }
    }
}

configurations.all {
    resolutionStrategy {
        force("androidx.core:core-ktx:$coreKtxVersion")
        force("androidx.core:core:$coreKtxVersion")
        force("androidx.tracing:tracing-ktx:$tracingVersion")
    }
}

dependencies {
    implementation("androidx.core:core-ktx:$coreKtxVersion")
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:$lifecycleVersion")
    implementation("androidx.activity:activity-compose:$activityComposeVersion")

    implementation(platform("androidx.compose:compose-bom:2024.06.00"))
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-graphics")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")
    implementation("androidx.compose.material:material-icons-extended")
    implementation("androidx.compose.runtime:runtime-livedata")

    implementation("androidx.room:room-runtime:$roomVersion")
    implementation("androidx.room:room-ktx:$roomVersion")
    implementation("androidx.appcompat:appcompat:1.7.1")
    implementation("com.google.firebase:firebase-crashlytics-buildtools:3.0.4")
    ksp("androidx.room:room-compiler:$roomVersion")

    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:$lifecycleVersion")
    implementation("androidx.navigation:navigation-compose:$navigationVersion")

    implementation("com.google.android.material:material:1.12.0")

    implementation("com.github.PhilJay:MPAndroidChart:v3.1.0")

    implementation("com.google.code.gson:gson:$gsonVersion")

    implementation("androidx.tracing:tracing-ktx:$tracingVersion")

    implementation("io.coil-kt:coil-compose:$coilVersion")

    // --- NEW: Add the image cropper dependency ---
    implementation("com.vanniktech:android-image-cropper:$imageCropperVersion")

    // Local unit tests
    testImplementation("junit:junit:4.13.2")
    testImplementation("androidx.test:core-ktx:$androidxTestVersion")
    testImplementation("androidx.test.ext:junit:$testExtJunitVersion")
    testImplementation("org.robolectric:robolectric:$robolectricVersion")
    testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:$coroutinesTestVersion")
    testImplementation("androidx.arch.core:core-testing:2.2.0")

    // Instrumented UI tests
    androidTestImplementation("androidx.tracing:tracing-ktx:$tracingVersion")
    androidTestImplementation("androidx.test:runner:$androidxTestVersion")
    androidTestImplementation("androidx.test:core-ktx:$androidxTestVersion")
    androidTestImplementation("androidx.test.ext:junit-ktx:$testExtJunitVersion")
    androidTestImplementation("androidx.test:rules:$androidxTestVersion")
    androidTestImplementation("androidx.test.espresso:espresso-core:$espressoVersion")
    androidTestImplementation(platform("androidx.compose:compose-bom:2024.06.00"))
    androidTestImplementation("androidx.compose.ui:ui-test-junit4")

    // Debug dependencies
    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")

    implementation("androidx.biometric:biometric:1.2.0-alpha05")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3")
    implementation("androidx.work:work-runtime-ktx:$workVersion")
}



================== FILE: ./app/src/main/AndroidManifest.xml ==================
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-feature
        android:name="android.hardware.telephony"
        android:required="false" />
    <!-- FIX: Explicitly declare that the camera feature is used, but not required. -->
    <uses-feature
        android:name="android.hardware.camera"
        android:required="false" />

    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.READ_SMS" />
    <uses-permission android:name="android.permission.RECEIVE_SMS" />
    <uses-permission android:name="android.permission.USE_BIOMETRIC" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>


    <application
        android:name=".MainApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.PersonalFinanceApp"
        tools:targetApi="33"
        android:enableOnBackInvokedCallback="true">

        <meta-data
            android:name="com.google.firebase.messaging.default_notification_icon"
            android:resource="@drawable/ic_launcher_foreground" />

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:label="@string/app_name"
            android:launchMode="singleTop"
            android:theme="@style/Theme.PersonalFinanceApp">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />
                <data
                    android:host="finlight.pm.io"
                    android:scheme="app" />
            </intent-filter>
        </activity>

        <receiver
            android:name=".SmsReceiver"
            android:exported="true"
            android:permission="android.permission.BROADCAST_SMS">
            <intent-filter android:priority="999">
                <action android:name="android.provider.Telephony.SMS_RECEIVED" />
            </intent-filter>
        </receiver>

        <activity
            android:name="com.canhub.cropper.CropImageActivity"
            android:theme="@style/Theme.AppCompat.DayNight"
            />

        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.provider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_paths" />
        </provider>

    </application>

</manifest>



---------- Main Source Files ----------
================== FILE: ./app/src/main/java/DashboardViewModelFactory.kt ==================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider

/**
 * Factory for creating a DashboardViewModel with a constructor that takes dependencies.
 */
class DashboardViewModelFactory(private val application: Application) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(DashboardViewModel::class.java)) {
            val db = AppDatabase.getInstance(application)
            val transactionRepository = TransactionRepository(db.transactionDao())
            val accountRepository = AccountRepository(db.accountDao())
            val settingsRepository = SettingsRepository(application)

            @Suppress("UNCHECKED_CAST")
            return DashboardViewModel(
                transactionRepository = transactionRepository,
                accountRepository = accountRepository,
                budgetDao = db.budgetDao(),
                settingsRepository = settingsRepository,
            ) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
-e 


================== FILE: ./app/src/main/java/MonthlySummaryItem.kt ==================
package io.pm.finlight

import java.util.Calendar

/**
 * A data class to hold a Calendar instance for a specific month
 * and the total amount spent during that month.
 *
 * @param calendar The Calendar object representing the month.
 * @param totalSpent The total expenses for that month.
 */
data class MonthlySummaryItem(val calendar: Calendar, val totalSpent: Double)
-e 


================== FILE: ./app/src/main/java/DataExportService.kt ==================
package io.pm.finlight

import android.content.Context
import android.net.Uri
import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.withContext
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import java.text.SimpleDateFormat
import java.util.*

object DataExportService {
    private val json =
        Json {
            prettyPrint = true
            isLenient = true
            ignoreUnknownKeys = true
        }

    suspend fun exportToJsonString(context: Context): String? {
        return withContext(Dispatchers.IO) {
            try {
                val db = AppDatabase.getInstance(context)

                val backupData =
                    AppDataBackup(
                        transactions = db.transactionDao().getAllTransactionsSimple().first(),
                        accounts = db.accountDao().getAllAccounts().first(),
                        categories = db.categoryDao().getAllCategories().first(),
                        budgets = db.budgetDao().getAllBudgets().first(),
                        merchantMappings = db.merchantMappingDao().getAllMappings().first(),
                    )

                json.encodeToString(backupData)
            } catch (e: Exception) {
                Log.e("DataExportService", "Error exporting to JSON", e)
                null
            }
        }
    }

    suspend fun importDataFromJson(
        context: Context,
        uri: Uri,
    ): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                val jsonString = context.contentResolver.openInputStream(uri)?.bufferedReader().use { it?.readText() }
                if (jsonString == null) return@withContext false

                val backupData = json.decodeFromString<AppDataBackup>(jsonString)

                val db = AppDatabase.getInstance(context)
                val transactionDao = db.transactionDao()
                val accountDao = db.accountDao()
                val categoryDao = db.categoryDao()
                val budgetDao = db.budgetDao()
                val merchantMappingDao = db.merchantMappingDao()

                transactionDao.deleteAll()
                accountDao.deleteAll()
                categoryDao.deleteAll()
                budgetDao.deleteAll()
                merchantMappingDao.deleteAll()

                accountDao.insertAll(backupData.accounts)
                categoryDao.insertAll(backupData.categories)
                budgetDao.insertAll(backupData.budgets)
                merchantMappingDao.insertAll(backupData.merchantMappings)
                transactionDao.insertAll(backupData.transactions)

                true
            } catch (e: Exception) {
                Log.e("DataExportService", "Error importing from JSON", e)
                false
            }
        }
    }

    suspend fun exportToCsvString(context: Context): String? {
        return withContext(Dispatchers.IO) {
            try {
                val db = AppDatabase.getInstance(context)
                val transactions = db.transactionDao().getAllTransactions().first()
                val csvBuilder = StringBuilder()

                csvBuilder.append("Date,Description,Amount,Type,Category,Account,Notes\n")

                val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())

                transactions.forEach { details ->
                    val date = dateFormat.format(Date(details.transaction.date))
                    val description = escapeCsvField(details.transaction.description)
                    val amount = details.transaction.amount.toString()
                    val type = details.transaction.transactionType
                    val category = escapeCsvField(details.categoryName ?: "N/A")
                    val account = escapeCsvField(details.accountName ?: "N/A")
                    val notes = escapeCsvField(details.transaction.notes ?: "")

                    csvBuilder.append("$date,$description,$amount,$type,$category,$account,$notes\n")
                }
                csvBuilder.toString()
            } catch (e: Exception) {
                Log.e("DataExportService", "Error exporting to CSV", e)
                null
            }
        }
    }

    suspend fun importFromCsv(
        context: Context,
        uri: Uri,
    ): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                val db = AppDatabase.getInstance(context)
                val accountDao = db.accountDao()
                val categoryDao = db.categoryDao()
                val transactionDao = db.transactionDao()

                val newTransactions = mutableListOf<Transaction>()
                val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())

                context.contentResolver.openInputStream(uri)?.bufferedReader()?.useLines { lines ->
                    // Use .iterator() to avoid issues with concurrent modification
                    val lineIterator = lines.iterator()
                    // Skip header row
                    if (lineIterator.hasNext()) {
                        lineIterator.next()
                    }

                    while (lineIterator.hasNext()) {
                        val line = lineIterator.next()
                        val tokens =
                            line.split(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)".toRegex())
                                .map { it.trim().removeSurrounding("\"") }

                        if (tokens.size >= 6) {
                            val date = dateFormat.parse(tokens[0])?.time ?: System.currentTimeMillis()
                            val description = tokens[1]
                            val amount = tokens[2].toDoubleOrNull() ?: 0.0
                            val type = tokens[3]
                            val categoryName = tokens[4]
                            val accountName = tokens[5]
                            val notes = if (tokens.size > 6) tokens[6] else null

                            var category: Category? = categoryDao.findByName(categoryName)
                            if (category == null && categoryName.isNotBlank()) {
                                categoryDao.insert(Category(name = categoryName))
                                category = categoryDao.findByName(categoryName) // Query again to get the object with the ID
                            }

                            var account: Account? = accountDao.findByName(accountName)
                            if (account == null && accountName.isNotBlank()) {
                                accountDao.insert(Account(name = accountName, type = "Imported"))
                                account = accountDao.findByName(accountName) // Query again to get the object with the ID
                            }

                            // Ensure account and category were successfully found or created before adding transaction
                            if (account != null && category != null) {
                                newTransactions.add(
                                    Transaction(
                                        description = description,
                                        amount = amount,
                                        date = date,
                                        transactionType = type,
                                        accountId = account.id,
                                        categoryId = category.id,
                                        notes = notes,
                                    ),
                                )
                            } else {
                                Log.w("DataExportService", "Skipping row due to missing account/category: $line")
                            }
                        }
                    }
                }

                if (newTransactions.isNotEmpty()) {
                    transactionDao.insertAll(newTransactions)
                }
                true
            } catch (e: Exception) {
                Log.e("DataExportService", "Error importing from CSV", e)
                false
            }
        }
    }

    private fun escapeCsvField(field: String): String {
        if (field.contains(",") || field.contains("\"") || field.contains("\n")) {
            return "\"${field.replace("\"", "\"\"")}\""
        }
        return field
    }
}
-e 


================== FILE: ./app/src/main/java/AccountRepository.kt ==================
package io.pm.finlight

import kotlinx.coroutines.flow.Flow

class AccountRepository(private val accountDao: AccountDao) {
    // Expose the new query result to the ViewModel
    val accountsWithBalance: Flow<List<AccountWithBalance>> = accountDao.getAccountsWithBalance()

    val allAccounts: Flow<List<Account>> = accountDao.getAllAccounts()

    fun getAccountById(accountId: Int): Flow<Account?> {
        return accountDao.getAccountById(accountId)
    }

    suspend fun insert(account: Account) {
        accountDao.insert(account)
    }

    suspend fun update(account: Account) {
        accountDao.update(account)
    }

    suspend fun delete(account: Account) {
        accountDao.delete(account)
    }
}
-e 


================== FILE: ./app/src/main/java/BudgetRepository.kt ==================
package io.pm.finlight

import kotlinx.coroutines.flow.Flow

class BudgetRepository(private val budgetDao: BudgetDao) {
    fun getBudgetsForMonth(
        month: Int,
        year: Int,
    ): Flow<List<Budget>> {
        return budgetDao.getBudgetsForMonth(month, year)
    }

    fun getBudgetsForMonthWithSpending(yearMonth: String, month: Int, year: Int): Flow<List<BudgetWithSpending>> {
        return budgetDao.getBudgetsWithSpendingForMonth(yearMonth, month, year)
    }

    fun getActualSpendingForCategory(
        categoryName: String,
        month: Int,
        year: Int,
    ): Flow<Double?> {
        return budgetDao.getActualSpendingForCategory(categoryName, month, year)
    }

    suspend fun update(budget: Budget) {
        budgetDao.update(budget)
    }

    suspend fun insert(budget: Budget) {
        budgetDao.insert(budget)
    }

    suspend fun delete(budget: Budget) {
        budgetDao.delete(budget)
    }

    fun getBudgetById(id: Int): Flow<Budget?> {
        return budgetDao.getById(id)
    }
}
-e 


================== FILE: ./app/src/main/java/TransactionViewModel.kt ==================
package io.pm.finlight

import android.app.Application
import android.net.Uri
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Date
import java.util.Locale

private const val TAG = "TransactionViewModel"

class TransactionViewModel(application: Application) : AndroidViewModel(application) {
    private val transactionRepository: TransactionRepository
    val accountRepository: AccountRepository
    val categoryRepository: CategoryRepository
    private val tagRepository: TagRepository
    private val settingsRepository: SettingsRepository
    private val context = application

    private val db = AppDatabase.getInstance(application)
    private var areTagsLoadedForCurrentTxn = false
    private var currentTxnIdForTags: Int? = null

    // --- State for the currently selected month ---
    private val _selectedMonth = MutableStateFlow(Calendar.getInstance())
    val selectedMonth: StateFlow<Calendar> = _selectedMonth.asStateFlow()

    // --- Flow that provides a list of past months with their total spending ---
    val monthlySummaries: StateFlow<List<MonthlySummaryItem>>

    // --- Flow for category spending in the selected month ---
    @OptIn(ExperimentalCoroutinesApi::class)
    val categorySpendingForSelectedMonth: StateFlow<List<CategorySpending>> = _selectedMonth.flatMapLatest { calendar ->
        val monthStart = (calendar.clone() as Calendar).apply {
            set(Calendar.DAY_OF_MONTH, 1)
            set(Calendar.HOUR_OF_DAY, 0)
            set(Calendar.MINUTE, 0)
            set(Calendar.SECOND, 0)
        }.timeInMillis

        val monthEnd = (calendar.clone() as Calendar).apply {
            add(Calendar.MONTH, 1)
            set(Calendar.DAY_OF_MONTH, 1)
            add(Calendar.DAY_OF_MONTH, -1)
            set(Calendar.HOUR_OF_DAY, 23)
            set(Calendar.MINUTE, 59)
            set(Calendar.SECOND, 59)
        }.timeInMillis

        transactionRepository.getSpendingByCategoryForMonth(monthStart, monthEnd)
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

    // --- Flow for merchant spending in the selected month ---
    @OptIn(ExperimentalCoroutinesApi::class)
    val merchantSpendingForSelectedMonth: StateFlow<List<MerchantSpendingSummary>> = _selectedMonth.flatMapLatest { calendar ->
        val monthStart = (calendar.clone() as Calendar).apply {
            set(Calendar.DAY_OF_MONTH, 1)
            set(Calendar.HOUR_OF_DAY, 0)
            set(Calendar.MINUTE, 0)
            set(Calendar.SECOND, 0)
        }.timeInMillis

        val monthEnd = (calendar.clone() as Calendar).apply {
            add(Calendar.MONTH, 1)
            set(Calendar.DAY_OF_MONTH, 1)
            add(Calendar.DAY_OF_MONTH, -1)
            set(Calendar.HOUR_OF_DAY, 23)
            set(Calendar.MINUTE, 59)
            set(Calendar.SECOND, 59)
        }.timeInMillis

        transactionRepository.getSpendingByMerchantForMonth(monthStart, monthEnd)
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())


    // --- Flow that emits transactions only for the selected month ---
    @OptIn(ExperimentalCoroutinesApi::class)
    val transactionsForSelectedMonth: StateFlow<List<TransactionDetails>> = _selectedMonth.flatMapLatest { calendar ->
        val monthStart = (calendar.clone() as Calendar).apply {
            set(Calendar.DAY_OF_MONTH, 1)
            set(Calendar.HOUR_OF_DAY, 0)
            set(Calendar.MINUTE, 0)
            set(Calendar.SECOND, 0)
        }.timeInMillis

        val monthEnd = (calendar.clone() as Calendar).apply {
            add(Calendar.MONTH, 1)
            set(Calendar.DAY_OF_MONTH, 1)
            add(Calendar.DAY_OF_MONTH, -1)
            set(Calendar.HOUR_OF_DAY, 23)
            set(Calendar.MINUTE, 59)
            set(Calendar.SECOND, 59)
        }.timeInMillis

        transactionRepository.getTransactionDetailsForRange(monthStart, monthEnd)
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

    // --- Flow for total income in the selected month ---
    val monthlyIncome: StateFlow<Double> = transactionsForSelectedMonth.map { txns ->
        txns.filter { it.transaction.transactionType == "income" }.sumOf { it.transaction.amount }
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0.0)

    // --- Flow for total expenses in the selected month ---
    val monthlyExpenses: StateFlow<Double> = transactionsForSelectedMonth.map { txns ->
        txns.filter { it.transaction.transactionType == "expense" }.sumOf { it.transaction.amount }
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0.0)

    // --- Flow for the overall budget in the selected month ---
    @OptIn(ExperimentalCoroutinesApi::class)
    val overallMonthlyBudget: StateFlow<Float> = _selectedMonth.flatMapLatest {
        settingsRepository.getOverallBudgetForMonth(it.get(Calendar.YEAR), it.get(Calendar.MONTH) + 1)
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0f)

    // --- Flow for remaining budget amount ---
    val amountRemaining: StateFlow<Float> =
        combine(overallMonthlyBudget, monthlyExpenses) { budget, expenses ->
            budget - expenses.toFloat()
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0f)

    // --- Flow for the 'Safe to Spend' amount per day ---
    val safeToSpendPerDay: StateFlow<Float> =
        combine(amountRemaining, _selectedMonth) { remaining, calendar ->
            val today = Calendar.getInstance()
            val lastDayOfMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH)

            val remainingDays = if (
                today.get(Calendar.YEAR) == calendar.get(Calendar.YEAR) &&
                today.get(Calendar.MONTH) == calendar.get(Calendar.MONTH)
            ) {
                (lastDayOfMonth - today.get(Calendar.DAY_OF_MONTH) + 1).coerceAtLeast(1)
            } else if (calendar.after(today)) {
                lastDayOfMonth
            } else {
                1
            }

            if (remaining > 0) remaining / remainingDays else 0f
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0f)


    val allTransactions: StateFlow<List<TransactionDetails>>
    val allAccounts: StateFlow<List<Account>>
    val allCategories: Flow<List<Category>>
    val allTags: StateFlow<List<Tag>>

    private val _validationError = MutableStateFlow<String?>(null)
    val validationError = _validationError.asStateFlow()

    private val _selectedTags = MutableStateFlow<Set<Tag>>(emptySet())
    val selectedTags = _selectedTags.asStateFlow()

    private val _transactionImages = MutableStateFlow<List<TransactionImage>>(emptyList())
    val transactionImages: StateFlow<List<TransactionImage>> = _transactionImages.asStateFlow()

    init {
        transactionRepository = TransactionRepository(db.transactionDao())
        accountRepository = AccountRepository(db.accountDao())
        categoryRepository = CategoryRepository(db.categoryDao())
        tagRepository = TagRepository(db.tagDao(), db.transactionDao())
        settingsRepository = SettingsRepository(application)

        allTransactions = transactionRepository.allTransactions.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )

        allAccounts = accountRepository.allAccounts.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )

        allCategories = categoryRepository.allCategories

        allTags = tagRepository.allTags.onEach {
            Log.d(TAG, "allTags flow collected new data. Count: ${it.size}")
        }.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )

        // --- NEW: Calculate monthly summaries ---
        val twelveMonthsAgo = Calendar.getInstance().apply { add(Calendar.YEAR, -1) }.timeInMillis
        monthlySummaries = transactionRepository.getMonthlyTrends(twelveMonthsAgo)
            .map { trends ->
                val dateFormat = SimpleDateFormat("yyyy-MM", Locale.getDefault())
                val monthMap = trends.associate {
                    val cal = Calendar.getInstance().apply {
                        time = dateFormat.parse(it.monthYear) ?: Date()
                    }
                    (cal.get(Calendar.YEAR) * 100 + cal.get(Calendar.MONTH)) to it.totalExpenses
                }

                (0..11).map { i ->
                    val cal = Calendar.getInstance().apply { add(Calendar.MONTH, -i) }
                    val key = cal.get(Calendar.YEAR) * 100 + cal.get(Calendar.MONTH)
                    val spent = monthMap[key] ?: 0.0
                    MonthlySummaryItem(calendar = cal, totalSpent = spent)
                }.reversed()
            }
            .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())
    }

    // --- REFACTORED: Function to set the selected month directly ---
    fun setSelectedMonth(calendar: Calendar) {
        _selectedMonth.value = calendar
    }


    fun attachPhotoToTransaction(transactionId: Int, sourceUri: Uri) {
        viewModelScope.launch {
            val localPath = saveImageToInternalStorage(sourceUri)
            if (localPath != null) {
                transactionRepository.addImageToTransaction(transactionId, localPath)
            }
        }
    }

    fun deleteTransactionImage(image: TransactionImage) {
        viewModelScope.launch {
            transactionRepository.deleteImage(image)
            withContext(Dispatchers.IO) {
                try {
                    File(image.imageUri).delete()
                } catch (e: Exception) {
                    Log.e(TAG, "Failed to delete image file: ${image.imageUri}", e)
                }
            }
        }
    }

    fun loadImagesForTransaction(transactionId: Int) {
        viewModelScope.launch {
            transactionRepository.getImagesForTransaction(transactionId).collect {
                _transactionImages.value = it
            }
        }
    }


    private suspend fun saveImageToInternalStorage(sourceUri: Uri): String? {
        return withContext(Dispatchers.IO) {
            try {
                val inputStream = context.contentResolver.openInputStream(sourceUri)
                val fileName = "txn_attach_${System.currentTimeMillis()}.jpg"
                val file = File(context.filesDir, fileName)
                val outputStream = FileOutputStream(file)
                inputStream?.use { input ->
                    outputStream.use { output ->
                        input.copyTo(output)
                    }
                }
                file.absolutePath
            } catch (e: Exception) {
                Log.e("TransactionViewModel", "Error saving image to internal storage", e)
                null
            }
        }
    }


    fun updateTransactionDescription(id: Int, description: String) = viewModelScope.launch {
        if (description.isNotBlank()) {
            transactionRepository.updateDescription(id, description)
        }
    }

    fun updateTransactionAmount(id: Int, amountStr: String) = viewModelScope.launch {
        amountStr.toDoubleOrNull()?.let {
            if (it > 0) {
                transactionRepository.updateAmount(id, it)
            }
        }
    }

    fun updateTransactionNotes(id: Int, notes: String) = viewModelScope.launch {
        transactionRepository.updateNotes(id, notes.takeIf { it.isNotBlank() })
    }

    fun updateTransactionCategory(id: Int, categoryId: Int?) = viewModelScope.launch {
        transactionRepository.updateCategoryId(id, categoryId)
    }

    fun updateTransactionAccount(id: Int, accountId: Int) = viewModelScope.launch {
        transactionRepository.updateAccountId(id, accountId)
    }

    fun updateTransactionDate(id: Int, date: Long) = viewModelScope.launch {
        transactionRepository.updateDate(id, date)
    }

    fun updateTagsForTransaction(transactionId: Int) = viewModelScope.launch {
        Log.d(TAG, "updateTagsForTransaction: Saving tags for txn ID $transactionId. Tags: ${_selectedTags.value.map { it.name }}")
        transactionRepository.updateTagsForTransaction(transactionId, _selectedTags.value)
    }

    fun onTagSelected(tag: Tag) {
        Log.d(TAG, "onTagSelected: Toggled tag '${tag.name}' (ID: ${tag.id})")
        _selectedTags.update { currentTags ->
            val newSet = if (tag in currentTags) {
                currentTags - tag
            } else {
                currentTags + tag
            }
            Log.d(TAG, "onTagSelected: New selected tags: ${newSet.map { it.name }}")
            newSet
        }
    }

    fun addTagOnTheGo(tagName: String) {
        if (tagName.isNotBlank()) {
            viewModelScope.launch {
                Log.d(TAG, "addTagOnTheGo: Attempting to add tag '$tagName'")
                val newTag = Tag(name = tagName)
                Log.d(TAG, "addTagOnTheGo: Current selected tags before insert: ${_selectedTags.value.map { it.name }}")

                val newId = tagRepository.insert(newTag)
                Log.d(TAG, "addTagOnTheGo: Inserted tag '$tagName', got new ID: $newId")

                if (newId != -1L) {
                    _selectedTags.update { currentTags ->
                        val updatedTags = currentTags + newTag.copy(id = newId.toInt())
                        Log.d(TAG, "addTagOnTheGo: Updating selected tags. New set: ${updatedTags.map { it.name }}")
                        updatedTags
                    }
                } else {
                    Log.w(TAG, "addTagOnTheGo: Failed to insert tag '$tagName', it might already exist.")
                }
            }
        }
    }

    fun loadTagsForTransaction(transactionId: Int) {
        if (currentTxnIdForTags == transactionId && areTagsLoadedForCurrentTxn) {
            Log.d(TAG, "loadTagsForTransaction: Skipped DB fetch for txn ID $transactionId, tags already loaded.")
            return
        }

        viewModelScope.launch {
            Log.d(TAG, "loadTagsForTransaction: Loading initial tags for txn ID $transactionId")
            val initialTags = transactionRepository.getTagsForTransaction(transactionId).first()
            _selectedTags.value = initialTags.toSet()
            areTagsLoadedForCurrentTxn = true
            currentTxnIdForTags = transactionId
            Log.d(TAG, "loadTagsForTransaction: Loaded initial tags: ${initialTags.map { it.name }}. Flag set to true.")
        }
    }

    fun clearSelectedTags() {
        _selectedTags.value = emptySet()
        areTagsLoadedForCurrentTxn = false
        currentTxnIdForTags = null
        Log.d(TAG, "clearSelectedTags: Cleared selected tags and reset loading flag.")
    }

    fun getTransactionDetailsById(id: Int): Flow<TransactionDetails?> {
        return transactionRepository.getTransactionDetailsById(id)
    }

    fun getTransactionById(id: Int): Flow<Transaction?> {
        return transactionRepository.getTransactionById(id)
    }

    suspend fun approveSmsTransaction(
        potentialTxn: PotentialTransaction,
        description: String,
        categoryId: Int?,
        notes: String?,
        tags: Set<Tag>
    ): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                val accountName = potentialTxn.potentialAccount?.formattedName ?: "Unknown Account"
                val accountType = potentialTxn.potentialAccount?.accountType ?: "General"

                var account = db.accountDao().findByName(accountName)
                if (account == null) {
                    Log.d("ViewModel_Approve", "Account '$accountName' not found. Creating new one.")
                    val newAccount = Account(name = accountName, type = accountType)
                    accountRepository.insert(newAccount)
                    account = db.accountDao().findByName(accountName)
                }

                if (account == null) {
                    Log.e("ViewModel_Approve", "Failed to find or create account.")
                    return@withContext false
                }

                val newTransaction = Transaction(
                    description = description,
                    categoryId = categoryId,
                    amount = potentialTxn.amount,
                    date = System.currentTimeMillis(),
                    accountId = account.id,
                    notes = notes,
                    transactionType = potentialTxn.transactionType,
                    sourceSmsId = potentialTxn.sourceSmsId,
                    sourceSmsHash = potentialTxn.sourceSmsHash,
                    source = "Reviewed Import"
                )

                transactionRepository.insertTransactionWithTags(newTransaction, tags)
                Log.d("ViewModel_Approve", "Successfully approved and saved transaction.")
                true
            } catch (e: Exception) {
                Log.e("ViewModel_Approve", "Error approving SMS transaction", e)
                false
            }
        }
    }


    fun addTransaction(
        description: String,
        categoryId: Int?,
        amountStr: String,
        accountId: Int,
        notes: String?,
        date: Long,
        transactionType: String,
        sourceSmsId: Long?,
        sourceSmsHash: String?,
        imageUris: List<Uri>
    ): Boolean {
        _validationError.value = null

        if (description.isBlank()) {
            _validationError.value = "Description cannot be empty."
            return false
        }
        val amount = amountStr.toDoubleOrNull()
        if (amount == null || amount <= 0.0) {
            _validationError.value = "Please enter a valid, positive amount."
            return false
        }

        val newTransaction =
            Transaction(
                description = description,
                categoryId = categoryId,
                amount = amount,
                date = date,
                accountId = accountId,
                notes = notes,
                transactionType = transactionType,
                sourceSmsId = sourceSmsId,
                sourceSmsHash = sourceSmsHash,
                source = "Manual Entry"
            )
        viewModelScope.launch {
            val savedImagePaths = imageUris.mapNotNull { uri ->
                saveImageToInternalStorage(uri)
            }

            val newTransactionId = transactionRepository.insertTransactionWithTagsAndImages(
                newTransaction,
                _selectedTags.value,
                savedImagePaths
            )
            Log.d(TAG, "Transaction created with ID: $newTransactionId")
        }
        return true
    }

    fun updateTransaction(transaction: Transaction): Boolean {
        _validationError.value = null

        if (transaction.description.isBlank()) {
            _validationError.value = "Description cannot be empty."
            return false
        }
        if (transaction.amount <= 0.0) {
            _validationError.value = "Amount must be a valid, positive number."
            return false
        }

        viewModelScope.launch {
            transactionRepository.updateTransactionWithTags(transaction, _selectedTags.value)
        }
        return true
    }

    fun deleteTransaction(transaction: Transaction) =
        viewModelScope.launch {
            transactionRepository.delete(transaction)
        }

    fun clearError() {
        _validationError.value = null
    }
}
-e 


================== FILE: ./app/src/main/java/TransactionDetails.kt ==================
package io.pm.finlight

import androidx.room.Embedded
import androidx.room.Relation

data class TransactionDetails(
    @Embedded
    val transaction: Transaction,
    @Relation(
        parentColumn = "id",
        entityColumn = "transactionId"
    )
    val images: List<TransactionImage>, // --- NEW: Add relation to images ---
    val accountName: String?,
    val categoryName: String?,
    val categoryIconKey: String?,
    val categoryColorKey: String?
)
-e 


================== FILE: ./app/src/main/java/CsvValidationReport.kt ==================
package io.pm.finlight

/**
 * An enum to represent the validation status of a single row from the CSV.
 */
enum class CsvRowStatus {
    VALID,
    INVALID_COLUMN_COUNT,
    INVALID_DATE,
    INVALID_AMOUNT,
    ACCOUNT_NOT_FOUND,
    CATEGORY_NOT_FOUND,
    NEEDS_ACCOUNT_CREATION,
    NEEDS_CATEGORY_CREATION,
    NEEDS_BOTH_CREATION,
}

/**
 * A data class representing a single, reviewable row from the imported CSV file.
 * It holds the original data and its current validation status.
 */
data class ReviewableRow(
    val lineNumber: Int,
    var rowData: List<String>,
    var status: CsvRowStatus,
    var statusMessage: String,
)

/**
 * A data class to hold the full results of a CSV validation process.
 */
data class CsvValidationReport(
    val reviewableRows: List<ReviewableRow> = emptyList(),
    val totalRowCount: Int = 0,
)
-e 


================== FILE: ./app/src/main/java/NavItems.kt ==================
package io.pm.finlight

import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Assessment
import androidx.compose.material.icons.filled.Home
import androidx.compose.material.icons.filled.Person
import androidx.compose.material.icons.filled.Receipt
import androidx.compose.ui.graphics.vector.ImageVector

sealed class BottomNavItem(val route: String, val icon: ImageVector, val label: String) {
    object Dashboard : BottomNavItem("dashboard", Icons.Filled.Home, "Dashboard")
    object Transactions : BottomNavItem("transaction_list", Icons.Filled.Receipt, "Transactions")
    object Reports : BottomNavItem("reports_screen", Icons.Filled.Assessment, "Reports")
    object Profile : BottomNavItem("profile", Icons.Filled.Person, "Profile")
}
val screenTitles = mapOf(
    BottomNavItem.Dashboard.route to "Dashboard",
    BottomNavItem.Transactions.route to "All Transactions",
    BottomNavItem.Reports.route to "Reports",
    BottomNavItem.Profile.route to "Profile",
    "settings_screen" to "App Settings",
    "add_transaction" to "Add Transaction",
    // --- DELETED: Removed route for the obsolete EditTransactionScreen ---
    // "edit_transaction/{transactionId}" to "Edit Transaction",
    "transaction_detail/{transactionId}" to "Edit Transaction", // The detail screen is now the edit screen
    "account_list" to "Your Accounts",
    "add_account" to "Add New Account",
    "edit_account/{accountId}" to "Edit Account",
    "account_detail/{accountId}" to "Account Details",
    "budget_screen" to "Manage Budgets",
    "add_budget" to "Add Category Budget",
    "edit_budget/{budgetId}" to "Edit Budget",
    "category_list" to "Manage Categories",
    "recurring_transactions" to "Recurring Transactions",
    "add_recurring_transaction" to "Add Recurring Rule",
    "search_screen" to "Search",
    "review_sms_screen" to "Review SMS Transactions",
    "approve_transaction_screen/{amount}/{type}/{merchant}/{smsId}/{smsSender}" to "Approve Transaction",
    "tag_management" to "Manage Tags",
    "edit_profile" to "Edit Profile"
)
-e 


================== FILE: ./app/src/main/java/WeeklySummaryWorker.kt ==================
package io.pm.finlight

import android.content.Context
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.withContext
import java.util.Calendar

/**
 * A background worker that calculates the user's financial summary for the past 7 days
 * and displays it as a system notification.
 */
class WeeklySummaryWorker(
    private val context: Context,
    workerParams: WorkerParameters,
) : CoroutineWorker(context, workerParams) {
    override suspend fun doWork(): Result {
        return withContext(Dispatchers.IO) {
            try {
                Log.d("WeeklySummaryWorker", "Worker starting...")
                val db = AppDatabase.getInstance(context)
                val transactionDao = db.transactionDao()

                // 1. Calculate the start and end timestamps for the last 7 days.
                val calendar = Calendar.getInstance()
                val endDate = calendar.timeInMillis
                calendar.add(Calendar.DAY_OF_YEAR, -7)
                val startDate = calendar.timeInMillis

                // 2. Fetch transactions for the last week using the existing DAO method.
                val transactions = transactionDao.getTransactionDetailsForRange(startDate, endDate).first()
                Log.d("WeeklySummaryWorker", "Found ${transactions.size} transactions in the last 7 days.")

                // 3. Calculate total income and expenses.
                var totalIncome = 0.0
                var totalExpenses = 0.0
                transactions.forEach { details ->
                    if (details.transaction.transactionType == "income") {
                        totalIncome += details.transaction.amount
                    } else {
                        totalExpenses += details.transaction.amount
                    }
                }

                // 4. Send the summary notification via the helper.
                NotificationHelper.showWeeklySummaryNotification(context, totalIncome, totalExpenses)

                Log.d("WeeklySummaryWorker", "Worker finished successfully.")
                Result.success()
            } catch (e: Exception) {
                Log.e("WeeklySummaryWorker", "Worker failed", e)
                Result.retry() // Retry the job if it fails
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/SearchViewModel.kt ==================
package io.pm.finlight

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch

data class SearchUiState(
    val keyword: String = "",
    val selectedAccount: Account? = null,
    val selectedCategory: Category? = null,
    val transactionType: String = "All", // "All", "Income", "Expense"
    val startDate: Long? = null,
    val endDate: Long? = null,
    val accounts: List<Account> = emptyList(),
    val categories: List<Category> = emptyList(),
    val hasSearched: Boolean = false,
)

class SearchViewModel(
    private val transactionDao: TransactionDao,
    private val accountDao: AccountDao,
    private val categoryDao: CategoryDao,
) : ViewModel() {
    private val _uiState = MutableStateFlow(SearchUiState())
    val uiState: StateFlow<SearchUiState> = _uiState.asStateFlow()

    private val _searchResults = MutableStateFlow<List<TransactionDetails>>(emptyList())
    val searchResults: StateFlow<List<TransactionDetails>> = _searchResults.asStateFlow()

    init {
        viewModelScope.launch {
            accountDao.getAllAccounts().collect { accounts ->
                _uiState.update { it.copy(accounts = accounts) }
            }
        }
        viewModelScope.launch {
            categoryDao.getAllCategories().collect { categories ->
                _uiState.update { it.copy(categories = categories) }
            }
        }
    }

    fun onKeywordChange(newKeyword: String) {
        _uiState.update { it.copy(keyword = newKeyword) }
    }

    fun onAccountChange(account: Account?) {
        _uiState.update { it.copy(selectedAccount = account) }
    }

    fun onCategoryChange(category: Category?) {
        _uiState.update { it.copy(selectedCategory = category) }
    }

    // CORRECTED: The 'type' parameter is now nullable to handle when the user clears the filter.
    fun onTypeChange(type: String?) {
        // If the type is null (cleared), default back to "All".
        _uiState.update { it.copy(transactionType = type ?: "All") }
    }

    fun onDateChange(
        start: Long? = _uiState.value.startDate,
        end: Long? = _uiState.value.endDate,
    ) {
        _uiState.update { it.copy(startDate = start, endDate = end) }
    }

    fun clearFilters() {
        _uiState.value =
            SearchUiState(
                accounts = _uiState.value.accounts,
                categories = _uiState.value.categories,
            )
        _searchResults.value = emptyList()
    }

    fun executeSearch() {
        viewModelScope.launch {
            val state = _uiState.value
            _searchResults.value =
                transactionDao.searchTransactions(
                    keyword = state.keyword,
                    accountId = state.selectedAccount?.id,
                    categoryId = state.selectedCategory?.id,
                    transactionType = if (state.transactionType.equals("All", ignoreCase = true)) null else state.transactionType.lowercase(),
                    startDate = state.startDate,
                    endDate = state.endDate,
                )
            _uiState.update { it.copy(hasSearched = true) }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/RecurringTransactionDao.kt ==================
package io.pm.finlight

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import kotlinx.coroutines.flow.Flow

@Dao
interface RecurringTransactionDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(recurringTransaction: RecurringTransaction)

    @Update
    suspend fun update(recurringTransaction: RecurringTransaction)

    @Delete
    suspend fun delete(recurringTransaction: RecurringTransaction)

    @Query("SELECT * FROM recurring_transactions ORDER BY startDate DESC")
    fun getAll(): Flow<List<RecurringTransaction>>

    @Query("SELECT * FROM recurring_transactions WHERE id = :id")
    fun getById(id: Int): Flow<RecurringTransaction?>
}
-e 


================== FILE: ./app/src/main/java/MerchantMapping.kt ==================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

@Serializable
@Entity(tableName = "merchant_mappings")
data class MerchantMapping(
    @PrimaryKey
    val smsSender: String, // e.g., "AM-HDFCBK"
    val merchantName: String, // e.g., "McDonald's"
)
-e 


================== FILE: ./app/src/main/java/AccountWithBalance.kt ==================
package io.pm.finlight

import androidx.room.Embedded

/**
 * A data class to hold an Account and its dynamically calculated balance.
 * This is used for display purposes in the UI and is not a database entity.
 */
data class AccountWithBalance(
    @Embedded
    val account: Account,
    val balance: Double,
)
-e 


================== FILE: ./app/src/main/java/Account.kt ==================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

@Serializable
@Entity(tableName = "accounts")
data class Account(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val name: String,
    val type: String,
    // The balance field is intentionally removed from the database entity.
    // It will be calculated on-the-fly.
)
-e 


================== FILE: ./app/src/main/java/SmsMessage.kt ==================
package io.pm.finlight

/**
 * A simple data class to hold the relevant information from an SMS message.
 */
data class SmsMessage(
    val id: Long,
    val sender: String,
    val body: String,
    val date: Long,
)
-e 


================== FILE: ./app/src/main/java/MonthlyTrend.kt ==================
package io.pm.finlight

data class MonthlyTrend(
    val monthYear: String, // Format: "YYYY-MM"
    val totalIncome: Double,
    val totalExpenses: Double,
)
-e 


================== FILE: ./app/src/main/java/RecurringTransaction.kt ==================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

@Serializable
@Entity(
    tableName = "recurring_transactions",
    indices = [
        Index(value = ["accountId"]),
        Index(value = ["categoryId"]),
    ],
    foreignKeys = [
        ForeignKey(
            entity = Account::class,
            parentColumns = ["id"],
            childColumns = ["accountId"],
            onDelete = ForeignKey.CASCADE,
        ),
        ForeignKey(
            entity = Category::class,
            parentColumns = ["id"],
            childColumns = ["categoryId"],
            onDelete = ForeignKey.SET_NULL,
        ),
    ],
)
data class RecurringTransaction(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val description: String,
    val amount: Double,
    val transactionType: String, // "income" or "expense"
    val recurrenceInterval: String, // e.g., "Monthly", "Weekly", "Yearly"
    val startDate: Long, // Timestamp for the first occurrence
    val accountId: Int,
    val categoryId: Int?,
)
-e 


================== FILE: ./app/src/main/java/CategoryViewModel.kt ==================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.firstOrNull
import kotlinx.coroutines.flow.receiveAsFlow
import kotlinx.coroutines.launch

class CategoryViewModel(application: Application) : AndroidViewModel(application) {
    private val categoryRepository: CategoryRepository
    private val transactionRepository: TransactionRepository
    val allCategories: Flow<List<Category>>
    private val _uiEvent = Channel<String>()
    val uiEvent = _uiEvent.receiveAsFlow()

    init {
        val db = AppDatabase.getInstance(application)
        categoryRepository = CategoryRepository(db.categoryDao())
        transactionRepository = TransactionRepository(db.transactionDao())
        allCategories = categoryRepository.allCategories
    }

    suspend fun getCategoryById(id: Int): Category? {
        return allCategories.firstOrNull()?.find { it.id == id }
    }

    fun addCategory(name: String, iconKey: String, colorKey: String) =
        viewModelScope.launch {
            // --- NEW: Logic to assign a better default icon and color ---
            val usedColorKeys = allCategories.firstOrNull()?.map { it.colorKey } ?: emptyList()

            // If the default icon was passed, use our special "letter" key.
            // The UI will know how to render this.
            val finalIconKey = if (iconKey == "category") "letter_default" else iconKey

            // If the default color was passed, find the next available color.
            val finalColorKey = if (colorKey == "gray_light") {
                CategoryIconHelper.getNextAvailableColor(usedColorKeys)
            } else {
                colorKey
            }

            categoryRepository.insert(Category(name = name, iconKey = finalIconKey, colorKey = finalColorKey))
        }

    fun updateCategory(category: Category) =
        viewModelScope.launch {
            categoryRepository.update(category)
        }

    fun deleteCategory(category: Category) =
        viewModelScope.launch {
            val transactionCount = transactionRepository.countTransactionsForCategory(category.id)
            if (transactionCount == 0) {
                categoryRepository.delete(category)
                _uiEvent.send("Category '${category.name}' deleted.")
            } else {
                _uiEvent.send("Cannot delete '${category.name}'. It's used by $transactionCount transaction(s).")
            }
        }
}
-e 


================== FILE: ./app/src/main/java/CategorySpending.kt ==================
package io.pm.finlight

/**
 * A simple data class to hold the results of a GROUP BY query,
 * containing the name of a category, its visual identifiers, and the total amount spent in it.
 */
data class CategorySpending(
    val categoryName: String,
    val totalAmount: Double,
    val colorKey: String?,
    val iconKey: String?
)
-e 


================== FILE: ./app/src/main/java/Category.kt ==================
package io.pm.finlight

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.Index
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

@Serializable
@Entity(
    tableName = "categories",
    // Ensure that no two categories can have the same name.
    indices = [Index(value = ["name"], unique = true)],
)
data class Category(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    @ColumnInfo(name = "name")
    val name: String,
    // A key to identify the Material Icon for the category
    @ColumnInfo(name = "iconKey")
    val iconKey: String = "category", // Default icon
    // --- NEW: A key to identify the icon's background color ---
    @ColumnInfo(name = "colorKey")
    val colorKey: String = "gray" // Default color
)
-e 


================== FILE: ./app/src/main/java/ReminderManager.kt ==================
package io.pm.finlight

import android.content.Context
import androidx.work.*
import java.util.concurrent.TimeUnit

object ReminderManager {
    private const val DAILY_EXPENSE_REPORT_WORK_TAG = "daily_expense_report_work"
    private const val WEEKLY_SUMMARY_WORK_TAG = "weekly_summary_work"

    fun scheduleDailyReport(context: Context) {
        val constraints =
            Constraints.Builder()
                .setRequiresDeviceIdle(true)
                .build()

        // Schedule the new DailyReportWorker to run periodically.
        val dailyReportRequest =
            PeriodicWorkRequestBuilder<DailyReportWorker>(1, TimeUnit.DAYS)
                .setConstraints(constraints)
                .build()

        WorkManager.getInstance(context).enqueueUniquePeriodicWork(
            DAILY_EXPENSE_REPORT_WORK_TAG,
            ExistingPeriodicWorkPolicy.KEEP,
            dailyReportRequest,
        )
    }

    fun cancelDailyReport(context: Context) {
        WorkManager.getInstance(context).cancelUniqueWork(DAILY_EXPENSE_REPORT_WORK_TAG)
    }

    fun scheduleWeeklySummary(context: Context) {
        val reminderRequest =
            PeriodicWorkRequestBuilder<WeeklySummaryWorker>(7, TimeUnit.DAYS)
                .build()

        WorkManager.getInstance(context).enqueueUniquePeriodicWork(
            WEEKLY_SUMMARY_WORK_TAG,
            ExistingPeriodicWorkPolicy.KEEP,
            reminderRequest,
        )
    }

    fun cancelWeeklySummary(context: Context) {
        WorkManager.getInstance(context).cancelUniqueWork(WEEKLY_SUMMARY_WORK_TAG)
    }
}
-e 


================== FILE: ./app/src/main/java/Tag.kt ==================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.Index
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

/**
 * Represents a user-defined Tag (e.g., "Work Trip", "Vacation 2025", "Tax-Deductible").
 * Tags provide a flexible way to organize transactions outside of the rigid category system.
 */
@Serializable
@Entity(
    tableName = "tags",
    indices = [Index(value = ["name"], unique = true)]
)
data class Tag(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val name: String
)-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/TagManagementScreen.kt ==================
// FILE: app/src/main/java/io/pm/finlight/ui/screens/TagManagementScreen.kt

package io.pm.finlight.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import io.pm.finlight.Tag
import io.pm.finlight.TagViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun TagManagementScreen(viewModel: TagViewModel = viewModel()) {
    val tags by viewModel.allTags.collectAsState()
    var newTagName by remember { mutableStateOf("") }

    var showEditDialog by remember { mutableStateOf(false) }
    var showDeleteDialog by remember { mutableStateOf(false) }
    var selectedTag by remember { mutableStateOf<Tag?>(null) }

    val snackbarHostState = remember { SnackbarHostState() }

    // This listens for one-time events from the ViewModel
    LaunchedEffect(key1 = viewModel.uiEvent) {
        viewModel.uiEvent.collect { message ->
            snackbarHostState.showSnackbar(message)
        }
    }

    Scaffold(
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
                .padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                OutlinedTextField(
                    value = newTagName,
                    onValueChange = { newTagName = it },
                    label = { Text("New Tag Name") },
                    modifier = Modifier.weight(1f)
                )
                Button(
                    onClick = {
                        viewModel.addTag(newTagName)
                        newTagName = "" // Clear input field
                    },
                    enabled = newTagName.isNotBlank()
                ) {
                    Icon(Icons.Default.Add, contentDescription = "Add Tag")
                }
            }

            Spacer(modifier = Modifier.height(16.dp))
            HorizontalDivider()

            if (tags.isEmpty()) {
                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    Text("No tags created yet. Add one above!")
                }
            } else {
                LazyColumn {
                    items(tags) { tag ->
                        ListItem(
                            headlineContent = { Text(tag.name) },
                            trailingContent = {
                                Row {
                                    IconButton(onClick = {
                                        selectedTag = tag
                                        showEditDialog = true
                                    }) {
                                        Icon(Icons.Default.Edit, contentDescription = "Edit Tag")
                                    }
                                    IconButton(onClick = {
                                        selectedTag = tag
                                        showDeleteDialog = true
                                    }) {
                                        Icon(
                                            Icons.Default.Delete,
                                            contentDescription = "Delete Tag",
                                            tint = MaterialTheme.colorScheme.error
                                        )
                                    }
                                }
                            }
                        )
                        HorizontalDivider()
                    }
                }
            }
        }
    }

    // --- DIALOGS ---

    if (showEditDialog && selectedTag != null) {
        EditTagDialog(
            tag = selectedTag!!,
            onDismiss = { showEditDialog = false },
            onConfirm = { updatedTag ->
                viewModel.updateTag(updatedTag)
                showEditDialog = false
            }
        )
    }

    if (showDeleteDialog && selectedTag != null) {
        DeleteTagDialog(
            tag = selectedTag!!,
            onDismiss = { showDeleteDialog = false },
            onConfirm = {
                viewModel.deleteTag(it)
                showDeleteDialog = false
            }
        )
    }
}


@Composable
private fun EditTagDialog(
    tag: Tag,
    onDismiss: () -> Unit,
    onConfirm: (Tag) -> Unit
) {
    var tagName by remember(tag) { mutableStateOf(tag.name) }
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Edit Tag") },
        text = {
            OutlinedTextField(
                value = tagName,
                onValueChange = { tagName = it },
                label = { Text("Tag Name") },
                modifier = Modifier.fillMaxWidth()
            )
        },
        confirmButton = {
            Button(
                onClick = { onConfirm(tag.copy(name = tagName)) },
                enabled = tagName.isNotBlank()
            ) {
                Text("Save")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) { Text("Cancel") }
        }
    )
}

@Composable
private fun DeleteTagDialog(
    tag: Tag,
    onDismiss: () -> Unit,
    onConfirm: (Tag) -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Delete Tag?") },
        text = { Text("Are you sure you want to delete the tag '${tag.name}'?") },
        confirmButton = {
            Button(
                onClick = { onConfirm(tag) },
                colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
            ) {
                Text("Delete")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) { Text("Cancel") }
        }
    )
}

-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/AddRecurringTransactionScreen.kt ==================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.Button
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.ExposedDropdownMenuBox
import androidx.compose.material3.ExposedDropdownMenuDefaults
import androidx.compose.material3.FilterChip
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import io.pm.finlight.Account
import io.pm.finlight.Category
import io.pm.finlight.RecurringTransactionViewModel
import io.pm.finlight.TransactionViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddRecurringTransactionScreen(navController: NavController) {
    val recurringViewModel: RecurringTransactionViewModel = viewModel()
    val transactionViewModel: TransactionViewModel = viewModel()

    var description by remember { mutableStateOf("") }
    var amount by remember { mutableStateOf("") }
    var transactionType by remember { mutableStateOf("expense") }

    val recurrenceIntervals = listOf("Daily", "Weekly", "Monthly", "Yearly")
    var selectedInterval by remember { mutableStateOf(recurrenceIntervals[2]) }
    var intervalExpanded by remember { mutableStateOf(false) }

    val accounts by transactionViewModel.allAccounts.collectAsState(initial = emptyList())
    var selectedAccount by remember { mutableStateOf<Account?>(null) }
    var accountExpanded by remember { mutableStateOf(false) }

    val categories by transactionViewModel.allCategories.collectAsState(initial = emptyList())
    var selectedCategory by remember { mutableStateOf<Category?>(null) }
    var categoryExpanded by remember { mutableStateOf(false) }

    LazyColumn(
        modifier = Modifier.fillMaxSize().padding(),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp),
    ) {
        item {
            OutlinedTextField(value = description, onValueChange = {
                description = it
            }, label = { Text("Description") }, modifier = Modifier.fillMaxWidth())
        }
        item {
            OutlinedTextField(value = amount, onValueChange = {
                amount = it
            }, label = {
                Text(
                    "Amount",
                )
            }, modifier = Modifier.fillMaxWidth(), keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number))
        }

        item {
            Row {
                FilterChip(selected = transactionType == "expense", onClick = {
                    transactionType = "expense"
                }, label = { Text("Expense") }, modifier = Modifier.weight(1f))
                Spacer(Modifier.width(8.dp))
                FilterChip(selected = transactionType == "income", onClick = {
                    transactionType = "income"
                }, label = { Text("Income") }, modifier = Modifier.weight(1f))
            }
        }

        item {
            ExposedDropdownMenuBox(expanded = intervalExpanded, onExpandedChange = { intervalExpanded = !intervalExpanded }) {
                OutlinedTextField(value = selectedInterval, onValueChange = {
                }, readOnly = true, label = {
                    Text("Repeats")
                }, trailingIcon = {
                    ExposedDropdownMenuDefaults.TrailingIcon(expanded = intervalExpanded)
                }, modifier = Modifier.fillMaxWidth().menuAnchor())
                ExposedDropdownMenu(expanded = intervalExpanded, onDismissRequest = { intervalExpanded = false }) {
                    recurrenceIntervals.forEach {
                            interval ->
                        DropdownMenuItem(text = { Text(interval) }, onClick = {
                            selectedInterval = interval
                            intervalExpanded = false
                        })
                    }
                }
            }
        }

        item {
            ExposedDropdownMenuBox(expanded = accountExpanded, onExpandedChange = { accountExpanded = !accountExpanded }) {
                OutlinedTextField(value = selectedAccount?.name ?: "Select Account", onValueChange = {
                }, readOnly = true, label = {
                    Text("Account")
                }, trailingIcon = {
                    ExposedDropdownMenuDefaults.TrailingIcon(
                        expanded = accountExpanded,
                    )
                }, modifier = Modifier.fillMaxWidth().menuAnchor())
                ExposedDropdownMenu(expanded = accountExpanded, onDismissRequest = { accountExpanded = false }) {
                    accounts.forEach {
                            account ->
                        DropdownMenuItem(text = { Text(account.name) }, onClick = {
                            selectedAccount = account
                            accountExpanded = false
                        })
                    }
                }
            }
        }

        item {
            ExposedDropdownMenuBox(expanded = categoryExpanded, onExpandedChange = { categoryExpanded = !categoryExpanded }) {
                OutlinedTextField(value = selectedCategory?.name ?: "Select Category", onValueChange = {
                }, readOnly = true, label = {
                    Text("Category")
                }, trailingIcon = {
                    ExposedDropdownMenuDefaults.TrailingIcon(expanded = categoryExpanded)
                }, modifier = Modifier.fillMaxWidth().menuAnchor())
                ExposedDropdownMenu(expanded = categoryExpanded, onDismissRequest = { categoryExpanded = false }) {
                    categories.forEach {
                            category ->
                        DropdownMenuItem(text = { Text(category.name) }, onClick = {
                            selectedCategory = category
                            categoryExpanded = false
                        })
                    }
                }
            }
        }

        item {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(16.dp),
            ) {
                OutlinedButton(onClick = { navController.popBackStack() }, modifier = Modifier.weight(1f)) {
                    Text("Cancel")
                }
                Button(
                    onClick = {
                        val amountDouble = amount.toDoubleOrNull()
                        if (amountDouble != null && selectedAccount != null) {
                            recurringViewModel.addRecurringTransaction(
                                description,
                                amountDouble,
                                transactionType,
                                selectedInterval,
                                System.currentTimeMillis(),
                                selectedAccount!!.id,
                                selectedCategory?.id,
                            )
                            navController.popBackStack()
                        }
                    },
                    modifier = Modifier.weight(1f),
                    enabled = description.isNotBlank() && amount.isNotBlank() && selectedAccount != null,
                ) {
                    Text("Save Rule")
                }
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/OnboardingPages.kt ==================
// FILE: app/src/main/java/io/pm/finlight/ui/screens/OnboardingPages.kt

package io.pm.finlight.ui.screens

import android.Manifest
import android.os.Build
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.Message
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardCapitalization
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.unit.dp
import io.pm.finlight.OnboardingViewModel

@Composable
fun WelcomePage() {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center,
        modifier = Modifier
            .fillMaxSize()
            .padding(32.dp)
    ) {
        Icon(
            imageVector = Icons.Default.PrivacyTip,
            contentDescription = "Privacy Icon",
            modifier = Modifier.size(80.dp),
            tint = MaterialTheme.colorScheme.primary
        )
        Spacer(modifier = Modifier.height(24.dp))
        Text(
            text = "Welcome to Finlight",
            style = MaterialTheme.typography.headlineMedium,
            textAlign = TextAlign.Center
        )
        Spacer(modifier = Modifier.height(16.dp))
        Text(
            buildAnnotatedString {
                append("Your ")
                withStyle(style = SpanStyle(fontWeight = FontWeight.Bold, color = Color(0xFF00C853))) {
                    append("PRIVACY")
                }
                append(" is our ")
                withStyle(style = SpanStyle(fontWeight = FontWeight.Bold, color = Color(0xFF00C853))) {
                    append("PRIORITY")
                }
                append(". All your data is ")
                withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {
                    append("STORED SECURELY")
                }
                append(" and ")
                withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {
                    append("ONLY ON YOUR DEVICE")
                }
                append(". Let's get you set up.")
            },
            style = MaterialTheme.typography.bodyLarge,
            textAlign = TextAlign.Center
        )
    }
}

@Composable
fun UserNamePage(viewModel: OnboardingViewModel) {
    val name by viewModel.userName.collectAsState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Icon(
            imageVector = Icons.Default.AccountCircle,
            contentDescription = "User Icon",
            modifier = Modifier.size(80.dp),
            tint = MaterialTheme.colorScheme.primary
        )
        Spacer(Modifier.height(24.dp))
        Text("What should we call you?", style = MaterialTheme.typography.headlineSmall)
        Text(
            "This will be used to personalize your experience.",
            style = MaterialTheme.typography.bodyMedium,
            textAlign = TextAlign.Center,
            modifier = Modifier.padding(top = 8.dp)
        )
        Spacer(Modifier.height(24.dp))
        OutlinedTextField(
            value = name,
            onValueChange = { viewModel.onNameChanged(it) },
            label = { Text("Your Name") },
            keyboardOptions = KeyboardOptions(
                keyboardType = KeyboardType.Text,
                capitalization = KeyboardCapitalization.Words
            ),
            singleLine = true,
            modifier = Modifier.fillMaxWidth()
        )
    }
}

@Composable
fun BudgetSetupPage(viewModel: OnboardingViewModel) {
    val budget by viewModel.monthlyBudget.collectAsState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Text("Set a Monthly Budget", style = MaterialTheme.typography.headlineSmall)
        Text(
            "Give yourself a spending target for the month.",
            style = MaterialTheme.typography.bodyMedium,
            textAlign = TextAlign.Center,
            modifier = Modifier.padding(top = 8.dp)
        )
        Text(
            "This can be changed any time in Settings.",
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        Spacer(Modifier.height(24.dp))
        OutlinedTextField(
            value = budget,
            onValueChange = { viewModel.onBudgetChanged(it) },
            label = { Text("Total Monthly Budget") },
            leadingIcon = { Text("") },
            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
            modifier = Modifier.fillMaxWidth()
        )
    }
}

@Composable
fun SmsPermissionPage(onPermissionResult: () -> Unit) {
    val context = LocalContext.current
    val permissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestMultiplePermissions()
    ) { perms ->
        if (perms.values.any { !it }) {
            Toast.makeText(context, "Permissions denied. You can enable them later in settings.", Toast.LENGTH_LONG).show()
        } else {
            Toast.makeText(context, "SMS Scanning Enabled!", Toast.LENGTH_SHORT).show()
        }
        onPermissionResult()
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Icon(Icons.AutoMirrored.Filled.Message, contentDescription = "SMS Icon", modifier = Modifier.size(80.dp), tint = MaterialTheme.colorScheme.primary)
        Spacer(Modifier.height(24.dp))
        Text("Automate Your Tracking", style = MaterialTheme.typography.headlineMedium)
        Spacer(Modifier.height(16.dp))
        Text(
            "Consider allowing Finlight to read your SMS inbox to automatically detect and import new transactions. This is a huge time-saver!",
            style = MaterialTheme.typography.bodyLarge,
            textAlign = TextAlign.Center
        )
        Spacer(Modifier.height(24.dp))
        Button(onClick = {
            permissionLauncher.launch(arrayOf(Manifest.permission.READ_SMS, Manifest.permission.RECEIVE_SMS))
        }) {
            Text("Enable SMS Scanning")
        }
    }
}

@Composable
fun SmsScanningInfoPage() {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Icon(
            imageVector = Icons.Default.AutoAwesome,
            contentDescription = "Magic Wand Icon",
            modifier = Modifier.size(80.dp),
            tint = MaterialTheme.colorScheme.primary
        )
        Spacer(Modifier.height(24.dp))
        Text("Supercharge Your Setup", style = MaterialTheme.typography.headlineMedium, textAlign = TextAlign.Center)
        Spacer(Modifier.height(16.dp))
        Text(
            buildAnnotatedString {
                append("After setup, you can visit the ")
                withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {
                    append("Settings")
                }
                append(" screen at any time to import existing transactions from your SMS inbox.\n\nYou'll have two options:\n\n")
                withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {
                    append(" Quick Scan:")
                }
                append(" A fast scan of recent messages. This defaults to the last 30 days, but you can pick any start date you like!\n\n")
                withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {
                    append(" Full Scan:")
                }
                append(" A complete scan of your entire inbox.")
            },
            style = MaterialTheme.typography.bodyLarge,
            textAlign = TextAlign.Center
        )
    }
}


@Composable
fun NotificationPermissionPage(onPermissionResult: () -> Unit) {
    val context = LocalContext.current
    val permissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestPermission()
    ) { isGranted ->
        if (isGranted) {
            Toast.makeText(context, "Notifications enabled!", Toast.LENGTH_SHORT).show()
        } else {
            Toast.makeText(context, "You can enable notifications later in settings.", Toast.LENGTH_LONG).show()
        }
        onPermissionResult()
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Icon(Icons.Default.NotificationsActive, contentDescription = "Notification Icon", modifier = Modifier.size(80.dp), tint = MaterialTheme.colorScheme.primary)
        Spacer(Modifier.height(24.dp))
        Text("Stay Updated", style = MaterialTheme.typography.headlineMedium)
        Spacer(Modifier.height(16.dp))
        Text(
            "Get notified about new transactions and receive daily, weekly and monthly summaries by enabling notifications.",
            style = MaterialTheme.typography.bodyLarge,
            textAlign = TextAlign.Center
        )
        Spacer(Modifier.height(24.dp))

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            Button(onClick = {
                permissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
            }) {
                Text("Enable Notifications")
            }
            Spacer(Modifier.height(16.dp))
        } else {
            LaunchedEffect(Unit) {
                onPermissionResult()
            }
        }
    }
}

@Composable
fun CompletionPage() {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Icon(
            imageVector = Icons.Default.CheckCircle,
            contentDescription = "Success Icon",
            modifier = Modifier.size(100.dp),
            tint = MaterialTheme.colorScheme.primary
        )
        Spacer(modifier = Modifier.height(24.dp))
        Text(
            text = "You're All Set!",
            style = MaterialTheme.typography.headlineMedium,
            textAlign = TextAlign.Center
        )
        Spacer(modifier = Modifier.height(16.dp))
        Text(
            text = "Your accounts and preferences have been saved. You can now start tracking your finances.",
            style = MaterialTheme.typography.bodyLarge,
            textAlign = TextAlign.Center
        )
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/CategoryListScreen.kt ==================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import io.pm.finlight.Category
import io.pm.finlight.CategoryIconHelper
import io.pm.finlight.CategoryViewModel
import io.pm.finlight.ui.components.DeleteCategoryDialog

@Composable
fun CategoryListScreen(
    navController: NavController,
    viewModel: CategoryViewModel,
) {
    val categories by viewModel.allCategories.collectAsState(initial = emptyList())
    var showEditDialog by remember { mutableStateOf(false) }
    var showDeleteDialog by remember { mutableStateOf(false) }
    var selectedCategory by remember { mutableStateOf<Category?>(null) }
    val snackbarHostState = remember { SnackbarHostState() }

    LaunchedEffect(key1 = viewModel.uiEvent) {
        viewModel.uiEvent.collect { message ->
            snackbarHostState.showSnackbar(message)
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
    ) {
        Button(
            onClick = {
                selectedCategory = null
                showEditDialog = true
            },
            modifier = Modifier.fillMaxWidth()
        ) {
            Icon(imageVector = Icons.Default.Add, contentDescription = "Add")
            Spacer(modifier = Modifier.width(8.dp))
            Text("Add New Category")
        }

        Spacer(modifier = Modifier.height(16.dp))
        HorizontalDivider()

        LazyColumn {
            items(categories) { category ->
                ListItem(
                    headlineContent = { Text(category.name) },
                    leadingContent = {
                        // --- UPDATED: To handle letter-based icons ---
                        Box(
                            modifier = Modifier
                                .size(40.dp)
                                .clip(CircleShape)
                                .background(CategoryIconHelper.getIconBackgroundColor(category.colorKey)),
                            contentAlignment = Alignment.Center
                        ) {
                            if (category.iconKey == "letter_default") {
                                Text(
                                    text = category.name.firstOrNull()?.uppercase() ?: "?",
                                    fontWeight = FontWeight.Bold,
                                    fontSize = 18.sp,
                                    color = Color.Black
                                )
                            } else {
                                Icon(
                                    imageVector = CategoryIconHelper.getIcon(category.iconKey),
                                    contentDescription = category.name,
                                    tint = Color.Black,
                                    modifier = Modifier.size(22.dp)
                                )
                            }
                        }
                    },
                    trailingContent = {
                        Row {
                            IconButton(onClick = {
                                selectedCategory = category
                                showEditDialog = true
                            }) {
                                Icon(imageVector = Icons.Default.Edit, contentDescription = "Edit Category")
                            }
                            IconButton(onClick = {
                                selectedCategory = category
                                showDeleteDialog = true
                            }) {
                                Icon(
                                    imageVector = Icons.Default.Delete,
                                    contentDescription = "Delete Category",
                                    tint = MaterialTheme.colorScheme.error,
                                )
                            }
                        }
                    }
                )
                HorizontalDivider()
            }
        }
    }

    if (showEditDialog) {
        EditCategoryDialog(
            category = selectedCategory,
            onDismiss = { showEditDialog = false },
            onConfirm = { name, iconKey, colorKey ->
                if (selectedCategory == null) {
                    viewModel.addCategory(name, iconKey, colorKey)
                } else {
                    viewModel.updateCategory(selectedCategory!!.copy(name = name, iconKey = iconKey, colorKey = colorKey))
                }
                showEditDialog = false
            },
        )
    }

    if (showDeleteDialog && selectedCategory != null) {
        DeleteCategoryDialog(
            category = selectedCategory!!,
            onDismiss = { showDeleteDialog = false },
            onConfirm = {
                viewModel.deleteCategory(selectedCategory!!)
                showDeleteDialog = false
            },
        )
    }
}


@Composable
fun EditCategoryDialog(
    category: Category?,
    onDismiss: () -> Unit,
    onConfirm: (String, String, String) -> Unit,
) {
    var name by remember { mutableStateOf(category?.name ?: "") }
    var selectedIconKey by remember { mutableStateOf(category?.iconKey ?: "category") }
    var selectedColorKey by remember { mutableStateOf(category?.colorKey ?: "gray_light") }
    val allIcons = remember { CategoryIconHelper.getAllIcons().entries.toList() }
    val allColors = remember { CategoryIconHelper.getAllIconColors().entries.toList() }

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text(if (category == null) "Add Category" else "Edit Category") },
        text = {
            Column {
                OutlinedTextField(
                    value = name,
                    onValueChange = { name = it },
                    label = { Text("Category Name") },
                    modifier = Modifier.fillMaxWidth()
                )
                Spacer(Modifier.height(16.dp))
                Text("Select Icon", style = MaterialTheme.typography.titleMedium)
                LazyVerticalGrid(
                    columns = GridCells.Adaptive(minSize = 48.dp),
                    modifier = Modifier.heightIn(max = 150.dp)
                ) {
                    items(allIcons) { (key, icon) ->
                        IconButton(
                            onClick = { selectedIconKey = key },
                            modifier = Modifier
                                .padding(4.dp)
                                .border(
                                    width = 1.dp,
                                    color = if (selectedIconKey == key) MaterialTheme.colorScheme.primary else Color.Transparent,
                                    shape = MaterialTheme.shapes.medium
                                )
                        ) {
                            Icon(imageVector = icon, contentDescription = key)
                        }
                    }
                }
                Spacer(Modifier.height(16.dp))
                Text("Select Color", style = MaterialTheme.typography.titleMedium)
                LazyVerticalGrid(
                    columns = GridCells.Adaptive(minSize = 48.dp),
                    modifier = Modifier.heightIn(max = 100.dp)
                ) {
                    items(allColors) { (key, color) ->
                        Box(
                            modifier = Modifier
                                .padding(6.dp)
                                .size(32.dp)
                                .clip(CircleShape)
                                .background(color)
                                .clickable { selectedColorKey = key }
                                .border(
                                    width = 2.dp,
                                    color = if (selectedColorKey == key) MaterialTheme.colorScheme.outline else Color.Transparent,
                                    shape = CircleShape
                                )
                        )
                    }
                }
            }
        },
        confirmButton = {
            Button(
                onClick = {
                    if (name.isNotBlank()) {
                        onConfirm(name, selectedIconKey, selectedColorKey)
                    }
                },
                enabled = name.isNotBlank(),
            ) {
                Text(if (category == null) "Add" else "Update")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        },
    )
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/MerchantSpendingScreen.kt ==================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import io.pm.finlight.MerchantSpendingSummary

@Composable
fun MerchantSpendingScreen(merchantList: List<MerchantSpendingSummary>) {
    if (merchantList.isEmpty()) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Text("No merchant data for this month.")
        }
        return
    }

    LazyColumn(
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        items(merchantList) { merchant ->
            MerchantSpendingCard(merchant = merchant)
        }
    }
}

@Composable
fun MerchantSpendingCard(merchant: MerchantSpendingSummary) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(2.dp)
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(merchant.merchantName, style = MaterialTheme.typography.titleMedium, fontWeight = FontWeight.Bold)
                val visitText = if (merchant.transactionCount == 1) "1 visit" else "${merchant.transactionCount} visits"
                Text(visitText, style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant)
            }
            Text(
                "${"%,.2f".format(merchant.totalAmount)}",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.error
            )
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/AddEditBudgetScreen.kt ==================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import io.pm.finlight.Budget
import io.pm.finlight.BudgetViewModel
import io.pm.finlight.Category

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddEditBudgetScreen(
    navController: NavController,
    viewModel: BudgetViewModel,
    budgetId: Int?,
) {
    val isEditMode = budgetId != null
    val buttonText = if (isEditMode) "Update Budget" else "Save Budget"

    var amount by remember { mutableStateOf("") }
    val availableCategories by viewModel.availableCategoriesForNewBudget.collectAsState(initial = emptyList())
    val allCategories by viewModel.allCategories.collectAsState(initial = emptyList())
    var selectedCategory by remember { mutableStateOf<Category?>(null) }
    var isCategoryDropdownExpanded by remember { mutableStateOf(false) }

    val budgetToEdit by if (isEditMode) {
        viewModel.getBudgetById(budgetId!!).collectAsState(initial = null)
    } else {
        remember { mutableStateOf<Budget?>(null) }
    }

    LaunchedEffect(budgetToEdit, allCategories) {
        if (isEditMode) {
            budgetToEdit?.let { budget ->
                amount = "%.0f".format(budget.amount)
                selectedCategory = allCategories.find { it.name == budget.categoryName }
            }
        }
    }

    Column(
        modifier =
            Modifier
                .fillMaxSize()
                .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp),
    ) {
        val isDropdownEnabled = !isEditMode && availableCategories.isNotEmpty()

        ExposedDropdownMenuBox(
            expanded = isCategoryDropdownExpanded && isDropdownEnabled,
            onExpandedChange = { if (isDropdownEnabled) isCategoryDropdownExpanded = !isCategoryDropdownExpanded },
        ) {
            OutlinedTextField(
                value = selectedCategory?.name ?: "Select Category",
                onValueChange = {},
                readOnly = true,
                label = { Text("Category") },
                trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = isCategoryDropdownExpanded && isDropdownEnabled) },
                modifier =
                    Modifier
                        .fillMaxWidth()
                        .menuAnchor(),
                enabled = isDropdownEnabled,
            )
            ExposedDropdownMenu(
                expanded = isCategoryDropdownExpanded && isDropdownEnabled,
                onDismissRequest = { isCategoryDropdownExpanded = false },
            ) {
                availableCategories.forEach { category ->
                    DropdownMenuItem(
                        text = { Text(category.name) },
                        onClick = {
                            selectedCategory = category
                            isCategoryDropdownExpanded = false
                        },
                    )
                }
            }
        }

        if (availableCategories.isEmpty() && !isEditMode) {
            Text(
                text = "All categories already have a budget for this month. You can edit existing budgets from the previous screen.",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
            )
        }

        OutlinedTextField(
            value = amount,
            onValueChange = { amount = it },
            label = { Text("Budget Amount") },
            modifier = Modifier.fillMaxWidth(),
            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
            leadingIcon = { Text("") },
        )
        Spacer(modifier = Modifier.height(16.dp))
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(16.dp),
        ) {
            OutlinedButton(onClick = { navController.popBackStack() }, modifier = Modifier.weight(1f)) {
                Text("Cancel")
            }
            Button(
                onClick = {
                    val amountDouble = amount.toDoubleOrNull()
                    if (selectedCategory != null && amountDouble != null && amountDouble > 0) {
                        if (isEditMode) {
                            budgetToEdit?.let { currentBudget ->
                                viewModel.updateBudget(currentBudget.copy(amount = amountDouble))
                            }
                        } else {
                            viewModel.addCategoryBudget(selectedCategory!!.name, amount)
                        }
                        navController.popBackStack()
                    }
                },
                modifier = Modifier.weight(1f),
                enabled = selectedCategory != null && amount.isNotBlank(),
            ) {
                Text(buttonText)
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/SmsWorkflowScreens.kt ==================
package io.pm.finlight.ui.screens

import android.Manifest
import android.content.pm.PackageManager
import android.util.Log
import android.widget.Toast
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.Notes
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.core.app.NotificationManagerCompat
import androidx.core.content.ContextCompat
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.google.gson.Gson
import io.pm.finlight.*
import kotlinx.coroutines.launch
import java.net.URLEncoder

// --- NEW: Sealed class to manage bottom sheet content ---
private sealed class ApproveSheetContent {
    object Category : ApproveSheetContent()
    object Tags : ApproveSheetContent()
}


@Composable
fun ReviewSmsScreen(
    navController: NavController,
    viewModel: SettingsViewModel,
) {
    val potentialTransactions by viewModel.potentialTransactions.collectAsState()
    val isScanning by viewModel.isScanning.collectAsState()

    var hasLoadedOnce by remember { mutableStateOf(false) }

    LaunchedEffect(isScanning, potentialTransactions) {
        if (!isScanning) {
            hasLoadedOnce = true
        }
        if (hasLoadedOnce && potentialTransactions.isEmpty()) {
            navController.popBackStack()
        }
    }

    if (isScanning && !hasLoadedOnce) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center,
        ) {
            Column(horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.spacedBy(8.dp)) {
                Text("Scanning for transactions...", style = MaterialTheme.typography.titleMedium)
                CircularProgressIndicator(modifier = Modifier.padding(top = 16.dp))
            }
        }
    } else {
        LazyColumn(
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp),
        ) {
            item {
                Text(
                    "${potentialTransactions.size} potential transactions found.",
                    style = MaterialTheme.typography.labelLarge,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                )
            }
            items(potentialTransactions, key = { it.sourceSmsId }) { pt ->
                PotentialTransactionItem(
                    transaction = pt,
                    onDismiss = { viewModel.dismissPotentialTransaction(it) },
                    onApprove = { transaction ->
                        val encodedPotentialTxn = URLEncoder.encode(Gson().toJson(transaction), "UTF-8")
                        val route = "approve_transaction_screen?potentialTxnJson=$encodedPotentialTxn"
                        navController.navigate(route)
                    },
                )
            }
        }
    }
}

@Composable
fun PotentialTransactionItem(
    transaction: PotentialTransaction,
    onDismiss: (PotentialTransaction) -> Unit,
    onApprove: (PotentialTransaction) -> Unit,
) {
    Card(modifier = Modifier.fillMaxWidth(), elevation = CardDefaults.cardElevation(2.dp)) {
        Column(modifier = Modifier.padding(16.dp)) {
            val amountColor = if (transaction.transactionType == "expense") MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary

            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(
                    text = transaction.merchantName ?: "Unknown Merchant",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    modifier = Modifier.weight(1f),
                )
                Text(
                    text = "${"%.2f".format(transaction.amount)}",
                    style = MaterialTheme.typography.titleLarge,
                    color = amountColor,
                    fontWeight = FontWeight.Bold,
                )
            }
            transaction.potentialAccount?.let {
                Text(
                    text = "Account: ${it.formattedName} (${it.accountType})",
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.SemiBold,
                    color = MaterialTheme.colorScheme.secondary
                )
            }
            Spacer(Modifier.height(4.dp))
            Text(
                text = "Type: ${transaction.transactionType.replaceFirstChar { it.uppercase() }}",
                style = MaterialTheme.typography.bodyMedium,
            )
            Spacer(Modifier.height(8.dp))
            Text(
                text = "Original Message: ${transaction.originalMessage}",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                maxLines = 2,
                overflow = TextOverflow.Ellipsis,
            )
            Spacer(Modifier.height(16.dp))
            Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                OutlinedButton(onClick = { onDismiss(transaction) }) { Text("Dismiss") }
                Spacer(Modifier.width(8.dp))
                Button(onClick = { onApprove(transaction) }) { Text("Approve") }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)
@Composable
fun ApproveTransactionScreen(
    navController: NavController,
    transactionViewModel: TransactionViewModel,
    settingsViewModel: SettingsViewModel,
    potentialTxn: PotentialTransaction,
) {
    var description by remember { mutableStateOf(potentialTxn.merchantName ?: "") }
    var notes by remember { mutableStateOf("") }
    var selectedTransactionType by remember(potentialTxn.transactionType) { mutableStateOf(potentialTxn.transactionType) }
    val scope = rememberCoroutineScope()
    // --- FIX: Get the context for the NotificationManager ---
    val context = LocalContext.current

    val categories by transactionViewModel.allCategories.collectAsState(initial = emptyList())
    var selectedCategory by remember { mutableStateOf<Category?>(null) }

    val allTags by transactionViewModel.allTags.collectAsState()
    val selectedTags by transactionViewModel.selectedTags.collectAsState()

    // --- NEW: State for bottom sheets ---
    var activeSheetContent by remember { mutableStateOf<ApproveSheetContent?>(null) }
    val sheetState = rememberModalBottomSheetState()


    val isExpense = selectedTransactionType == "expense"
    val isSaveEnabled = description.isNotBlank() && (!isExpense || selectedCategory != null)

    DisposableEffect(Unit) {
        onDispose {
            transactionViewModel.clearSelectedTags()
        }
    }

    Scaffold { innerPadding ->
        LazyColumn(
            modifier = Modifier
                .padding(innerPadding)
                .fillMaxSize(),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                // --- REFACTORED: Primary Info Card ---
                Card(elevation = CardDefaults.cardElevation(2.dp)) {
                    Column(Modifier.padding(16.dp)) {
                        Text(
                            "${"%,.2f".format(potentialTxn.amount)}",
                            style = MaterialTheme.typography.displaySmall,
                            modifier = Modifier.fillMaxWidth(),
                            textAlign = TextAlign.End,
                            fontWeight = FontWeight.Bold
                        )
                        HorizontalDivider(modifier = Modifier.padding(vertical = 12.dp))
                        OutlinedTextField(
                            value = description,
                            onValueChange = { description = it },
                            label = { Text("Description / Merchant") },
                            modifier = Modifier.fillMaxWidth(),
                            colors = OutlinedTextFieldDefaults.colors(
                                unfocusedBorderColor = Color.Transparent,
                                focusedBorderColor = Color.Transparent
                            ),
                            placeholder = { Text("What was this for?") }
                        )
                    }
                }
            }
            item {
                TabRow(selectedTabIndex = if (isExpense) 0 else 1) {
                    listOf("Expense", "Income").forEachIndexed { index, title ->
                        Tab(selected = (if (isExpense) 0 else 1) == index, onClick = {
                            selectedTransactionType = if (index == 0) "expense" else "income"
                        }, text = { Text(title) })
                    }
                }
            }

            item {
                // --- REFACTORED: Details Card ---
                Card(elevation = CardDefaults.cardElevation(2.dp)) {
                    Column {
                        DetailRow(
                            icon = Icons.Default.AccountBalanceWallet,
                            label = "Account",
                            value = potentialTxn.potentialAccount?.formattedName ?: "Unknown Account",
                            onClick = null // Not editable
                        )
                        if (isExpense) {
                            HorizontalDivider()
                            DetailRow(
                                icon = Icons.Default.Category,
                                label = "Category",
                                value = selectedCategory?.name ?: "Select category",
                                onClick = { activeSheetContent = ApproveSheetContent.Category },
                                valueColor = if (selectedCategory == null) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.onSurface,
                                leadingIcon = { selectedCategory?.let { CategoryIcon(it, Modifier.size(24.dp)) } }
                            )
                        }
                        HorizontalDivider()
                        DetailRow(
                            icon = Icons.Default.NewLabel,
                            label = "Tags",
                            value = if (selectedTags.isEmpty()) "Add tags" else selectedTags.joinToString { it.name },
                            onClick = { activeSheetContent = ApproveSheetContent.Tags }
                        )
                        HorizontalDivider()
                        OutlinedTextField(
                            value = notes,
                            onValueChange = { notes = it },
                            modifier = Modifier.fillMaxWidth(),
                            placeholder = { Text("Add notes...") },
                            leadingIcon = { Icon(Icons.AutoMirrored.Filled.Notes, contentDescription = "Notes") },
                            colors = OutlinedTextFieldDefaults.colors(
                                unfocusedBorderColor = Color.Transparent,
                                focusedBorderColor = Color.Transparent,
                            )
                        )
                    }
                }
            }
            item {
                Row(modifier = Modifier.fillMaxWidth().padding(top = 8.dp), horizontalArrangement = Arrangement.spacedBy(16.dp)) {
                    OutlinedButton(onClick = { navController.popBackStack() }, modifier = Modifier.weight(1f)) {
                        Text("Cancel")
                    }
                    Button(
                        onClick = {
                            scope.launch {
                                val success = transactionViewModel.approveSmsTransaction(
                                    potentialTxn = potentialTxn,
                                    description = description,
                                    categoryId = selectedCategory?.id,
                                    notes = notes.takeIf { it.isNotBlank() },
                                    tags = selectedTags
                                )
                                if (success) {
                                    settingsViewModel.onTransactionApproved(potentialTxn.sourceSmsId)
                                    settingsViewModel.saveMerchantMapping(potentialTxn.smsSender, description)
                                    // --- FIX: Programmatically dismiss the source notification ---
                                    val notificationManager = NotificationManagerCompat.from(context)
                                    notificationManager.cancel(potentialTxn.sourceSmsId.toInt())
                                    navController.popBackStack()
                                }
                            }
                        },
                        modifier = Modifier.weight(1f),
                        enabled = isSaveEnabled,
                    ) { Text("Save Transaction") }
                }
            }
        }
    }

    // --- NEW: Bottom Sheet Logic ---
    if (activeSheetContent != null) {
        ModalBottomSheet(
            onDismissRequest = { activeSheetContent = null },
            sheetState = sheetState
        ) {
            when (activeSheetContent) {
                is ApproveSheetContent.Category -> ApproveCategoryPickerSheet(
                    items = categories,
                    onItemSelected = { selectedCategory = it; activeSheetContent = null }
                )
                is ApproveSheetContent.Tags -> ApproveTagPickerSheet(
                    allTags = allTags,
                    selectedTags = selectedTags,
                    onTagSelected = transactionViewModel::onTagSelected,
                    onAddNewTag = transactionViewModel::addTagOnTheGo,
                    onConfirm = { activeSheetContent = null }
                )
                else -> {}
            }
        }
    }
}


// --- NEW: Helper composables adapted from AddTransactionScreen ---

@Composable
private fun DetailRow(
    icon: ImageVector,
    label: String,
    value: String,
    onClick: (() -> Unit)?,
    valueColor: Color = MaterialTheme.colorScheme.onSurface,
    leadingIcon: (@Composable () -> Unit)? = null
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .then(if (onClick != null) Modifier.clickable(onClick = onClick) else Modifier)
            .padding(16.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        if (leadingIcon != null) {
            leadingIcon()
        } else {
            Icon(icon, contentDescription = label)
        }
        Spacer(Modifier.width(16.dp))
        Text(label, modifier = Modifier.weight(1f))
        Text(value, color = valueColor, fontWeight = FontWeight.SemiBold)
        if (onClick != null) {
            Icon(Icons.Default.ChevronRight, contentDescription = null, tint = MaterialTheme.colorScheme.onSurfaceVariant)
        }
    }
}

@Composable
private fun ApproveCategoryPickerSheet(
    items: List<Category>,
    onItemSelected: (Category) -> Unit
) {
    Column(modifier = Modifier.navigationBarsPadding()) {
        Text(
            "Select Category",
            style = MaterialTheme.typography.titleLarge,
            modifier = Modifier.padding(16.dp)
        )
        LazyVerticalGrid(
            columns = GridCells.Adaptive(minSize = 100.dp),
            contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp),
            horizontalArrangement = Arrangement.spacedBy(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            items(items) { category ->
                Column(
                    modifier = Modifier
                        .clip(RoundedCornerShape(12.dp))
                        .clickable { onItemSelected(category) }
                        .padding(vertical = 12.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    CategoryIcon(category, Modifier.size(48.dp))
                    Text(category.name, style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center)
                }
            }
        }
        Spacer(Modifier.height(16.dp))
    }
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
private fun ApproveTagPickerSheet(
    allTags: List<Tag>,
    selectedTags: Set<Tag>,
    onTagSelected: (Tag) -> Unit,
    onAddNewTag: (String) -> Unit,
    onConfirm: () -> Unit
) {
    var newTagName by remember { mutableStateOf("") }

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
            .navigationBarsPadding(),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("Manage Tags", style = MaterialTheme.typography.titleLarge)
        FlowRow(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(8.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            allTags.forEach { tag ->
                FilterChip(
                    selected = tag in selectedTags,
                    onClick = { onTagSelected(tag) },
                    label = { Text(tag.name) }
                )
            }
        }
        HorizontalDivider()
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            OutlinedTextField(
                value = newTagName,
                onValueChange = { newTagName = it },
                label = { Text("New Tag Name") },
                modifier = Modifier.weight(1f)
            )
            IconButton(
                onClick = {
                    onAddNewTag(newTagName)
                    newTagName = ""
                },
                enabled = newTagName.isNotBlank()
            ) {
                Icon(Icons.Default.Add, contentDescription = "Add New Tag")
            }
        }
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.End,
            verticalAlignment = Alignment.CenterVertically
        ) {
            TextButton(onClick = onConfirm) { Text("Cancel") }
            Spacer(modifier = Modifier.width(8.dp))
            Button(onClick = {
                if (newTagName.isNotBlank()) {
                    onAddNewTag(newTagName)
                }
                onConfirm()
            }) { Text("Done") }
        }
    }
}

@Composable
private fun CategoryIcon(category: Category, modifier: Modifier = Modifier) {
    Box(
        modifier = modifier
            .clip(CircleShape)
            .background(CategoryIconHelper.getIconBackgroundColor(category.colorKey)),
        contentAlignment = Alignment.Center
    ) {
        if (category.iconKey == "letter_default") {
            Text(
                text = category.name.firstOrNull()?.uppercase() ?: "?",
                fontWeight = FontWeight.Bold,
                color = Color.Black,
                fontSize = 22.sp
            )
        } else {
            Icon(
                imageVector = CategoryIconHelper.getIcon(category.iconKey),
                contentDescription = null,
                tint = Color.Black,
                modifier = Modifier.padding(12.dp)
            )
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/EditAccountScreen.kt ==================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import io.pm.finlight.AccountViewModel

@Composable
fun EditAccountScreen(
    navController: NavController,
    viewModel: AccountViewModel,
    accountId: Int,
) {
    val account by viewModel.getAccountById(accountId).collectAsState(initial = null)
    var accountName by remember { mutableStateOf("") }
    var accountType by remember { mutableStateOf("") }
    var showDeleteDialog by remember { mutableStateOf(false) }

    LaunchedEffect(account) {
        account?.let {
            accountName = it.name
            accountType = it.type
        }
    }

    account?.let { currentAccount ->
        Column(
            modifier =
                Modifier
                    .fillMaxSize()
                    .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp),
        ) {
            OutlinedTextField(
                value = accountName,
                onValueChange = { accountName = it },
                label = { Text("Account Name") },
                modifier = Modifier.fillMaxWidth(),
            )
            OutlinedTextField(
                value = accountType,
                onValueChange = { accountType = it },
                label = { Text("Account Type") },
                modifier = Modifier.fillMaxWidth(),
            )
            Spacer(modifier = Modifier.height(16.dp))
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(16.dp),
            ) {
                OutlinedButton(onClick = { navController.popBackStack() }, modifier = Modifier.weight(1f)) {
                    Text("Cancel")
                }
                Button(
                    onClick = {
                        val updatedAccount =
                            currentAccount.copy(
                                name = accountName,
                                type = accountType,
                            )
                        viewModel.updateAccount(updatedAccount)
                        navController.popBackStack()
                    },
                    modifier = Modifier.weight(1f),
                ) {
                    Text("Update Account")
                }
            }
            // The delete button can be moved here or kept in a TopAppBar action in MainActivity
        }
    }

    if (showDeleteDialog) {
        AlertDialog(
            onDismissRequest = { showDeleteDialog = false },
            title = { Text("Confirm Deletion") },
            text = { Text("Are you sure you want to delete this account? This will also delete all associated transactions.") },
            confirmButton = {
                Button(
                    onClick = {
                        account?.let {
                            viewModel.deleteAccount(it)
                            showDeleteDialog = false
                            navController.popBackStack()
                        }
                    },
                ) { Text("Delete") }
            },
            dismissButton = {
                TextButton(onClick = { showDeleteDialog = false }) { Text("Cancel") }
            },
        )
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/AddTransactionScreen.kt ==================
package io.pm.finlight.ui.screens

import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.BasicTextField
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.Notes
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import coil.compose.AsyncImage
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import io.pm.finlight.*
import io.pm.finlight.ui.components.TimePickerDialog
import java.text.SimpleDateFormat
import java.util.*

private sealed class AddSheetContent {
    object Account : AddSheetContent()
    object Category : AddSheetContent()
    object Tags : AddSheetContent()
}


@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)
@Composable
fun AddTransactionScreen(
    navController: NavController,
    viewModel: TransactionViewModel,
    isCsvEdit: Boolean = false,
    csvLineNumber: Int = -1,
    initialDataJson: String? = null
) {
    var description by remember { mutableStateOf("") }
    var amount by remember { mutableStateOf("") }
    var notes by remember { mutableStateOf("") }

    var transactionType by remember { mutableStateOf("expense") }

    val accounts by viewModel.allAccounts.collectAsState(initial = emptyList())
    var selectedAccount by remember { mutableStateOf<Account?>(null) }

    val categories by viewModel.allCategories.collectAsState(initial = emptyList())
    var selectedCategory by remember { mutableStateOf<Category?>(null) }

    var showDatePicker by remember { mutableStateOf(false) }
    var showTimePicker by remember { mutableStateOf(false) }
    val selectedDateTime by remember { mutableStateOf(Calendar.getInstance()) }

    val snackbarHostState = remember { SnackbarHostState() }
    val validationError by viewModel.validationError.collectAsState()

    var attachedImageUris by remember { mutableStateOf<List<Uri>>(emptyList()) }
    val imagePickerLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetMultipleContents()
    ) { uris: List<Uri> ->
        attachedImageUris = attachedImageUris + uris
    }

    var activeSheetContent by remember { mutableStateOf<AddSheetContent?>(null) }
    val sheetState = rememberModalBottomSheetState()

    val isExpense = transactionType == "expense"
    val isSaveEnabled = (description.isNotBlank() && amount.isNotBlank() && selectedAccount != null && (!isExpense || selectedCategory != null))

    val allTags by viewModel.allTags.collectAsState()
    val selectedTags by viewModel.selectedTags.collectAsState()

    // --- NEW: Logic to pre-fill the form when editing a CSV row ---
    LaunchedEffect(initialDataJson, accounts, categories) {
        if (isCsvEdit && initialDataJson != null) {
            try {
                val gson = Gson()
                val initialData: List<String> = gson.fromJson(initialDataJson, object : TypeToken<List<String>>() {}.type)
                val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())

                initialData.getOrNull(0)?.let {
                    try {
                        selectedDateTime.time = dateFormat.parse(it) ?: Date()
                    } catch (e: Exception) { /* Keep default date on parse error */ }
                }
                description = initialData.getOrElse(1) { "" }
                amount = initialData.getOrElse(2) { "" }
                transactionType = initialData.getOrElse(3) { "expense" }
                val categoryName = initialData.getOrElse(4) { "" }
                val accountName = initialData.getOrElse(5) { "" }
                notes = initialData.getOrElse(6) { "" }

                selectedCategory = categories.find { it.name.equals(categoryName, ignoreCase = true) }
                selectedAccount = accounts.find { it.name.equals(accountName, ignoreCase = true) }

            } catch (e: Exception) {
                // Log error or show a toast if JSON parsing fails
            }
        }
    }

    DisposableEffect(Unit) { onDispose { viewModel.clearSelectedTags() } }

    LaunchedEffect(validationError) { validationError?.let { snackbarHostState.showSnackbar(it); viewModel.clearError() } }

    Scaffold(
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier
                .padding(innerPadding)
                .fillMaxSize(),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                SegmentedButton(
                    options = listOf("Expense", "Income"),
                    selectedOption = transactionType.replaceFirstChar { it.uppercase() },
                    onOptionSelected = {
                        transactionType = it.lowercase(Locale.getDefault())
                        if (transactionType == "income") {
                            selectedCategory = null
                        }
                    }
                )
            }

            item {
                PrimaryInfoCard(
                    amount = amount,
                    onAmountChange = { amount = it },
                    description = description,
                    onDescriptionChange = { description = it }
                )
            }

            item {
                DetailsCard(
                    selectedAccount = selectedAccount,
                    onAccountClick = { activeSheetContent = AddSheetContent.Account },
                    selectedCategory = selectedCategory,
                    onCategoryClick = { activeSheetContent = AddSheetContent.Category },
                    isCategoryVisible = isExpense,
                    selectedDate = selectedDateTime.time,
                    onDateClick = { showDatePicker = true },
                    tags = selectedTags,
                    onTagsClick = { activeSheetContent = AddSheetContent.Tags },
                    notes = notes,
                    onNotesChange = { notes = it },
                    attachmentsCount = attachedImageUris.size,
                    onAttachmentsClick = { imagePickerLauncher.launch("image/*") }
                )
            }

            if (attachedImageUris.isNotEmpty()) {
                item {
                    LazyRow(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                        items(attachedImageUris) { uri ->
                            Box {
                                AsyncImage(
                                    model = uri,
                                    contentDescription = "Selected image",
                                    contentScale = ContentScale.Crop,
                                    modifier = Modifier
                                        .size(80.dp)
                                        .clip(RoundedCornerShape(8.dp))
                                )
                                IconButton(
                                    onClick = { attachedImageUris = attachedImageUris - uri },
                                    modifier = Modifier
                                        .align(Alignment.TopEnd)
                                        .padding(4.dp)
                                        .size(24.dp)
                                        .background(Color.Black.copy(alpha = 0.5f), CircleShape)
                                ) {
                                    Icon(
                                        Icons.Default.Close,
                                        contentDescription = "Remove attachment",
                                        tint = Color.White,
                                        modifier = Modifier.size(16.dp)
                                    )
                                }
                            }
                        }
                    }
                }
            }

            item {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(top = 8.dp),
                    horizontalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    OutlinedButton(onClick = { navController.popBackStack() }, modifier = Modifier.weight(1f)) {
                        Text("Cancel")
                    }
                    Button(
                        onClick = {
                            if (isCsvEdit) {
                                // --- NEW: Logic for returning edited CSV data ---
                                val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
                                val correctedData = listOf(
                                    dateFormat.format(selectedDateTime.time),
                                    description,
                                    amount,
                                    transactionType,
                                    selectedCategory?.name ?: "",
                                    selectedAccount?.name ?: "",
                                    notes
                                )
                                val gson = Gson()
                                navController.previousBackStackEntry
                                    ?.savedStateHandle
                                    ?.set("corrected_row", gson.toJson(correctedData))
                                navController.previousBackStackEntry
                                    ?.savedStateHandle
                                    ?.set("corrected_row_line", csvLineNumber)
                                navController.popBackStack()
                            } else {
                                // Original logic for adding a new transaction
                                val success = viewModel.addTransaction(
                                    description = description,
                                    categoryId = selectedCategory?.id,
                                    amountStr = amount,
                                    accountId = selectedAccount!!.id,
                                    notes = notes.takeIf { it.isNotBlank() },
                                    date = selectedDateTime.timeInMillis,
                                    transactionType = transactionType,
                                    sourceSmsId = null,
                                    sourceSmsHash = null,
                                    imageUris = attachedImageUris
                                )
                                if (success) navController.popBackStack()
                            }
                        },
                        modifier = Modifier.weight(1f),
                        enabled = isSaveEnabled
                    ) {
                        // --- UPDATED: Button text is now dynamic ---
                        Text(if (isCsvEdit) "Update Row" else "Save")
                    }
                }
            }
        }
    }

    if (activeSheetContent != null) {
        ModalBottomSheet(
            onDismissRequest = { activeSheetContent = null },
            sheetState = sheetState
        ) {
            when (activeSheetContent) {
                is AddSheetContent.Account -> AddAccountPickerSheet(
                    items = accounts,
                    onItemSelected = { selectedAccount = it; activeSheetContent = null },
                    onDismiss = { activeSheetContent = null }
                )
                is AddSheetContent.Category -> AddCategoryPickerSheet(
                    items = categories,
                    onItemSelected = { selectedCategory = it; activeSheetContent = null },
                    onDismiss = { activeSheetContent = null }
                )
                is AddSheetContent.Tags -> AddTagPickerSheet(
                    allTags = allTags,
                    selectedTags = selectedTags,
                    onTagSelected = viewModel::onTagSelected,
                    onAddNewTag = viewModel::addTagOnTheGo,
                    onConfirm = { activeSheetContent = null },
                    onDismiss = { activeSheetContent = null }
                )
                else -> {}
            }
        }
    }

    if (showDatePicker) {
        val datePickerState = rememberDatePickerState(initialSelectedDateMillis = selectedDateTime.timeInMillis)
        DatePickerDialog(
            onDismissRequest = { showDatePicker = false },
            confirmButton = {
                TextButton(onClick = {
                    datePickerState.selectedDateMillis?.let {
                        val cal = Calendar.getInstance().apply { timeInMillis = it }
                        selectedDateTime.set(Calendar.YEAR, cal.get(Calendar.YEAR))
                        selectedDateTime.set(Calendar.MONTH, cal.get(Calendar.MONTH))
                        selectedDateTime.set(Calendar.DAY_OF_MONTH, cal.get(Calendar.DAY_OF_MONTH))
                    }
                    showDatePicker = false
                    showTimePicker = true
                }) { Text("OK") }
            },
            dismissButton = { TextButton(onClick = { showDatePicker = false }) { Text("Cancel") } }
        ) { DatePicker(state = datePickerState) }
    }

    if (showTimePicker) {
        val timePickerState = rememberTimePickerState(
            initialHour = selectedDateTime.get(Calendar.HOUR_OF_DAY),
            initialMinute = selectedDateTime.get(Calendar.MINUTE)
        )
        TimePickerDialog(
            onDismissRequest = { showTimePicker = false },
            onConfirm = {
                selectedDateTime.set(Calendar.HOUR_OF_DAY, timePickerState.hour)
                selectedDateTime.set(Calendar.MINUTE, timePickerState.minute)
                showTimePicker = false
            }
        ) { TimePicker(state = timePickerState) }
    }
}

@Composable
fun PrimaryInfoCard(
    amount: String,
    onAmountChange: (String) -> Unit,
    description: String,
    onDescriptionChange: (String) -> Unit
) {
    Card(elevation = CardDefaults.cardElevation(2.dp)) {
        Column(Modifier.padding(16.dp)) {
            BasicTextField(
                value = amount,
                onValueChange = onAmountChange,
                modifier = Modifier.fillMaxWidth(),
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                cursorBrush = SolidColor(MaterialTheme.colorScheme.primary),
                textStyle = MaterialTheme.typography.displayMedium.copy(
                    textAlign = TextAlign.End,
                    color = MaterialTheme.colorScheme.onSurface
                ),
                decorationBox = { innerTextField ->
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.End,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "",
                            style = MaterialTheme.typography.headlineLarge,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Spacer(Modifier.width(8.dp))
                        Box(modifier = Modifier.weight(1f)) {
                            if (amount.isEmpty()) {
                                Text(
                                    "0.00",
                                    style = MaterialTheme.typography.displayMedium,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                                    modifier = Modifier.fillMaxWidth(),
                                    textAlign = TextAlign.End
                                )
                            }
                            innerTextField()
                        }
                    }
                }
            )
            HorizontalDivider(modifier = Modifier.padding(vertical = 12.dp))
            OutlinedTextField(
                value = description,
                onValueChange = onDescriptionChange,
                label = { Text("Description") },
                // --- FIX: Add a testTag for reliable UI testing ---
                modifier = Modifier.fillMaxWidth().testTag("description_input"),
                colors = OutlinedTextFieldDefaults.colors(
                    unfocusedBorderColor = Color.Transparent,
                    focusedBorderColor = Color.Transparent
                ),
                placeholder = { Text("What did you spend on?") }
            )
        }
    }
}

@Composable
fun DetailsCard(
    selectedAccount: Account?,
    onAccountClick: () -> Unit,
    selectedCategory: Category?,
    onCategoryClick: () -> Unit,
    isCategoryVisible: Boolean,
    selectedDate: Date,
    onDateClick: () -> Unit,
    tags: Set<Tag>,
    onTagsClick: () -> Unit,
    notes: String,
    onNotesChange: (String) -> Unit,
    attachmentsCount: Int,
    onAttachmentsClick: () -> Unit
) {
    val dateFormatter = remember { SimpleDateFormat("EEE, dd MMMM yyyy", Locale.getDefault()) }

    Card(elevation = CardDefaults.cardElevation(2.dp)) {
        Column {
            DetailRow(
                icon = Icons.Default.AccountBalanceWallet,
                label = "Account",
                value = selectedAccount?.name ?: "Select account",
                onClick = onAccountClick,
                valueColor = if (selectedAccount == null) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.onSurface
            )
            if (isCategoryVisible) {
                HorizontalDivider()
                DetailRow(
                    icon = Icons.Default.Category,
                    label = "Category",
                    value = selectedCategory?.name ?: "Select category",
                    onClick = onCategoryClick,
                    valueColor = if (selectedCategory == null) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.onSurface,
                    leadingIcon = { selectedCategory?.let { CategoryIcon(it, Modifier.size(24.dp)) } }
                )
            }
            HorizontalDivider()
            DetailRow(
                icon = Icons.Default.DateRange,
                label = "Date",
                value = dateFormatter.format(selectedDate),
                onClick = onDateClick
            )
            HorizontalDivider()
            DetailRow(
                icon = Icons.Default.NewLabel,
                label = "Tags",
                value = if (tags.isEmpty()) "Add tags" else tags.joinToString { it.name },
                onClick = onTagsClick
            )
            HorizontalDivider()
            DetailRow(
                icon = Icons.Default.Attachment,
                label = "Attach Photo",
                value = if (attachmentsCount > 0) "$attachmentsCount image(s)" else "Add receipt",
                onClick = onAttachmentsClick
            )
            HorizontalDivider()
            // Notes field directly inside the card
            OutlinedTextField(
                value = notes,
                onValueChange = onNotesChange,
                modifier = Modifier.fillMaxWidth(),
                placeholder = { Text("Add notes...") },
                leadingIcon = { Icon(Icons.AutoMirrored.Filled.Notes, contentDescription = "Notes") },
                colors = OutlinedTextFieldDefaults.colors(
                    unfocusedBorderColor = Color.Transparent,
                    focusedBorderColor = Color.Transparent,
                )
            )
        }
    }
}


@Composable
private fun DetailRow(
    icon: androidx.compose.ui.graphics.vector.ImageVector,
    label: String,
    value: String,
    onClick: () -> Unit,
    valueColor: Color = MaterialTheme.colorScheme.onSurface,
    leadingIcon: (@Composable () -> Unit)? = null
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick)
            .padding(16.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        if (leadingIcon != null) {
            leadingIcon()
        } else {
            Icon(icon, contentDescription = label)
        }
        Spacer(Modifier.width(16.dp))
        Text(label, modifier = Modifier.weight(1f))
        Text(value, color = valueColor, fontWeight = FontWeight.SemiBold)
        Icon(Icons.Default.ChevronRight, contentDescription = null, tint = MaterialTheme.colorScheme.onSurfaceVariant)
    }
}


@Composable
private fun SegmentedButton(
    options: List<String>,
    selectedOption: String,
    onOptionSelected: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier
            .fillMaxWidth()
            .clip(CircleShape)
            .background(MaterialTheme.colorScheme.surfaceVariant)
            .padding(4.dp)
    ) {
        options.forEach { option ->
            Button(
                onClick = { onOptionSelected(option) },
                modifier = Modifier.weight(1f),
                shape = CircleShape,
                colors = if (option == selectedOption) {
                    ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.primary)
                } else {
                    ButtonDefaults.buttonColors(containerColor = Color.Transparent, contentColor = MaterialTheme.colorScheme.onSurface)
                },
                elevation = if (option == selectedOption) ButtonDefaults.buttonElevation(defaultElevation = 2.dp) else null
            ) {
                Text(option)
            }
        }
    }
}


// --- Bottom Sheet Composables for Add Screen ---

@Composable
private fun AddAccountPickerSheet(
    items: List<Account>,
    onItemSelected: (Account) -> Unit,
    onDismiss: () -> Unit
) {
    Column(modifier = Modifier.navigationBarsPadding()) {
        Text(
            "Select Account",
            style = MaterialTheme.typography.titleLarge,
            modifier = Modifier.padding(16.dp)
        )
        LazyColumn {
            items(items) { item ->
                ListItem(
                    headlineContent = { Text(item.name) },
                    modifier = Modifier.clickable { onItemSelected(item) }
                )
            }
        }
        Spacer(Modifier.height(16.dp))
    }
}

@Composable
private fun AddCategoryPickerSheet(
    items: List<Category>,
    onItemSelected: (Category) -> Unit,
    onDismiss: () -> Unit
) {
    Column(modifier = Modifier.navigationBarsPadding()) {
        Text(
            "Select Category",
            style = MaterialTheme.typography.titleLarge,
            modifier = Modifier.padding(16.dp)
        )
        LazyVerticalGrid(
            columns = GridCells.Adaptive(minSize = 100.dp),
            contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp),
            horizontalArrangement = Arrangement.spacedBy(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            items(items) { category ->
                Column(
                    modifier = Modifier
                        .clip(RoundedCornerShape(12.dp))
                        .clickable { onItemSelected(category) }
                        .padding(vertical = 12.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    CategoryIcon(category, Modifier.size(48.dp))
                    Text(category.name, style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center)
                }
            }
        }
        Spacer(Modifier.height(16.dp))
    }
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
private fun AddTagPickerSheet(
    allTags: List<Tag>,
    selectedTags: Set<Tag>,
    onTagSelected: (Tag) -> Unit,
    onAddNewTag: (String) -> Unit,
    onConfirm: () -> Unit,
    onDismiss: () -> Unit,
) {
    var newTagName by remember { mutableStateOf("") }

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
            .navigationBarsPadding(),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("Manage Tags", style = MaterialTheme.typography.titleLarge)
        FlowRow(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(8.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            allTags.forEach { tag ->
                FilterChip(
                    selected = tag in selectedTags,
                    onClick = { onTagSelected(tag) },
                    label = { Text(tag.name) }
                )
            }
        }
        HorizontalDivider()
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            OutlinedTextField(
                value = newTagName,
                onValueChange = { newTagName = it },
                label = { Text("New Tag Name") },
                modifier = Modifier.weight(1f)
            )
            IconButton(
                onClick = {
                    onAddNewTag(newTagName)
                    newTagName = ""
                },
                enabled = newTagName.isNotBlank()
            ) {
                Icon(Icons.Default.Add, contentDescription = "Add New Tag")
            }
        }
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.End,
            verticalAlignment = Alignment.CenterVertically
        ) {
            TextButton(onClick = onDismiss) { Text("Cancel") }
            Spacer(modifier = Modifier.width(8.dp))
            Button(onClick = {
                if (newTagName.isNotBlank()) {
                    onAddNewTag(newTagName)
                }
                onConfirm() // This just dismisses the sheet now
            }) { Text("Done") }
        }
    }
}


@Composable
private fun CategoryIcon(category: Category, modifier: Modifier = Modifier) {
    Box(
        modifier = modifier
            .clip(CircleShape)
            .background(CategoryIconHelper.getIconBackgroundColor(category.colorKey)),
        contentAlignment = Alignment.Center
    ) {
        if (category.iconKey == "letter_default") {
            Text(
                text = category.name.firstOrNull()?.uppercase() ?: "?",
                fontWeight = FontWeight.Bold,
                color = Color.Black,
                fontSize = 22.sp
            )
        } else {
            Icon(
                imageVector = CategoryIconHelper.getIcon(category.iconKey),
                contentDescription = null,
                tint = Color.Black,
                modifier = Modifier.padding(12.dp)
            )
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/AccountListScreen.kt ==================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.clickable
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.ListItem
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.navigation.NavController
import io.pm.finlight.AccountViewModel

@Composable
fun AccountListScreen(
    navController: NavController,
    viewModel: AccountViewModel,
) {
    val accounts by viewModel.accountsWithBalance.collectAsState(initial = emptyList())

    LazyColumn {
        items(accounts) { account ->
            ListItem(
                headlineContent = { Text(account.account.name) },
                supportingContent = { Text("Balance: ${"%.2f".format(account.balance)}") },
                trailingContent = {
                    IconButton(onClick = { navController.navigate("edit_account/${account.account.id}") }) {
                        Icon(Icons.Filled.Edit, contentDescription = "Edit Account")
                    }
                },
                modifier = Modifier.clickable { navController.navigate("account_detail/${account.account.id}") },
            )
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/BudgetScreen.kt ==================
package io.pm.finlight.ui.screens

import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.tween
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Category
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material.icons.filled.MonetizationOn
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.drawscope.rotate
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import io.pm.finlight.Budget
import io.pm.finlight.BudgetViewModel
import io.pm.finlight.CategoryIconHelper
import io.pm.finlight.BudgetWithSpending
import kotlin.math.cos
import kotlin.math.sin

@Composable
fun GaugeChart(progress: Float) {
    val animatedProgress by animateFloatAsState(
        targetValue = progress.coerceIn(0f, 1f),
        animationSpec = tween(durationMillis = 1000)
    )

    Canvas(modifier = Modifier.size(150.dp)) {
        val arcSize = size.width
        val arcRadius = arcSize / 2
        val strokeWidth = 20f

        drawArc(
            color = Color.LightGray.copy(alpha = 0.3f),
            startAngle = 135f,
            sweepAngle = 270f,
            useCenter = false,
            topLeft = Offset.Zero,
            size = Size(arcSize, arcSize),
            style = Stroke(width = strokeWidth, cap = StrokeCap.Round)
        )

        drawArc(
            brush = Brush.horizontalGradient(
                colors = listOf(Color(0xFF00E5FF), Color(0xFF18A0FF), Color(0xFF0052D4))
            ),
            startAngle = 135f,
            sweepAngle = 270 * animatedProgress,
            useCenter = false,
            topLeft = Offset.Zero,
            size = Size(arcSize, arcSize),
            style = Stroke(width = strokeWidth, cap = StrokeCap.Round)
        )

        val angle = (135 + 270 * animatedProgress).coerceIn(135f, 405f)
        val angleInRadians = Math.toRadians(angle.toDouble())
        val lineStart = center
        val lineEnd = Offset(
            x = center.x + (arcRadius * 0.8f) * cos(angleInRadians).toFloat(),
            y = center.y + (arcRadius * 0.8f) * sin(angleInRadians).toFloat()
        )
        drawLine(
            color = Color.White,
            start = lineStart,
            end = lineEnd,
            strokeWidth = 8f,
            cap = StrokeCap.Round
        )
        drawCircle(color = Color.White, radius = 15f, center = center)
        drawCircle(color = Color.Black, radius = 10f, center = center)

        // --- NEW: Draw the stars ---
        for (i in 0..4) {
            val starProgress = i / 4f
            val starAngle = 135f + (270f * starProgress)
            val starAngleRad = Math.toRadians(starAngle.toDouble())
            val starRadius = arcRadius * 0.9f
            val starCenter = Offset(
                center.x + starRadius * cos(starAngleRad).toFloat(),
                center.y + starRadius * sin(starAngleRad).toFloat()
            )
            val starColor = if(animatedProgress >= starProgress) Color(0xFF81D4FA) else Color.Gray.copy(alpha = 0.5f)

            rotate(degrees = starAngle - 90, pivot = starCenter) {
                val path = Path().apply {
                    val outerR = 12f
                    val innerR = 5f
                    moveTo(starCenter.x, starCenter.y - outerR)
                    for (j in 1..4) {
                        val outerAngle = j * (360.0 / 5.0) + -90.0
                        val innerAngle = outerAngle + (360.0 / 10.0)
                        lineTo(
                            starCenter.x + (innerR * cos(Math.toRadians(innerAngle))).toFloat(),
                            starCenter.y + (innerR * sin(Math.toRadians(innerAngle))).toFloat()
                        )
                        lineTo(
                            starCenter.x + (outerR * cos(Math.toRadians(outerAngle + 360.0/5.0))).toFloat(),
                            starCenter.y + (outerR * sin(Math.toRadians(outerAngle + 360.0/5.0))).toFloat()
                        )
                    }
                    close()
                }
                drawPath(path, color = starColor)
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun BudgetScreen(
    navController: NavController,
    viewModel: BudgetViewModel = viewModel(),
) {
    val categoryBudgets by viewModel.budgetsForCurrentMonth.collectAsState()
    val overallBudget by viewModel.overallBudget.collectAsState()
    val totalSpending by viewModel.totalSpending.collectAsState()
    var showDeleteDialog by remember { mutableStateOf(false) }
    var budgetToDelete by remember { mutableStateOf<Budget?>(null) }
    var showOverallBudgetDialog by remember { mutableStateOf(false) }

    Column(modifier = Modifier.fillMaxSize()) {
        LazyColumn(modifier = Modifier.weight(1f), contentPadding = PaddingValues(16.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
            item {
                Row(modifier = Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
                    Column(modifier = Modifier.weight(1f)) {
                        Text("Set monthly budget", style = MaterialTheme.typography.headlineSmall)
                        Text("Setting a budget reduces expenditures about 10% on an average.", style = MaterialTheme.typography.bodySmall, color = Color.Gray)
                    }
                    GaugeChart(progress = if (overallBudget > 0) (totalSpending.toFloat() / overallBudget) else 0f)
                }
            }
            item {
                Card(modifier = Modifier.fillMaxWidth().clickable { showOverallBudgetDialog = true }, elevation = CardDefaults.cardElevation(2.dp)) {
                    Row(modifier = Modifier.fillMaxWidth().padding(16.dp), verticalAlignment = Alignment.CenterVertically) {
                        Icon(imageVector = Icons.Default.MonetizationOn, contentDescription = "Overall Budget", modifier = Modifier.size(40.dp))
                        Spacer(modifier = Modifier.width(16.dp))
                        Text("Overall budget", style = MaterialTheme.typography.titleMedium, modifier = Modifier.weight(1f))
                        Text("${"%,.0f".format(overallBudget)}", style = MaterialTheme.typography.titleLarge, fontWeight = FontWeight.Bold)
                    }
                }
            }
            item {
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                    Text("Category wise budget", style = MaterialTheme.typography.titleMedium, modifier = Modifier.padding(top = 16.dp))
                    IconButton(onClick = { navController.navigate("add_budget") }) {
                        Icon(Icons.Default.Add, contentDescription = "Add Category Budget")
                    }
                }
            }
            if (categoryBudgets.isEmpty()) {
                item {
                    Text("No category budgets set. Tap the '+' icon to add one.", modifier = Modifier.padding(16.dp), textAlign = TextAlign.Center, color = Color.Gray)
                }
            } else {
                items(categoryBudgets) { budgetWithSpending ->
                    CategoryBudgetItem(
                        budgetWithSpending = budgetWithSpending,
                        onEdit = { navController.navigate("edit_budget/${budgetWithSpending.budget.id}") },
                        onDelete = { budgetToDelete = budgetWithSpending.budget; showDeleteDialog = true }
                    )
                }
            }
        }
    }
    if (showDeleteDialog) {
        AlertDialog(
            onDismissRequest = { showDeleteDialog = false },
            title = { Text("Delete Budget?") },
            text = { Text("Are you sure you want to delete the budget for '${budgetToDelete?.categoryName}'?") },
            confirmButton = { Button(onClick = { budgetToDelete?.let { viewModel.deleteBudget(it) }; showDeleteDialog = false }, colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)) { Text("Delete") } },
            dismissButton = { TextButton(onClick = { showDeleteDialog = false }) { Text("Cancel") } },
        )
    }
    if (showOverallBudgetDialog) {
        EditOverallBudgetDialog(currentBudget = overallBudget, onDismiss = { showOverallBudgetDialog = false }, onConfirm = { newAmount -> viewModel.saveOverallBudget(newAmount); showOverallBudgetDialog = false })
    }
}

@Composable
fun EditOverallBudgetDialog(
    currentBudget: Float,
    onDismiss: () -> Unit,
    onConfirm: (String) -> Unit
) {
    var budgetInput by remember { mutableStateOf(if (currentBudget > 0) "%.0f".format(currentBudget) else "") }
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Set Overall Budget") },
        text = { OutlinedTextField(value = budgetInput, onValueChange = { budgetInput = it.filter { char -> char.isDigit() } }, label = { Text("Total Monthly Budget Amount") }, leadingIcon = { Text("") }, keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number), singleLine = true) },
        confirmButton = { Button(onClick = { onConfirm(budgetInput) }, enabled = budgetInput.isNotBlank()) { Text("Save") } },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } }
    )
}


@Composable
fun CategoryBudgetItem(
    budgetWithSpending: BudgetWithSpending,
    onEdit: () -> Unit,
    onDelete: () -> Unit
) {
    val progress = if (budgetWithSpending.budget.amount > 0) (budgetWithSpending.spent / budgetWithSpending.budget.amount).toFloat() else 0f
    Card(modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp), elevation = CardDefaults.cardElevation(2.dp)) {
        Row(modifier = Modifier.fillMaxWidth().padding(16.dp), verticalAlignment = Alignment.CenterVertically) {
            Box(
                modifier = Modifier
                    .size(40.dp)
                    .clip(CircleShape)
                    .background(
                        CategoryIconHelper.getIconBackgroundColor(
                            budgetWithSpending.colorKey ?: "gray_light"
                        )
                    ),
                contentAlignment = Alignment.Center
            ) {
                if (budgetWithSpending.iconKey == "letter_default") {
                    Text(
                        text = budgetWithSpending.budget.categoryName.firstOrNull()?.uppercase() ?: "?",
                        fontWeight = FontWeight.Bold,
                        fontSize = 18.sp,
                        color = Color.Black
                    )
                } else {
                    Icon(
                        imageVector = CategoryIconHelper.getIcon(budgetWithSpending.iconKey ?: "category"),
                        contentDescription = budgetWithSpending.budget.categoryName,
                        tint = Color.Black,
                        modifier = Modifier.size(22.dp)
                    )
                }
            }
            Spacer(modifier = Modifier.width(16.dp))
            Column(modifier = Modifier.weight(1f)) {
                Text(budgetWithSpending.budget.categoryName, style = MaterialTheme.typography.titleMedium)
                Spacer(modifier = Modifier.height(4.dp))
                LinearProgressIndicator(progress = { progress.coerceIn(0f, 1f) }, modifier = Modifier.fillMaxWidth())
                Spacer(modifier = Modifier.height(4.dp))
                Text("${"%,.0f".format(budgetWithSpending.spent)} of ${"%,.0f".format(budgetWithSpending.budget.amount)}", style = MaterialTheme.typography.bodySmall, color = Color.Gray)
            }
            Spacer(modifier = Modifier.width(16.dp))
            IconButton(onClick = onEdit) { Icon(Icons.Default.Edit, contentDescription = "Edit") }
            IconButton(onClick = onDelete) { Icon(Icons.Default.Delete, contentDescription = "Delete") }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/SettingsScreen.kt ==================
package io.pm.finlight.ui.screens

import android.Manifest
import android.content.pm.PackageManager
import android.util.Log
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ManageSearch
import androidx.compose.material.icons.automirrored.filled.Message
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.core.content.ContextCompat
import androidx.navigation.NavController
import io.pm.finlight.DataExportService
import io.pm.finlight.ScanResult
import io.pm.finlight.SettingsViewModel
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SettingsScreen(
    navController: NavController,
    viewModel: SettingsViewModel,
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val isScanning by viewModel.isScanning.collectAsState()

    var showDatePickerDialog by remember { mutableStateOf(false) }
    val smsScanStartDate by viewModel.smsScanStartDate.collectAsState()
    val dateFormatter = remember { SimpleDateFormat("dd MMMM, yyyy", Locale.getDefault()) }

    val isAppLockEnabled by viewModel.appLockEnabled.collectAsState()
    val isWeeklySummaryEnabled by viewModel.weeklySummaryEnabled.collectAsState()
    val isDailyReportEnabled by viewModel.dailyReportEnabled.collectAsState()
    val isUnknownTransactionPopupEnabled by viewModel.unknownTransactionPopupEnabled.collectAsState()
    val isBackupEnabled by viewModel.backupEnabled.collectAsState()
    var showSmsRationaleDialog by remember { mutableStateOf(false) }
    var hasSmsPermission by remember {
        mutableStateOf(
            ContextCompat.checkSelfPermission(context, Manifest.permission.READ_SMS) == PackageManager.PERMISSION_GRANTED &&
                    ContextCompat.checkSelfPermission(context, Manifest.permission.RECEIVE_SMS) == PackageManager.PERMISSION_GRANTED,
        )
    }
    var hasNotificationPermission by remember {
        mutableStateOf(
            ContextCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) == PackageManager.PERMISSION_GRANTED,
        )
    }

    LaunchedEffect(key1 = viewModel.scanEvent) {
        viewModel.scanEvent.collect { result ->
            if (result is ScanResult.Success) {
                if (result.count > 0) {
                    navController.navigate("review_sms_screen")
                } else {
                    Toast.makeText(context, "No new transactions found.", Toast.LENGTH_SHORT).show()
                }
            } else if (result is ScanResult.Error) {
                Toast.makeText(context, "An error occurred during scan.", Toast.LENGTH_SHORT).show()
            }
        }
    }

    val permissionLauncher =
        rememberLauncherForActivityResult(
            contract = ActivityResultContracts.RequestMultiplePermissions(),
        ) { permissions ->
            val allGranted = permissions.values.all { it }
            hasSmsPermission = allGranted
            if (!allGranted) {
                Toast.makeText(context, "Some SMS permissions were denied.", Toast.LENGTH_SHORT).show()
            }
        }

    val notificationPermissionLauncher =
        rememberLauncherForActivityResult(
            contract = ActivityResultContracts.RequestPermission(),
        ) { isGranted ->
            hasNotificationPermission = isGranted
        }

    val jsonFileSaverLauncher =
        rememberLauncherForActivityResult(
            contract = ActivityResultContracts.CreateDocument("application/json"),
            onResult = { uri ->
                uri?.let {
                    scope.launch {
                        val jsonString = DataExportService.exportToJsonString(context)
                        if (jsonString != null) {
                            try {
                                context.contentResolver.openOutputStream(it)?.use { outputStream ->
                                    outputStream.write(jsonString.toByteArray())
                                }
                                Toast.makeText(context, "Data exported successfully!", Toast.LENGTH_LONG).show()
                            } catch (e: Exception) {
                                Toast.makeText(context, "Error saving file.", Toast.LENGTH_LONG).show()
                            }
                        } else {
                            Toast.makeText(context, "Error exporting data.", Toast.LENGTH_LONG).show()
                        }
                    }
                }
            },
        )

    var showImportJsonDialog by remember { mutableStateOf(false) }
    var showImportCsvDialog by remember { mutableStateOf(false) }

    val csvFileSaverLauncher =
        rememberLauncherForActivityResult(
            contract = ActivityResultContracts.CreateDocument("text/csv"),
            onResult = { uri ->
                uri?.let {
                    scope.launch {
                        val csvString = DataExportService.exportToCsvString(context)
                        if (csvString != null) {
                            try {
                                context.contentResolver.openOutputStream(it)?.use { outputStream ->
                                    outputStream.write(csvString.toByteArray())
                                }
                                Toast.makeText(context, "CSV exported successfully!", Toast.LENGTH_LONG).show()
                            } catch (e: Exception) {
                                Toast.makeText(context, "Error saving CSV file.", Toast.LENGTH_LONG).show()
                            }
                        } else {
                            Toast.makeText(context, "Error exporting CSV data.", Toast.LENGTH_LONG).show()
                        }
                    }
                }
            },
        )

    val csvImportLauncher =
        rememberLauncherForActivityResult(
            contract = ActivityResultContracts.OpenDocument(),
            onResult = { uri ->
                uri?.let {
                    Log.d("SettingsScreen", "CSV file selected: $it. Starting validation.")
                    viewModel.validateCsvFile(it)
                    navController.navigate("csv_validation_screen")
                }
            },
        )

    val jsonImportLauncher =
        rememberLauncherForActivityResult(
            contract = ActivityResultContracts.OpenDocument(),
            onResult = { uri ->
                uri?.let {
                    scope.launch {
                        if (DataExportService.importDataFromJson(context, it)) {
                            Toast.makeText(context, "Data imported successfully! Please restart the app.", Toast.LENGTH_LONG).show()
                        } else {
                            Toast.makeText(context, "Failed to import data.", Toast.LENGTH_LONG).show()
                        }
                    }
                }
            },
        )

    if (showDatePickerDialog) {
        val datePickerState = rememberDatePickerState(initialSelectedDateMillis = smsScanStartDate)
        DatePickerDialog(
            onDismissRequest = { showDatePickerDialog = false },
            confirmButton = {
                TextButton(
                    onClick = {
                        datePickerState.selectedDateMillis?.let {
                            viewModel.saveSmsScanStartDate(it)
                        }
                        showDatePickerDialog = false
                    },
                ) { Text("OK") }
            },
            dismissButton = { TextButton(onClick = { showDatePickerDialog = false }) { Text("Cancel") } },
        ) {
            DatePicker(state = datePickerState)
        }
    }

    if (showSmsRationaleDialog) {
        AlertDialog(
            onDismissRequest = { showSmsRationaleDialog = false },
            title = { Text("Permission Required") },
            text = {
                Text(
                    "To automatically capture transactions, this app needs permission to read and receive SMS messages. Your data is processed only on your device and is never shared.",
                )
            },
            confirmButton = {
                Button(onClick = {
                    showSmsRationaleDialog = false
                    permissionLauncher.launch(
                        arrayOf(
                            Manifest.permission.READ_SMS,
                            Manifest.permission.RECEIVE_SMS,
                        ),
                    )
                }) {
                    Text("Continue")
                }
            },
            dismissButton = {
                TextButton(onClick = { showSmsRationaleDialog = false }) {
                    Text("Cancel")
                }
            },
        )
    }

    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(vertical = 9.dp),
    ) {
        item { SettingSectionHeader("App Management") }
        item {
            SettingsActionItem(
                text = "Manage Accounts",
                subtitle = "View, add, or edit your financial accounts.",
                icon = Icons.Default.AccountBalanceWallet,
                onClick = { navController.navigate("account_list") },
            )
        }
        item {
            SettingsActionItem(
                text = "Manage Budgets",
                subtitle = "Set and edit your overall and category-specific monthly budgets.",
                icon = Icons.Default.Savings,
                onClick = { navController.navigate("budget_screen") },
            )
        }
        item {
            SettingsActionItem(
                text = "Manage Categories",
                subtitle = "Add, edit, or remove transaction categories.",
                icon = Icons.Default.Category,
                onClick = { navController.navigate("category_list") },
            )
        }
        item {
            SettingsActionItem(
                text = "Manage Tags",
                subtitle = "Create and organize custom tags for transactions.",
                icon = Icons.Default.NewLabel,
                onClick = { navController.navigate("tag_management") },
            )
        }

        item { SettingSectionHeader("Security") }
        item {
            SettingsToggleItem(
                title = "Enable App Lock",
                subtitle = "Use biometrics or screen lock to secure the app.",
                icon = Icons.Default.Lock,
                checked = isAppLockEnabled,
                onCheckedChange = { viewModel.setAppLockEnabled(it) },
            )
        }

        item { SettingSectionHeader("Notifications & Automation") }
        item {
            SettingsToggleItem(
                title = "Enable Daily Summary Notification",
                subtitle = "Get a report of yesterday's spending each day.",
                icon = Icons.Default.NotificationsActive,
                checked = isDailyReportEnabled,
                onCheckedChange = { viewModel.setDailyReportEnabled(it) },
            )
        }
        item {
            SettingsToggleItem(
                title = "Weekly Summary Notification",
                subtitle = "Receive a summary of your finances every week.",
                icon = Icons.Default.CalendarToday,
                checked = isWeeklySummaryEnabled,
                onCheckedChange = { viewModel.setWeeklySummaryEnabled(it) },
            )
        }
        item {
            SettingsToggleItem(
                title = "Popup for Unknown Transactions",
                subtitle = "Show notification for SMS from new merchants.",
                icon = Icons.Default.Notifications,
                checked = isUnknownTransactionPopupEnabled,
                onCheckedChange = { viewModel.setUnknownTransactionPopupEnabled(it) },
            )
        }

        item { SettingSectionHeader("Permissions") }
        item {
            SettingsToggleItem(
                title = "SMS Access",
                subtitle = "Allow reading and receiving SMS for auto-detection.",
                icon = Icons.AutoMirrored.Filled.Message,
                checked = hasSmsPermission,
                onCheckedChange = { isChecked ->
                    if (isChecked && !hasSmsPermission) {
                        showSmsRationaleDialog = true
                    }
                },
                enabled = !hasSmsPermission,
            )
        }
        item {
            SettingsToggleItem(
                title = "Enable Notifications",
                subtitle = "Show alerts for new transactions and reminders.",
                icon = Icons.Default.Notifications,
                checked = hasNotificationPermission,
                onCheckedChange = {
                    if (!hasNotificationPermission) {
                        notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
                    }
                },
            )
        }

        item { SettingSectionHeader("SMS Scanning") }
        item {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp, vertical = 4.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Row(
                    modifier = Modifier
                        .weight(1f)
                        .clickable {
                            if (hasSmsPermission) {
                                showDatePickerDialog = true
                            } else {
                                showSmsRationaleDialog = true
                            }
                        },
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(Icons.Default.EventRepeat, contentDescription = null, modifier = Modifier.padding(end = 16.dp))
                    Column {
                        Text("Scan From Date", style = MaterialTheme.typography.bodyLarge)
                        Text(
                            "Current: ${dateFormatter.format(Date(smsScanStartDate))}",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
                OutlinedButton(
                    onClick = {
                        if (hasSmsPermission) {
                            if (!isScanning) {
                                viewModel.rescanSmsForReview(smsScanStartDate)
                            }
                        } else {
                            showSmsRationaleDialog = true
                        }
                    },
                    enabled = !isScanning
                ) {
                    Text("Scan")
                }
            }
        }
        item {
            SettingsActionItem(
                text = "Scan Full Inbox",
                subtitle = "Scan all messages to find transactions for review.",
                icon = Icons.AutoMirrored.Filled.ManageSearch,
                onClick = {
                    if (hasSmsPermission) {
                        if (!isScanning) {
                            viewModel.rescanSmsForReview(null) // Pass null for a full scan
                        }
                    } else {
                        showSmsRationaleDialog = true
                    }
                },
            )
        }
        item { SettingSectionHeader("Data Management") }
        // --- NEW: Toggle for Google Drive Backup ---
        item {
            SettingsToggleItem(
                title = "Enable Google Drive Backup",
                subtitle = "Automatically back up app data to your Google account.",
                icon = Icons.Default.CloudUpload,
                checked = isBackupEnabled,
                onCheckedChange = { viewModel.setBackupEnabled(it) },
            )
        }
        item {
            SettingsActionItem(
                text = "Export Data as JSON",
                subtitle = "Create a full backup of all your app data.",
                icon = Icons.Default.DataObject,
                onClick = {
                    val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
                    val fileName = "FinanceApp_Backup_${sdf.format(Date())}.json"
                    jsonFileSaverLauncher.launch(fileName)
                },
            )
        }

        item {
            SettingsActionItem(
                text = "Export Transactions as CSV",
                subtitle = "Save all transactions in a spreadsheet-compatible format.",
                icon = Icons.Default.GridOn,
                onClick = {
                    val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
                    val fileName = "FinanceApp_Transactions_${sdf.format(Date())}.csv"
                    csvFileSaverLauncher.launch(fileName)
                },
            )
        }

        item {
            SettingsActionItem(
                text = "Import from JSON",
                subtitle = "Restore your app data from a full backup file.",
                icon = Icons.Default.Download,
                onClick = { showImportJsonDialog = true },
            )
        }
        item {
            SettingsActionItem(
                text = "Import from CSV",
                subtitle = "Add new transactions from a CSV file.",
                icon = Icons.Default.PostAdd,
                onClick = { showImportCsvDialog = true },
            )
        }
    }

    if (isScanning) {
        Surface(
            modifier = Modifier.fillMaxSize(),
            color = MaterialTheme.colorScheme.scrim.copy(alpha = 0.5f),
        ) {
            Box(contentAlignment = Alignment.Center) {
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    CircularProgressIndicator()
                    Spacer(Modifier.height(16.dp))
                    Text("Scanning SMS Inbox...", style = MaterialTheme.typography.titleMedium)
                }
            }
        }
    }

    if (showImportCsvDialog) {
        AlertDialog(
            onDismissRequest = { showImportCsvDialog = false },
            title = { Text("Import from CSV?") },
            text = {
                Text(
                    "This will add transactions from the CSV file. If transactions already exist, this may create duplicates. Are you sure you want to continue?",
                )
            },
            confirmButton = {
                Button(onClick = {
                    showImportCsvDialog = false
                    csvImportLauncher.launch(arrayOf("text/csv", "text/comma-separated-values"))
                }) { Text("Continue") }
            },
            dismissButton = {
                TextButton(onClick = { showImportCsvDialog = false }) { Text("Cancel") }
            },
        )
    }

    if (showImportJsonDialog) {
        AlertDialog(
            onDismissRequest = { showImportJsonDialog = false },
            title = { Text("Import from JSON?") },
            text = { Text("This will DELETE all current data and replace it. This cannot be undone.") },
            confirmButton = {
                Button(onClick = {
                    showImportJsonDialog = false
                    jsonImportLauncher.launch(arrayOf("application/json"))
                }) { Text("Wipe and Import") }
            },
            dismissButton = {
                TextButton(onClick = { showImportJsonDialog = false }) { Text("Cancel") }
            },
        )
    }
}

@Composable
fun SettingSectionHeader(title: String) {
    Text(
        text = title.uppercase(),
        style = MaterialTheme.typography.labelSmall,
        color = MaterialTheme.colorScheme.primary,
        modifier = Modifier.padding(top = 24.dp, bottom = 8.dp, start = 16.dp, end = 16.dp),
    )
    HorizontalDivider()
}

@Composable
private fun SettingsToggleItem(
    title: String,
    subtitle: String,
    icon: ImageVector,
    checked: Boolean,
    onCheckedChange: (Boolean) -> Unit,
    enabled: Boolean = true,
) {
    ListItem(
        headlineContent = { Text(title) },
        supportingContent = { Text(subtitle, style = MaterialTheme.typography.bodySmall) },
        leadingContent = { Icon(icon, contentDescription = null) },
        trailingContent = { Switch(checked = checked, onCheckedChange = onCheckedChange, enabled = enabled) },
        modifier = Modifier.padding(horizontal = 16.dp),
    )
}

@Composable
private fun SettingsActionItem(
    text: String,
    subtitle: String? = null,
    icon: ImageVector,
    onClick: () -> Unit,
) {
    TextButton(
        onClick = onClick,
        modifier = Modifier.fillMaxWidth(),
        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 12.dp),
    ) {
        Row(
            verticalAlignment = Alignment.CenterVertically,
            modifier = Modifier.fillMaxWidth()
        ) {
            Icon(icon, contentDescription = null, modifier = Modifier.size(24.dp))
            Spacer(Modifier.width(16.dp))
            Column(modifier = Modifier.weight(1f)) {
                Text(text, style = MaterialTheme.typography.bodyLarge)
                if (subtitle != null) {
                    Text(
                        subtitle,
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/TransactionListScreen.kt ==================
package io.pm.finlight.ui.screens

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.tween
import androidx.compose.animation.expandVertically
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.pager.HorizontalPager
import androidx.compose.foundation.pager.PagerState
import androidx.compose.foundation.pager.rememberPagerState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material.icons.filled.ArrowDropUp
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.composed
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import io.pm.finlight.MonthlySummaryItem
import io.pm.finlight.TransactionViewModel
import io.pm.finlight.ui.components.TransactionList
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*
import kotlin.math.absoluteValue

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun TransactionListScreen(
    navController: NavController,
    viewModel: TransactionViewModel,
) {
    val tabs = listOf("Transactions", "Categories", "Merchants")
    val pagerState = rememberPagerState { tabs.size }
    val scope = rememberCoroutineScope()

    val transactions by viewModel.transactionsForSelectedMonth.collectAsState()
    val selectedMonth by viewModel.selectedMonth.collectAsState()
    val monthlySummaries by viewModel.monthlySummaries.collectAsState()
    val categorySpending by viewModel.categorySpendingForSelectedMonth.collectAsState()
    val merchantSpending by viewModel.merchantSpendingForSelectedMonth.collectAsState()
    val totalSpent by viewModel.monthlyExpenses.collectAsState()
    val totalIncome by viewModel.monthlyIncome.collectAsState()
    val budget by viewModel.overallMonthlyBudget.collectAsState()

    Column(modifier = Modifier.fillMaxSize()) {
        MonthlySummaryHeader(
            selectedMonth = selectedMonth,
            monthlySummaries = monthlySummaries,
            totalSpent = totalSpent,
            totalIncome = totalIncome,
            budget = budget,
            onMonthSelected = { viewModel.setSelectedMonth(it) }
        )
        TabRow(
            selectedTabIndex = pagerState.currentPage,
            indicator = { tabPositions ->
                TabRowDefaults.SecondaryIndicator(
                    Modifier.pagerTabIndicatorOffset(pagerState, tabPositions)
                )
            }
        ) {
            tabs.forEachIndexed { index, title ->
                Tab(
                    selected = pagerState.currentPage == index,
                    onClick = {
                        scope.launch {
                            pagerState.animateScrollToPage(index)
                        }
                    },
                    text = { Text(title) }
                )
            }
        }

        HorizontalPager(
            state = pagerState,
            modifier = Modifier.weight(1f)
        ) { page ->
            when (page) {
                0 -> {
                    TransactionList(transactions = transactions, navController = navController)
                }
                1 -> CategorySpendingScreen(spendingList = categorySpending)
                2 -> MerchantSpendingScreen(merchantList = merchantSpending)
            }
        }
    }
}

@Composable
fun MonthlySummaryHeader(
    selectedMonth: Calendar,
    monthlySummaries: List<MonthlySummaryItem>,
    totalSpent: Double,
    totalIncome: Double,
    budget: Float,
    onMonthSelected: (Calendar) -> Unit
) {
    val monthFormat = SimpleDateFormat("LLL", Locale.getDefault())
    // --- FIX: Corrected the illegal date format pattern ---
    val monthYearFormat = SimpleDateFormat("LLLL yyyy", Locale.getDefault())
    var showMonthScroller by remember { mutableStateOf(false) }

    val selectedTabIndex = monthlySummaries.indexOfFirst {
        it.calendar.get(Calendar.MONTH) == selectedMonth.get(Calendar.MONTH) &&
                it.calendar.get(Calendar.YEAR) == selectedMonth.get(Calendar.YEAR)
    }.coerceAtLeast(0)

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(bottom = 8.dp)
    ) {
        // Clickable header to toggle the month scroller
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clickable { showMonthScroller = !showMonthScroller }
                .padding(horizontal = 16.dp, vertical = 8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // This inner Row groups the Text and Icon together at the start
            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(
                    text = monthYearFormat.format(selectedMonth.time),
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold,
                )
                Icon(
                    imageVector = if (showMonthScroller) Icons.Default.ArrowDropUp else Icons.Default.ArrowDropDown,
                    contentDescription = if (showMonthScroller) "Hide month selector" else "Show month selector"
                )
            }
        }

        // Animated visibility for the horizontal month scroller
        AnimatedVisibility(
            visible = showMonthScroller,
            enter = expandVertically(),
            exit = shrinkVertically()
        ) {
            ScrollableTabRow(
                selectedTabIndex = selectedTabIndex,
                edgePadding = 16.dp,
                indicator = {}, // No indicator needed
                divider = {}
            ) {
                monthlySummaries.forEach { summaryItem ->
                    val isSelected = summaryItem.calendar.get(Calendar.MONTH) == selectedMonth.get(Calendar.MONTH) &&
                            summaryItem.calendar.get(Calendar.YEAR) == selectedMonth.get(Calendar.YEAR)
                    Tab(
                        selected = isSelected,
                        onClick = {
                            onMonthSelected(summaryItem.calendar)
                            showMonthScroller = false // Hide after selection
                        },
                        text = {
                            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                                Text(
                                    text = monthFormat.format(summaryItem.calendar.time),
                                    style = if (isSelected) MaterialTheme.typography.titleMedium else MaterialTheme.typography.titleSmall,
                                    fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal
                                )
                                Text(
                                    text = formatAmountInLakhs(summaryItem.totalSpent),
                                    style = MaterialTheme.typography.bodySmall,
                                    color = if (isSelected) MaterialTheme.colorScheme.onSurface else MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }
                        }
                    )
                }
            }
        }


        Spacer(Modifier.height(16.dp))

        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text("Total Spent", style = MaterialTheme.typography.labelMedium)
                Text(
                    "${"%,.2f".format(totalSpent)}",
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.error
                )
            }
            Column(horizontalAlignment = Alignment.End) {
                Text("Total Income", style = MaterialTheme.typography.labelMedium)
                Text(
                    "${"%,.2f".format(totalIncome)}",
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.primary
                )
            }
        }

        Spacer(Modifier.height(12.dp))

        if (budget > 0) {
            BudgetProgress(
                spent = totalSpent.toFloat(),
                budget = budget,
                modifier = Modifier.padding(horizontal = 16.dp)
            )
        } else {
            Text(
                text = "No budget set for this month.",
                style = MaterialTheme.typography.bodyMedium,
                textAlign = TextAlign.Center,
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp)
            )
        }
    }
}

private fun formatAmountInLakhs(amount: Double): String {
    if (amount < 1000) return "${"%,.0f".format(amount)}"
    if (amount < 100000) return "${"%,.0f".format(amount / 1000)}K"
    return "${"%.2f".format(amount / 100000.0)}L"
}


@Composable
fun BudgetProgress(spent: Float, budget: Float, modifier: Modifier = Modifier) {
    val progress = (spent / budget).coerceIn(0f, 1f)
    val animatedProgress by animateFloatAsState(targetValue = progress, animationSpec = tween(1000), label = "")

    val progressColor = when {
        progress > 1f -> MaterialTheme.colorScheme.error
        progress > 0.85f -> Color(0xFFFBC02D) // Amber
        else -> MaterialTheme.colorScheme.primary
    }

    Column(modifier = modifier.fillMaxWidth()) {
        LinearProgressIndicator(
            progress = { animatedProgress },
            modifier = Modifier
                .fillMaxWidth()
                .height(12.dp)
                .clip(CircleShape),
            color = progressColor,
            trackColor = MaterialTheme.colorScheme.surfaceVariant,
            strokeCap = StrokeCap.Round
        )
        Spacer(modifier = Modifier.height(8.dp))
        Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
            Text(
                text = "Spent: ${"%,.0f".format(spent)}",
                style = MaterialTheme.typography.bodySmall,
                fontWeight = FontWeight.SemiBold
            )
            Text(
                text = "Budget: ${"%,.0f".format(budget)}",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}


@Composable
fun PlaceholderTabContent(title: String) {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        contentAlignment = Alignment.Center
    ) {
        Text("Content for $title", style = MaterialTheme.typography.headlineMedium)
    }
}

private fun lerp(start: Dp, stop: Dp, fraction: Float): Dp {
    return Dp(start.value + (stop.value - start.value) * fraction)
}


@OptIn(ExperimentalFoundationApi::class)
fun Modifier.pagerTabIndicatorOffset(
    pagerState: PagerState,
    tabPositions: List<TabPosition>,
): Modifier = composed {
    if (tabPositions.isEmpty()) {
        this
    } else {
        val currentPage = pagerState.currentPage
        val fraction = pagerState.currentPageOffsetFraction.absoluteValue

        val currentTab = tabPositions[currentPage]
        val nextTab = tabPositions.getOrNull(currentPage + 1)

        val targetIndicatorOffset = if (nextTab != null) {
            lerp(currentTab.left, nextTab.left, fraction)
        } else {
            currentTab.left
        }

        val indicatorWidth = if (nextTab != null) {
            lerp(currentTab.width, nextTab.width, fraction)
        } else {
            currentTab.width
        }

        this.fillMaxWidth()
            .wrapContentSize(Alignment.BottomStart)
            .offset(x = targetIndicatorOffset)
            .width(indicatorWidth)
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/TransactionDetailScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/TransactionDetailScreen.kt
// REASON: REFACTORED - Replaced all editing dialogs with standardized ModalBottomSheets
// for a more consistent and modern user experience. Added an enhanced category
// picker with icons inside its bottom sheet.
// =================================================================================
package io.pm.finlight.ui.screens

import android.net.Uri
import android.util.Log
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.automirrored.filled.Notes
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardCapitalization
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import androidx.core.app.NotificationManagerCompat
import androidx.core.net.toUri
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import coil.compose.AsyncImage
import io.pm.finlight.*
import io.pm.finlight.ui.components.TimePickerDialog
import java.io.File
import java.text.SimpleDateFormat
import java.util.*

private const val TAG = "DetailScreenDebug"

/**
 * A sealed class to define the content type for the modal bottom sheet.
 * This allows for a type-safe way to determine which editor to display.
 */
private sealed class SheetContent {
    object Description : SheetContent()
    object Amount : SheetContent()
    object Notes : SheetContent()
    object Account : SheetContent()
    object Category : SheetContent()
    object Tags : SheetContent()
}

// --- BUG FIX: New sealed interface to represent the screen's state robustly ---
private sealed interface DetailScreenState {
    object Loading : DetailScreenState
    data class Success(val details: TransactionDetails) : DetailScreenState
    object Deleted : DetailScreenState
}


@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)
@Composable
fun TransactionDetailScreen(
    navController: NavController,
    transactionId: Int,
    viewModel: TransactionViewModel = viewModel()
) {
    Log.d(TAG, "Composing TransactionDetailScreen for transactionId: $transactionId")

    // --- BUG FIX: Use produceState for robust state management ---
    val screenState by produceState<DetailScreenState>(initialValue = DetailScreenState.Loading, transactionId) {
        viewModel.getTransactionDetailsById(transactionId).collect { details ->
            value = if (details != null) {
                Log.d(TAG, "produceState: Received data. Emitting Success.")
                DetailScreenState.Success(details)
            } else {
                // If the current state is already Success, it means the item was just deleted.
                if (value is DetailScreenState.Success) {
                    Log.d(TAG, "produceState: Received null after Success. Emitting Deleted.")
                    DetailScreenState.Deleted
                } else {
                    Log.d(TAG, "produceState: Received null initially. Emitting Loading.")
                    DetailScreenState.Loading
                }
            }
        }
    }

    val accounts by viewModel.allAccounts.collectAsState()
    val categories by viewModel.allCategories.collectAsState(initial = emptyList())
    val allTags by viewModel.allTags.collectAsState()
    val selectedTags by viewModel.selectedTags.collectAsState()
    val attachedImages by viewModel.transactionImages.collectAsState()

    var showMenu by remember { mutableStateOf(false) }
    var showDeleteDialog by remember { mutableStateOf(false) }
    var showDatePicker by remember { mutableStateOf(false) }
    var showTimePicker by remember { mutableStateOf(false) }
    var showImageViewer by remember { mutableStateOf<Uri?>(null) }
    var showImageDeleteDialog by remember { mutableStateOf<TransactionImage?>(null) }

    var activeSheetContent by remember { mutableStateOf<SheetContent?>(null) }
    val sheetState = rememberModalBottomSheetState()


    val imagePickerLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        uri?.let {
            viewModel.attachPhotoToTransaction(transactionId, it)
        }
    }

    val context = LocalContext.current
    LaunchedEffect(transactionId) {
        NotificationManagerCompat.from(context).cancel(transactionId)
        viewModel.loadTagsForTransaction(transactionId)
        viewModel.loadImagesForTransaction(transactionId)
    }

    DisposableEffect(Unit) {
        onDispose {
            viewModel.clearSelectedTags()
        }
    }

    // --- UI Rendering Logic based on the robust screenState ---
    when (val state = screenState) {
        is DetailScreenState.Loading -> {
            Log.d(TAG, "Rendering Loading state.")
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                CircularProgressIndicator()
            }
        }
        is DetailScreenState.Deleted -> {
            Log.d(TAG, "Rendering Deleted state. Navigating back.")
            // This effect will run once when the state becomes Deleted.
            LaunchedEffect(Unit) {
                navController.popBackStack()
            }
            // Show a blank screen while navigating away.
            Box(modifier = Modifier.fillMaxSize().background(MaterialTheme.colorScheme.background))
        }
        is DetailScreenState.Success -> {
            val details = state.details
            Log.d(TAG, "Rendering Success state for transaction: ${details.transaction.description}")
            val title = when (details.transaction.transactionType) {
                "expense" -> "Debit transaction"
                "income" -> "Credit transaction"
                else -> "Transaction Details"
            }
            val calendar = remember { Calendar.getInstance().apply { timeInMillis = details.transaction.date } }

            Scaffold(
                topBar = {
                    TopAppBar(
                        title = { Text(title) },
                        navigationIcon = {
                            IconButton(onClick = { navController.popBackStack() }) {
                                Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                            }
                        },
                        actions = {
                            IconButton(onClick = { showMenu = true }) {
                                Icon(Icons.Default.MoreVert, contentDescription = "More options")
                            }
                            DropdownMenu(
                                expanded = showMenu,
                                onDismissRequest = { showMenu = false }
                            ) {
                                DropdownMenuItem(
                                    text = { Text("Delete") },
                                    onClick = {
                                        showMenu = false
                                        showDeleteDialog = true
                                    },
                                    leadingIcon = { Icon(Icons.Default.Delete, contentDescription = "Delete") }
                                )
                            }
                        },
                        colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent)
                    )
                },
                containerColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f)
            ) { innerPadding ->
                LazyColumn(
                    modifier = Modifier
                        .padding(innerPadding)
                        .fillMaxSize(),
                    verticalArrangement = Arrangement.spacedBy(16.dp),
                    contentPadding = PaddingValues(start = 16.dp, end = 16.dp, bottom = 16.dp, top = 8.dp)
                ) {
                    item {
                        TransactionHeaderCard(
                            details = details,
                            onDescriptionClick = { activeSheetContent = SheetContent.Description },
                            onAmountClick = { activeSheetContent = SheetContent.Amount },
                            onCategoryClick = { activeSheetContent = SheetContent.Category },
                            onDateTimeClick = { showDatePicker = true }
                        )
                    }
                    item {
                        InfoCard(
                            icon = Icons.Default.AccountBalanceWallet,
                            label = "Account",
                            value = details.accountName ?: "N/A",
                            onClick = { activeSheetContent = SheetContent.Account }
                        )
                    }
                    item {
                        InfoCard(
                            icon = Icons.AutoMirrored.Filled.Notes,
                            label = "Notes",
                            value = details.transaction.notes ?: "Tap to add",
                            onClick = { activeSheetContent = SheetContent.Notes }
                        )
                    }
                    item {
                        Card(
                            modifier = Modifier.fillMaxWidth(),
                            elevation = CardDefaults.cardElevation(2.dp),
                            onClick = { activeSheetContent = SheetContent.Tags }
                        ) {
                            Row(
                                modifier = Modifier.padding(16.dp),
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Icon(Icons.Default.NewLabel, contentDescription = null, tint = MaterialTheme.colorScheme.onSurfaceVariant)
                                Spacer(modifier = Modifier.width(16.dp))
                                Column(modifier = Modifier.weight(1f)) {
                                    Text("Tags", style = MaterialTheme.typography.labelLarge, color = MaterialTheme.colorScheme.onSurfaceVariant)
                                    if (selectedTags.isEmpty()) {
                                        Text("Tap to add tags")
                                    } else {
                                        FlowRow(
                                            horizontalArrangement = Arrangement.spacedBy(8.dp),
                                            verticalArrangement = Arrangement.spacedBy(4.dp)
                                        ) {
                                            selectedTags.forEach { tag ->
                                                AssistChip(onClick = {}, label = { Text(tag.name) })
                                            }
                                        }
                                    }
                                }
                                Icon(Icons.Default.Add, contentDescription = "Add Tag")
                            }
                        }
                    }

                    item {
                        InfoCard(
                            icon = Icons.Default.Attachment,
                            label = "Attachments",
                            value = if (attachedImages.isEmpty()) "Tap to add a receipt or photo" else "${attachedImages.size} image(s) attached",
                            onClick = { imagePickerLauncher.launch("image/*") }
                        )
                    }

                    if (attachedImages.isNotEmpty()) {
                        item {
                            LazyRow(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                                items(attachedImages) { image ->
                                    Box {
                                        AsyncImage(
                                            model = File(image.imageUri),
                                            contentDescription = "Transaction Attachment",
                                            contentScale = ContentScale.Crop,
                                            modifier = Modifier
                                                .size(80.dp)
                                                .clip(RoundedCornerShape(8.dp))
                                                .clickable { showImageViewer = File(image.imageUri).toUri() }
                                        )
                                        IconButton(
                                            onClick = { showImageDeleteDialog = image },
                                            modifier = Modifier
                                                .align(Alignment.TopEnd)
                                                .padding(4.dp)
                                                .size(24.dp)
                                                .background(Color.Black.copy(alpha = 0.5f), CircleShape)
                                        ) {
                                            Icon(
                                                Icons.Default.Close,
                                                contentDescription = "Delete Attachment",
                                                tint = Color.White,
                                                modifier = Modifier.size(16.dp)
                                            )
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (activeSheetContent != null) {
                    ModalBottomSheet(
                        onDismissRequest = { activeSheetContent = null },
                        sheetState = sheetState
                    ) {
                        TransactionEditSheetContent(
                            sheetContent = activeSheetContent!!,
                            details = details,
                            viewModel = viewModel,
                            accounts = accounts,
                            categories = categories,
                            allTags = allTags,
                            selectedTags = selectedTags,
                            onDismiss = { activeSheetContent = null }
                        )
                    }
                }


                if (showDatePicker) {
                    val datePickerState = rememberDatePickerState(initialSelectedDateMillis = calendar.timeInMillis)
                    DatePickerDialog(
                        onDismissRequest = { showDatePicker = false },
                        confirmButton = {
                            TextButton(onClick = {
                                datePickerState.selectedDateMillis?.let {
                                    calendar.timeInMillis = it
                                }
                                showDatePicker = false
                                showTimePicker = true
                            }) { Text("OK") }
                        }
                    ) { DatePicker(state = datePickerState) }
                }
                if (showTimePicker) {
                    val timePickerState = rememberTimePickerState(initialHour = calendar.get(Calendar.HOUR_OF_DAY), initialMinute = calendar.get(Calendar.MINUTE))
                    TimePickerDialog(
                        onDismissRequest = { showTimePicker = false },
                        onConfirm = {
                            calendar.set(Calendar.HOUR_OF_DAY, timePickerState.hour)
                            calendar.set(Calendar.MINUTE, timePickerState.minute)
                            viewModel.updateTransactionDate(transactionId, calendar.timeInMillis)
                            showTimePicker = false
                        }
                    ) { TimePicker(state = timePickerState) }
                }

                if (showDeleteDialog) {
                    AlertDialog(
                        onDismissRequest = { showDeleteDialog = false },
                        title = { Text("Delete Transaction?") },
                        text = { Text("Are you sure you want to permanently delete this transaction? This action cannot be undone.") },
                        confirmButton = {
                            Button(
                                onClick = {
                                    viewModel.deleteTransaction(details.transaction)
                                    showDeleteDialog = false
                                },
                                colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
                            ) { Text("Delete") }
                        },
                        dismissButton = { TextButton(onClick = { showDeleteDialog = false }) { Text("Cancel") } }
                    )
                }

                if (showImageViewer != null) {
                    Dialog(onDismissRequest = { showImageViewer = null }) {
                        AsyncImage(
                            model = showImageViewer,
                            contentDescription = "Full screen image",
                            modifier = Modifier
                                .fillMaxWidth()
                                .clip(RoundedCornerShape(16.dp))
                        )
                    }
                }

                if (showImageDeleteDialog != null) {
                    AlertDialog(
                        onDismissRequest = { showImageDeleteDialog = null },
                        title = { Text("Delete Attachment?") },
                        text = { Text("Are you sure you want to delete this attachment? This action cannot be undone.") },
                        confirmButton = {
                            Button(
                                onClick = {
                                    viewModel.deleteTransactionImage(showImageDeleteDialog!!)
                                    showImageDeleteDialog = null
                                },
                                colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
                            ) { Text("Delete") }
                        },
                        dismissButton = {
                            TextButton(onClick = { showImageDeleteDialog = null }) { Text("Cancel") }
                        }
                    )
                }
            }
        }
    }
}

/**
 * A composable that renders the appropriate editor inside the modal bottom sheet
 * based on the [SheetContent] type.
 */
@Composable
private fun TransactionEditSheetContent(
    sheetContent: SheetContent,
    details: TransactionDetails,
    viewModel: TransactionViewModel,
    accounts: List<Account>,
    categories: List<Category>,
    allTags: List<Tag>,
    selectedTags: Set<Tag>,
    onDismiss: () -> Unit
) {
    val transactionId = details.transaction.id

    when (sheetContent) {
        is SheetContent.Description -> {
            EditTextFieldSheet(
                title = "Edit Description",
                initialValue = details.transaction.description,
                onConfirm = { viewModel.updateTransactionDescription(transactionId, it) },
                onDismiss = onDismiss
            )
        }
        is SheetContent.Amount -> {
            EditTextFieldSheet(
                title = "Edit Amount",
                initialValue = "%.2f".format(details.transaction.amount),
                keyboardType = KeyboardType.Number,
                onConfirm = { viewModel.updateTransactionAmount(transactionId, it) },
                onDismiss = onDismiss
            )
        }
        is SheetContent.Notes -> {
            EditTextFieldSheet(
                title = "Edit Notes",
                initialValue = details.transaction.notes ?: "",
                onConfirm = { viewModel.updateTransactionNotes(transactionId, it) },
                onDismiss = onDismiss
            )
        }
        is SheetContent.Account -> {
            PickerSheet(
                title = "Select Account",
                items = accounts,
                getItemName = { (it as Account).name },
                onItemSelected = { viewModel.updateTransactionAccount(transactionId, (it as Account).id) },
                onDismiss = onDismiss
            )
        }
        is SheetContent.Category -> {
            CategoryPickerSheet(
                title = "Select Category",
                items = categories,
                onItemSelected = { viewModel.updateTransactionCategory(transactionId, it.id) },
                onDismiss = onDismiss
            )
        }
        is SheetContent.Tags -> {
            TagPickerSheet(
                allTags = allTags,
                selectedTags = selectedTags,
                onTagSelected = viewModel::onTagSelected,
                onAddNewTag = viewModel::addTagOnTheGo,
                onConfirm = {
                    viewModel.updateTagsForTransaction(transactionId)
                    onDismiss()
                },
                onDismiss = onDismiss
            )
        }
    }
}


/**
 * A generic bottom sheet for editing a simple text field.
 */
@Composable
private fun EditTextFieldSheet(
    title: String,
    initialValue: String,
    keyboardType: KeyboardType = KeyboardType.Text,
    onConfirm: (String) -> Unit,
    onDismiss: () -> Unit
) {
    var text by remember { mutableStateOf(initialValue) }

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text(title, style = MaterialTheme.typography.titleLarge)
        OutlinedTextField(
            value = text,
            onValueChange = { text = it },
            label = { Text("Value") },
            keyboardOptions = KeyboardOptions(
                keyboardType = keyboardType,
                capitalization = if (keyboardType == KeyboardType.Text) KeyboardCapitalization.Sentences else KeyboardCapitalization.None
            ),
            singleLine = true,
            modifier = Modifier.fillMaxWidth().testTag("value_input")
        )
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.End,
            verticalAlignment = Alignment.CenterVertically
        ) {
            TextButton(onClick = onDismiss) { Text("Cancel") }
            Spacer(modifier = Modifier.width(8.dp))
            Button(onClick = {
                onConfirm(text)
                onDismiss()
            }) { Text("Save") }
        }
    }
}

/**
 * A generic bottom sheet for picking an item from a list.
 */
@Composable
private fun <T> PickerSheet(
    title: String,
    items: List<T>,
    getItemName: (T) -> String,
    onItemSelected: (T) -> Unit,
    onDismiss: () -> Unit
) {
    Column(modifier = Modifier.navigationBarsPadding()) {
        Text(
            title,
            style = MaterialTheme.typography.titleLarge,
            modifier = Modifier.padding(16.dp)
        )
        LazyColumn {
            items(items) { item ->
                ListItem(
                    headlineContent = { Text(getItemName(item)) },
                    modifier = Modifier.clickable {
                        onItemSelected(item)
                        onDismiss()
                    }
                )
            }
        }
        Spacer(Modifier.height(16.dp))
    }
}

/**
 * An enhanced category picker bottom sheet that shows category icons in a grid.
 */
@Composable
private fun CategoryPickerSheet(
    title: String,
    items: List<Category>,
    onItemSelected: (Category) -> Unit,
    onDismiss: () -> Unit
) {
    Column(modifier = Modifier.navigationBarsPadding()) {
        Text(
            title,
            style = MaterialTheme.typography.titleLarge,
            modifier = Modifier.padding(16.dp)
        )
        LazyVerticalGrid(
            columns = GridCells.Adaptive(minSize = 100.dp),
            contentPadding = PaddingValues(horizontal = 16.dp),
            horizontalArrangement = Arrangement.spacedBy(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            items(items) { category ->
                Column(
                    modifier = Modifier
                        .clip(RoundedCornerShape(12.dp))
                        .clickable {
                            onItemSelected(category)
                            onDismiss()
                        }
                        .padding(vertical = 12.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    CategoryIconDisplay(category)
                    Text(category.name, style = MaterialTheme.typography.bodyMedium)
                }
            }
        }
        Spacer(Modifier.height(16.dp))
    }
}

/**
 * A bottom sheet for selecting and creating tags.
 */
@OptIn(ExperimentalLayoutApi::class)
@Composable
private fun TagPickerSheet(
    allTags: List<Tag>,
    selectedTags: Set<Tag>,
    onTagSelected: (Tag) -> Unit,
    onAddNewTag: (String) -> Unit,
    onConfirm: () -> Unit,
    onDismiss: () -> Unit,
) {
    var newTagName by remember { mutableStateOf("") }

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("Manage Tags", style = MaterialTheme.typography.titleLarge)
        FlowRow(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(8.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            allTags.forEach { tag ->
                FilterChip(
                    selected = tag in selectedTags,
                    onClick = { onTagSelected(tag) },
                    label = { Text(tag.name) }
                )
            }
        }
        HorizontalDivider()
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            OutlinedTextField(
                value = newTagName,
                onValueChange = { newTagName = it },
                label = { Text("New Tag Name") },
                modifier = Modifier.weight(1f)
            )
            IconButton(
                onClick = {
                    onAddNewTag(newTagName)
                    newTagName = ""
                },
                enabled = newTagName.isNotBlank()
            ) {
                Icon(Icons.Default.Add, contentDescription = "Add New Tag")
            }
        }
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.End,
            verticalAlignment = Alignment.CenterVertically
        ) {
            TextButton(onClick = onDismiss) { Text("Cancel") }
            Spacer(modifier = Modifier.width(8.dp))
            Button(onClick = {
                if (newTagName.isNotBlank()) {
                    onAddNewTag(newTagName)
                }
                onConfirm()
            }) { Text("Save") }
        }
    }
}

// --- Helper Composables (mostly unchanged, but kept for context) ---

@Composable
private fun CategoryIconDisplay(category: Category) {
    Box(
        modifier = Modifier
            .size(48.dp)
            .clip(CircleShape)
            .background(CategoryIconHelper.getIconBackgroundColor(category.colorKey)),
        contentAlignment = Alignment.Center
    ) {
        if (category.iconKey == "letter_default") {
            Text(
                text = category.name.firstOrNull()?.uppercase() ?: "?",
                color = Color.Black,
                fontWeight = FontWeight.Bold,
                fontSize = 22.sp
            )
        } else {
            Icon(
                imageVector = CategoryIconHelper.getIcon(category.iconKey),
                contentDescription = category.name,
                tint = Color.Black,
                modifier = Modifier.size(24.dp)
            )
        }
    }
}


@Composable
private fun TransactionHeaderCard(
    details: TransactionDetails,
    onDescriptionClick: () -> Unit,
    onAmountClick: () -> Unit,
    onCategoryClick: () -> Unit,
    onDateTimeClick: () -> Unit,
) {
    val dateFormatter = remember { SimpleDateFormat("EEE, dd MMMM yyyy, h:mm a", Locale.getDefault()) }

    Card(
        modifier = Modifier.fillMaxWidth(),
        shape = RoundedCornerShape(24.dp),
        elevation = CardDefaults.cardElevation(4.dp)
    ) {
        Column(
            modifier = Modifier
                .background(
                    brush = Brush.verticalGradient(
                        colors = listOf(
                            MaterialTheme.colorScheme.surface.copy(alpha = 0.5f),
                            MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.8f)
                        )
                    )
                )
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            Text(
                text = details.transaction.description,
                style = MaterialTheme.typography.headlineSmall,
                color = MaterialTheme.colorScheme.onSurface,
                modifier = Modifier.clickable(onClick = onDescriptionClick)
            )

            Text(
                text = "${"%,.2f".format(details.transaction.amount)}",
                fontSize = 48.sp,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.onSurface,
                modifier = Modifier.clickable(onClick = onAmountClick)
            )

            ChipWithIcon(
                text = details.categoryName ?: "Uncategorized",
                icon = CategoryIconHelper.getIcon(details.categoryIconKey ?: "category"),
                colorKey = details.categoryColorKey ?: "gray_light",
                onClick = onCategoryClick,
                category = details.toCategory()
            )

            Spacer(modifier = Modifier.height(8.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = dateFormatter.format(Date(details.transaction.date)),
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.clickable(onClick = onDateTimeClick)
                )

                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(4.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Info,
                        contentDescription = "Transaction Source",
                        tint = MaterialTheme.colorScheme.onSurfaceVariant,
                        modifier = Modifier.size(16.dp)
                    )
                    Text(
                        text = details.transaction.source,
                        style = MaterialTheme.typography.labelSmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }
        }
    }
}

// Extension function to convert TransactionDetails to a Category object
private fun TransactionDetails.toCategory(): Category {
    return Category(
        id = this.transaction.categoryId ?: 0,
        name = this.categoryName ?: "Uncategorized",
        iconKey = this.categoryIconKey ?: "category",
        colorKey = this.categoryColorKey ?: "gray_light"
    )
}

@Composable
private fun ChipWithIcon(
    text: String,
    icon: androidx.compose.ui.graphics.vector.ImageVector,
    colorKey: String,
    onClick: () -> Unit,
    category: Category
) {
    Row(
        modifier = Modifier
            .clip(CircleShape)
            .clickable(onClick = onClick)
            .background(CategoryIconHelper.getIconBackgroundColor(colorKey).copy(alpha = 0.9f))
            .padding(horizontal = 12.dp, vertical = 6.dp),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        if (category.iconKey == "letter_default") {
            Text(
                text = category.name.firstOrNull()?.uppercase() ?: "?",
                color = Color.Black,
                fontWeight = FontWeight.Bold,
                fontSize = 16.sp
            )
        } else {
            Icon(
                imageVector = icon,
                contentDescription = null,
                tint = Color.Black,
                modifier = Modifier.size(20.dp)
            )
        }
        Text(
            text = text,
            fontWeight = FontWeight.SemiBold,
            color = Color.Black,
            style = MaterialTheme.typography.bodyMedium
        )
    }
}

@Composable
fun InfoCard(
    icon: androidx.compose.ui.graphics.vector.ImageVector,
    label: String,
    value: String,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(2.dp),
        onClick = onClick,
        enabled = onClick != {}
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Icon(icon, contentDescription = null, tint = MaterialTheme.colorScheme.onSurfaceVariant)
            Column(modifier = Modifier.weight(1f)) {
                Text(label, style = MaterialTheme.typography.labelLarge, color = MaterialTheme.colorScheme.onSurfaceVariant)
                Text(value, style = MaterialTheme.typography.bodyLarge)
            }
            Icon(Icons.Default.Edit, contentDescription = "Edit")
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/CategorySpendingScreen.kt ==================
package io.pm.finlight.ui.screens

import android.graphics.Color
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.viewinterop.AndroidView
import com.github.mikephil.charting.charts.PieChart
import com.github.mikephil.charting.data.PieData
import com.github.mikephil.charting.data.PieDataSet
import com.github.mikephil.charting.data.PieEntry
import com.github.mikephil.charting.formatter.PercentFormatter
import io.pm.finlight.CategoryIconHelper
import io.pm.finlight.CategorySpending

@Composable
fun CategorySpendingScreen(spendingList: List<CategorySpending>) {
    if (spendingList.isEmpty()) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Text("No spending data for this month.")
        }
        return
    }

    val totalSpending = spendingList.sumOf { it.totalAmount }
    val pieData = createPieData(spendingList)

    LazyColumn(
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        item {
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(4.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text("Category Breakdown", style = MaterialTheme.typography.titleLarge)
                    Spacer(Modifier.height(16.dp))
                    AndroidView(
                        factory = { context ->
                            PieChart(context).apply {
                                description.isEnabled = false
                                isDrawHoleEnabled = true
                                setHoleColor(Color.TRANSPARENT)
                                setEntryLabelColor(Color.BLACK)
                                setEntryLabelTextSize(12f)
                                legend.isEnabled = false
                                setUsePercentValues(true)
                            }
                        },
                        update = { chart ->
                            chart.data = pieData
                            chart.invalidate()
                        },
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(250.dp)
                    )
                }
            }
        }

        items(spendingList) { categorySpending ->
            CategorySpendingCard(
                categorySpending = categorySpending,
                totalSpending = totalSpending
            )
        }
    }
}

@Composable
fun CategorySpendingCard(categorySpending: CategorySpending, totalSpending: Double) {
    val percentage = (categorySpending.totalAmount / totalSpending * 100)

    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(2.dp)
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Box(
                modifier = Modifier
                    .size(40.dp)
                    .clip(CircleShape)
                    .background(
                        CategoryIconHelper.getIconBackgroundColor(
                            categorySpending.colorKey ?: "gray_light"
                        )
                    ),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = CategoryIconHelper.getIcon(categorySpending.iconKey ?: "category"),
                    contentDescription = categorySpending.categoryName,
                    tint = androidx.compose.ui.graphics.Color.Black,
                    modifier = Modifier.size(22.dp)
                )
            }
            Column(modifier = Modifier.weight(1f)) {
                Text(categorySpending.categoryName, style = MaterialTheme.typography.titleMedium)
                Text(
                    "${"%.1f".format(percentage)}% of total spending",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            Text(
                "${"%,.2f".format(categorySpending.totalAmount)}",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold
            )
        }
    }
}

// --- FIX: Removed 'private' modifier to make the function accessible from other files ---
fun createPieData(spendingList: List<CategorySpending>): PieData {
    val entries = spendingList.map {
        PieEntry(it.totalAmount.toFloat(), it.categoryName)
    }
    val colors = spendingList.map {
        (CategoryIconHelper.getIconBackgroundColor(it.colorKey ?: "gray_light")).toArgb()
    }
    val dataSet = PieDataSet(entries, "Spending").apply {
        this.colors = colors
        valueFormatter = PercentFormatter()
        valueTextSize = 12f
        valueTextColor = Color.BLACK
    }
    return PieData(dataSet)
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/AccountDetailScreen.kt ==================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Divider
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import io.pm.finlight.AccountViewModel
import io.pm.finlight.ui.components.AccountTransactionItem

@Composable
fun AccountDetailScreen(
    navController: NavController,
    viewModel: AccountViewModel,
    accountId: Int,
) {
    val account by viewModel.getAccountById(accountId).collectAsState(initial = null)
    val balance by viewModel.getAccountBalance(accountId).collectAsState(initial = 0.0)
    val transactions by viewModel.getTransactionsForAccount(accountId).collectAsState(initial = emptyList())

    Column(
        modifier =
            Modifier
                .padding(horizontal = 16.dp)
                .fillMaxSize(),
    ) {
        Card(
            modifier =
                Modifier
                    .fillMaxWidth()
                    .padding(vertical = 8.dp),
            elevation = CardDefaults.cardElevation(4.dp),
        ) {
            Column(
                modifier = Modifier.padding(16.dp),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.Center,
            ) {
                Text(
                    text = "Current Balance",
                    style = MaterialTheme.typography.titleMedium,
                    color = Color.Gray,
                )
                Spacer(modifier = Modifier.height(4.dp))
                Text(
                    text = "${"%.2f".format(balance)}",
                    style = MaterialTheme.typography.displaySmall,
                    fontWeight = FontWeight.Bold,
                    color = if (balance < 0) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary,
                )
            }
        }
        Spacer(modifier = Modifier.height(16.dp))
        Text(
            text = "Recent Transactions",
            style = MaterialTheme.typography.titleLarge,
            modifier = Modifier.padding(bottom = 8.dp),
        )
        if (transactions.isEmpty()) {
            Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize()) {
                Text("No transactions for this account yet.")
            }
        } else {
            LazyColumn {
                items(transactions) { details ->
                    AccountTransactionItem(transactionDetails = details)
                    HorizontalDivider()
                }
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/DashboardScreen.kt ==================
package io.pm.finlight.ui.screens

import android.app.Application
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.PieChart
import androidx.compose.material.icons.filled.Timeline
import androidx.compose.material3.FilledTonalButton
import androidx.compose.material3.Icon
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import androidx.navigation.NavGraph.Companion.findStartDestination
import coil.compose.AsyncImage
import io.pm.finlight.BottomNavItem
import io.pm.finlight.BudgetViewModel
import io.pm.finlight.DashboardViewModel
import io.pm.finlight.DashboardViewModelFactory
import io.pm.finlight.R
import io.pm.finlight.ui.components.AccountSummaryCard
import io.pm.finlight.ui.components.BudgetWatchCard
import io.pm.finlight.ui.components.NetWorthCard
import io.pm.finlight.ui.components.OverallBudgetCard
import io.pm.finlight.ui.components.RecentActivityCard
import io.pm.finlight.ui.components.StatCard

@Composable
fun DashboardScreen(
    navController: NavController,
    viewModel: DashboardViewModel = viewModel(factory = DashboardViewModelFactory(LocalContext.current.applicationContext as Application)),
    budgetViewModel: BudgetViewModel,
) {
    val profilePictureUri by viewModel.profilePictureUri.collectAsState()
    val netWorth by viewModel.netWorth.collectAsState()
    val monthlyIncome by viewModel.monthlyIncome.collectAsState()
    val monthlyExpenses by viewModel.monthlyExpenses.collectAsState()
    val overallBudget by viewModel.overallMonthlyBudget.collectAsState()
    val budgetStatus by viewModel.budgetStatus.collectAsState()
    val recentTransactions by viewModel.recentTransactions.collectAsState()
    val accountsSummary by viewModel.accountsSummary.collectAsState()
    // --- BUG FIX: Get the correct state for the card ---
    val safeToSpendPerDay by viewModel.safeToSpendPerDay.collectAsState()


    LazyColumn(
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp),
    ) {
        item {
            OverallBudgetCard(
                totalBudget = overallBudget,
                amountSpent = monthlyExpenses.toFloat(),
                navController = navController,
            )
        }
        item {
            Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(12.dp)) {
                StatCard(
                    label = "Monthly Income",
                    amount = monthlyIncome.toFloat(),
                    modifier = Modifier.weight(1f),
                    onClick = {
                        navController.navigate(BottomNavItem.Transactions.route) {
                            popUpTo(navController.graph.findStartDestination().id) {
                                saveState = true
                            }
                            launchSingleTop = true
                            restoreState = true
                        }
                    }
                )
                StatCard(
                    label = "Total Budget",
                    amount = overallBudget,
                    modifier = Modifier.weight(1f),
                    onClick = { navController.navigate("budget_screen") }
                )
                // --- BUG FIX: Removed onClick and corrected amount ---
                StatCard(
                    label = "Safe To Spend",
                    amount = safeToSpendPerDay,
                    isPerDay = true, // Add flag to show "/day" suffix
                    modifier = Modifier.weight(1f)
                    // No onClick handler, so the card is not clickable
                )
            }
        }
        item {
            Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(16.dp)) {
                FilledTonalButton(
                    onClick = {
                        navController.navigate(BottomNavItem.Reports.route) {
                            popUpTo(navController.graph.findStartDestination().id) { saveState = true }
                            launchSingleTop = true
                            restoreState = true
                        }
                    },
                    modifier = Modifier.weight(1f),
                ) {
                    Icon(Icons.Default.Timeline, contentDescription = null, modifier = Modifier.size(18.dp))
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("View Trends")
                }
                FilledTonalButton(
                    onClick = {
                        navController.navigate(BottomNavItem.Reports.route) {
                            popUpTo(navController.graph.findStartDestination().id) { saveState = true }
                            launchSingleTop = true
                            restoreState = true
                        }
                    },
                    modifier = Modifier.weight(1f),
                ) {
                    Icon(Icons.Default.PieChart, contentDescription = null, modifier = Modifier.size(18.dp))
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("View Categories")
                }
            }
        }
        item { NetWorthCard(netWorth) }
        item { RecentActivityCard(recentTransactions, navController) }
        item { AccountSummaryCard(accounts = accountsSummary, navController = navController) }
        item {
            BudgetWatchCard(
                budgetStatus = budgetStatus,
                viewModel = budgetViewModel,
                navController = navController,
            )
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/EditProfileScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/EditProfileScreen.kt
// REASON: New screen to allow users to update their profile information
// (name and picture) after the initial onboarding.
// =================================================================================
package io.pm.finlight.ui.screens

import android.content.Context
import android.net.Uri
import android.os.Environment
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CameraAlt
import androidx.compose.material.icons.filled.PhotoLibrary
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.input.KeyboardCapitalization
import androidx.compose.ui.unit.dp
import androidx.core.content.FileProvider
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import coil.compose.AsyncImage
import com.canhub.cropper.CropImageContract
import com.canhub.cropper.CropImageContractOptions
import com.canhub.cropper.CropImageOptions
import com.canhub.cropper.CropImageView
import io.pm.finlight.ProfileViewModel
import io.pm.finlight.R
import java.io.File
import java.text.SimpleDateFormat
import java.util.*

@Composable
fun EditProfileScreen(
    navController: NavController,
    viewModel: ProfileViewModel = viewModel()
) {
    val currentName by viewModel.userName.collectAsState()
    val savedProfilePictureUri by viewModel.profilePictureUri.collectAsState()
    val context = LocalContext.current

    var editedName by remember(currentName) { mutableStateOf(currentName) }
    var croppedImageUri by remember { mutableStateOf<Uri?>(null) }
    var tempCameraImageUri by remember { mutableStateOf<Uri?>(null) }
    var showImageSourceDialog by remember { mutableStateOf(false) }

    val displayUri = croppedImageUri ?: savedProfilePictureUri?.let { Uri.parse(it) }

    val toolbarColor = MaterialTheme.colorScheme.primary.toArgb()
    val toolbarTintColor = MaterialTheme.colorScheme.onPrimary.toArgb()
    val activityBackgroundColor = MaterialTheme.colorScheme.background.toArgb()

    val imageCropper = rememberLauncherForActivityResult(CropImageContract()) { result ->
        if (result.isSuccessful) {
            croppedImageUri = result.uriContent
        } else {
            val exception = result.error
            Toast.makeText(context, "Image cropping failed: ${exception?.message}", Toast.LENGTH_SHORT).show()
        }
    }

    val cameraLauncher = rememberLauncherForActivityResult(ActivityResultContracts.TakePicture()) { success ->
        if (success) {
            tempCameraImageUri?.let { uri ->
                val cropOptions = CropImageContractOptions(
                    uri = uri,
                    cropImageOptions = createCropOptions(toolbarColor, toolbarTintColor, activityBackgroundColor)
                )
                imageCropper.launch(cropOptions)
            }
        }
    }

    val galleryLauncher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri ->
        uri?.let {
            val cropOptions = CropImageContractOptions(
                uri = it,
                cropImageOptions = createCropOptions(toolbarColor, toolbarTintColor, activityBackgroundColor)
            )
            imageCropper.launch(cropOptions)
        }
    }

    if (showImageSourceDialog) {
        AlertDialog(
            onDismissRequest = { showImageSourceDialog = false },
            title = { Text("Change Profile Picture") },
            text = { Text("Choose a source for your new image.") },
            confirmButton = {
                TextButton(
                    onClick = {
                        showImageSourceDialog = false
                        // --- FIX: Create the temp file and get its secure URI before launching the camera ---
                        val tempFile = createTempImageFile(context)
                        val newTempUri = FileProvider.getUriForFile(
                            context,
                            "${context.packageName}.provider",
                            tempFile
                        )
                        tempCameraImageUri = newTempUri
                        cameraLauncher.launch(newTempUri)
                    }
                ) {
                    Icon(Icons.Default.CameraAlt, contentDescription = "Camera")
                    Spacer(Modifier.width(8.dp))
                    Text("Camera")
                }
            },
            dismissButton = {
                TextButton(
                    onClick = {
                        showImageSourceDialog = false
                        galleryLauncher.launch("image/*")
                    }
                ) {
                    Icon(Icons.Default.PhotoLibrary, contentDescription = "Gallery")
                    Spacer(Modifier.width(8.dp))
                    Text("Gallery")
                }
            }
        )
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(24.dp)
    ) {
        AsyncImage(
            model = displayUri,
            contentDescription = "User Profile Picture",
            placeholder = painterResource(id = R.drawable.ic_launcher_foreground),
            error = painterResource(id = R.drawable.ic_launcher_foreground),
            contentScale = ContentScale.Crop,
            modifier = Modifier
                .size(128.dp)
                .clip(CircleShape)
                .background(MaterialTheme.colorScheme.surfaceVariant)
                .border(2.dp, MaterialTheme.colorScheme.primary, CircleShape)
                .clickable {
                    showImageSourceDialog = true
                }
        )

        OutlinedTextField(
            value = editedName,
            onValueChange = { editedName = it },
            label = { Text("Your Name") },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true,
            keyboardOptions = KeyboardOptions(capitalization = KeyboardCapitalization.Words)
        )

        Spacer(modifier = Modifier.weight(1f))

        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            OutlinedButton(
                onClick = { navController.popBackStack() },
                modifier = Modifier.weight(1f)
            ) {
                Text("Cancel")
            }
            Button(
                onClick = {
                    viewModel.updateUserName(editedName)
                    croppedImageUri?.let { viewModel.saveProfilePictureUri(it) }
                    Toast.makeText(context, "Profile updated!", Toast.LENGTH_SHORT).show()
                    navController.popBackStack()
                },
                modifier = Modifier.weight(1f),
                enabled = editedName.isNotBlank()
            ) {
                Text("Save")
            }
        }
    }
}

/**
 * Helper function to create the crop options for the image cropper.
 */
private fun createCropOptions(toolbarColor: Int, toolbarTintColor: Int, activityBackgroundColor: Int): CropImageOptions {
    return CropImageOptions(
        cropShape = CropImageView.CropShape.OVAL,
        aspectRatioX = 1,
        aspectRatioY = 1,
        fixAspectRatio = true,
        outputCompressQuality = 70,
        imageSourceIncludeGallery = false, // We handle this ourselves now
        imageSourceIncludeCamera = false, // We handle this ourselves now
        activityTitle = "Crop Profile Picture",
        activityMenuIconColor = toolbarTintColor,
        toolbarColor = toolbarColor,
        toolbarBackButtonColor = toolbarTintColor,
        activityBackgroundColor = activityBackgroundColor
    )
}

/**
 * Helper function to create a temporary image file in the app's external files directory.
 */
private fun createTempImageFile(context: Context): File {
    // --- FIX: Use the external files directory for better compatibility with the camera intent ---
    val timeStamp: String = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())
    val storageDir: File? = context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)
    return File.createTempFile(
        "JPEG_${timeStamp}_",
        ".jpg",
        storageDir
    )
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/RecurringTransactionScreens.kt ==================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import io.pm.finlight.*
import java.util.*

@Composable
fun RecurringTransactionScreen(navController: NavController) {
    val viewModel: RecurringTransactionViewModel = viewModel()
    val recurringTransactions by viewModel.allRecurringTransactions.collectAsState(initial = emptyList())

    if (recurringTransactions.isEmpty()) {
        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            Text("No recurring transactions set up. Tap the '+' to add one.")
        }
    } else {
        LazyColumn(
            modifier = Modifier.padding(horizontal = 16.dp)
        ) {
            items(recurringTransactions) { rule ->
                ListItem(
                    headlineContent = { Text(rule.description) },
                    supportingContent = { Text("${rule.amount} every ${rule.recurrenceInterval.lowercase(Locale.getDefault())}") },
                    trailingContent = {
                        Text(
                            text = rule.transactionType.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() },
                            color = if (rule.transactionType == "expense") MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary
                        )
                    }
                )
                HorizontalDivider()
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/SearchScreen.kt ==================
package io.pm.finlight.ui.screens

import android.app.Application
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Clear
import androidx.compose.material.icons.filled.DateRange
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import io.pm.finlight.*
import io.pm.finlight.ui.components.TransactionItem
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SearchScreen(navController: NavController) {
    val context = LocalContext.current
    val factory = SearchViewModelFactory(context.applicationContext as Application)
    val viewModel: SearchViewModel = viewModel(factory = factory)

    val searchUiState by viewModel.uiState.collectAsState()
    val searchResults by viewModel.searchResults.collectAsState()

    var showStartDatePicker by remember { mutableStateOf(false) }
    var showEndDatePicker by remember { mutableStateOf(false) }

    val dateFormatter = SimpleDateFormat("dd/MM/yyyy", Locale.getDefault())

    Column(modifier = Modifier.fillMaxSize()) {
        LazyColumn(
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp),
            modifier = Modifier.weight(1f),
        ) {
            item {
                OutlinedTextField(
                    value = searchUiState.keyword,
                    onValueChange = { viewModel.onKeywordChange(it) },
                    label = { Text("Keyword (description, notes)") },
                    modifier = Modifier.fillMaxWidth(),
                )
            }

            item {
                SearchableDropdown(
                    label = "Account",
                    options = searchUiState.accounts,
                    selectedOption = searchUiState.selectedAccount,
                    onOptionSelected = { viewModel.onAccountChange(it) },
                    getDisplayName = { it.name },
                )
            }

            item {
                SearchableDropdown(
                    label = "Category",
                    options = searchUiState.categories,
                    selectedOption = searchUiState.selectedCategory,
                    onOptionSelected = { viewModel.onCategoryChange(it) },
                    getDisplayName = { it.name },
                )
            }

            item {
                SearchableDropdown(
                    label = "Transaction Type",
                    options = listOf("All", "Income", "Expense"),
                    selectedOption = searchUiState.transactionType.replaceFirstChar { it.uppercase() },
                    onOptionSelected = { viewModel.onTypeChange(it) },
                    getDisplayName = { it },
                )
            }

            item {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                ) {
                    DateTextField(
                        label = "Start Date",
                        date = searchUiState.startDate,
                        formatter = dateFormatter,
                        onClick = { showStartDatePicker = true },
                        onClear = { viewModel.onDateChange(start = null) },
                        modifier = Modifier.weight(1f),
                    )
                    DateTextField(
                        label = "End Date",
                        date = searchUiState.endDate,
                        formatter = dateFormatter,
                        onClick = { showEndDatePicker = true },
                        onClear = { viewModel.onDateChange(end = null) },
                        modifier = Modifier.weight(1f),
                    )
                }
            }

            if (searchResults.isNotEmpty()) {
                item {
                    Text(
                        text = "Results (${searchResults.size})",
                        style = MaterialTheme.typography.titleMedium,
                        modifier = Modifier.padding(top = 16.dp),
                    )
                    HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))
                }
                items(searchResults) { transactionDetails ->
                    TransactionItem(
                        transactionDetails = transactionDetails,
                        onClick = { navController.navigate("edit_transaction/${transactionDetails.transaction.id}") },
                    )
                }
            } else if (searchUiState.hasSearched) {
                item {
                    Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxWidth().padding(32.dp)) {
                        Text("No transactions match your criteria.")
                    }
                }
            }
        }

        Row(
            modifier =
                Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
            horizontalArrangement = Arrangement.spacedBy(16.dp),
        ) {
            OutlinedButton(
                onClick = { viewModel.clearFilters() },
                modifier = Modifier.weight(1f),
            ) { Text("Clear") }

            Button(
                onClick = { viewModel.executeSearch() },
                modifier = Modifier.weight(1f),
            ) { Text("Apply Filters") }
        }
    }

    if (showStartDatePicker) {
        val datePickerState = rememberDatePickerState(initialSelectedDateMillis = searchUiState.startDate)
        DatePickerDialog(
            onDismissRequest = { showStartDatePicker = false },
            confirmButton = {
                TextButton(onClick = {
                    viewModel.onDateChange(start = datePickerState.selectedDateMillis)
                    showStartDatePicker = false
                }) { Text("OK") }
            },
            dismissButton = {
                TextButton(onClick = { showStartDatePicker = false }) { Text("Cancel") }
            },
        ) {
            DatePicker(state = datePickerState)
        }
    }

    if (showEndDatePicker) {
        val datePickerState = rememberDatePickerState(initialSelectedDateMillis = searchUiState.endDate)
        DatePickerDialog(
            onDismissRequest = { showEndDatePicker = false },
            confirmButton = {
                TextButton(onClick = {
                    viewModel.onDateChange(end = datePickerState.selectedDateMillis)
                    showEndDatePicker = false
                }) { Text("OK") }
            },
            dismissButton = {
                TextButton(onClick = { showEndDatePicker = false }) { Text("Cancel") }
            },
        ) {
            DatePicker(state = datePickerState)
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun <T> SearchableDropdown(
    label: String,
    options: List<T>,
    selectedOption: T?,
    onOptionSelected: (T?) -> Unit,
    getDisplayName: (T) -> String,
) {
    var expanded by remember { mutableStateOf(false) }

    ExposedDropdownMenuBox(
        expanded = expanded,
        onExpandedChange = { expanded = !expanded },
    ) {
        OutlinedTextField(
            value = selectedOption?.let { getDisplayName(it) } ?: "All",
            onValueChange = {},
            readOnly = true,
            label = { Text(label) },
            trailingIcon = {
                Row {
                    if (selectedOption != null) {
                        IconButton(onClick = { onOptionSelected(null) }) {
                            Icon(Icons.Default.Clear, contentDescription = "Clear selection")
                        }
                    }
                    ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded)
                }
            },
            modifier =
                Modifier
                    .menuAnchor()
                    .fillMaxWidth(),
        )
        ExposedDropdownMenu(
            expanded = expanded,
            onDismissRequest = { expanded = false },
        ) {
            options.forEach { option ->
                DropdownMenuItem(
                    text = { Text(getDisplayName(option)) },
                    onClick = {
                        onOptionSelected(option)
                        expanded = false
                    },
                )
            }
        }
    }
}

@Composable
fun DateTextField(
    label: String,
    date: Long?,
    formatter: SimpleDateFormat,
    onClick: () -> Unit,
    onClear: () -> Unit,
    modifier: Modifier = Modifier,
) {
    OutlinedTextField(
        value = date?.let { formatter.format(Date(it)) } ?: "",
        onValueChange = {},
        readOnly = true,
        label = { Text(label) },
        modifier = modifier.clickable(onClick = onClick),
        trailingIcon = {
            if (date != null) {
                IconButton(onClick = onClear) {
                    Icon(Icons.Default.Clear, "Clear Date")
                }
            } else {
                Icon(Icons.Default.DateRange, "Select Date")
            }
        },
    )
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/CsvValidationScreen.kt ==================
package io.pm.finlight.ui.screens

import android.widget.Toast
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.livedata.observeAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import io.pm.finlight.*
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.launch
import java.net.URLEncoder

@Composable
fun CsvValidationScreen(
    navController: NavController,
    viewModel: SettingsViewModel
) {
    val report by viewModel.csvValidationReport.collectAsState()
    val context = LocalContext.current
    val scope = rememberCoroutineScope()

    val backStackEntry = navController.currentBackStackEntry
    val updatedRowJsonState = backStackEntry?.savedStateHandle?.getLiveData<String>("corrected_row")?.observeAsState()

    LaunchedEffect(updatedRowJsonState?.value) {
        val json = updatedRowJsonState?.value
        val line = backStackEntry?.savedStateHandle?.get<Int>("corrected_row_line")
        if (json != null && line != null) {
            val gson = Gson()
            val correctedData: List<String> = gson.fromJson(json, object : TypeToken<List<String>>() {}.type)
            viewModel.updateAndRevalidateRow(line, correctedData)
            backStackEntry.savedStateHandle.remove<String>("corrected_row")
            backStackEntry.savedStateHandle.remove<Int>("corrected_row_line")
        }
    }

    val currentReport = report
    if (currentReport == null) {
        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) { CircularProgressIndicator() }
    } else {
        Column(modifier = Modifier.fillMaxSize()) {
            LazyColumn(
                modifier = Modifier.weight(1f),
                contentPadding = PaddingValues(16.dp),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                item {
                    Text("Validation Complete", style = MaterialTheme.typography.headlineSmall, fontWeight = FontWeight.Bold)
                    Text("Tap a row to edit it, or use the trash icon to ignore it.")
                }

                items(currentReport.reviewableRows, key = { it.lineNumber }) { row ->
                    EditableRowItem(
                        row = row,
                        onEditClick = {
                            // --- UPDATED: Navigate to the AddTransactionScreen in edit mode ---
                            val gson = Gson()
                            val rowDataJson = gson.toJson(row.rowData)
                            val encodedJson = URLEncoder.encode(rowDataJson, "UTF-8")
                            navController.navigate("add_transaction?isCsvEdit=true&csvLineNumber=${row.lineNumber}&initialDataJson=$encodedJson")
                        },
                        onDeleteClick = {
                            viewModel.removeRowFromReport(row)
                        }
                    )
                }
            }
            val importableRowCount = report?.reviewableRows?.count { it.status == CsvRowStatus.VALID || it.status == CsvRowStatus.NEEDS_ACCOUNT_CREATION || it.status == CsvRowStatus.NEEDS_CATEGORY_CREATION || it.status == CsvRowStatus.NEEDS_BOTH_CREATION } ?: 0
            Row(modifier = Modifier.fillMaxWidth().padding(16.dp), horizontalArrangement = Arrangement.spacedBy(16.dp)) {
                OutlinedButton(onClick = {
                    viewModel.clearCsvValidationReport()
                    navController.popBackStack()
                }, modifier = Modifier.weight(1f)) { Text("Cancel") }

                Button(
                    onClick = {
                        scope.launch {
                            val rowsToImport = report?.reviewableRows?.filter { it.status != CsvRowStatus.INVALID_AMOUNT && it.status != CsvRowStatus.INVALID_DATE && it.status != CsvRowStatus.INVALID_COLUMN_COUNT }
                            if (!rowsToImport.isNullOrEmpty()) {
                                viewModel.commitCsvImport(rowsToImport)
                                Toast.makeText(context, "$importableRowCount transactions imported!", Toast.LENGTH_LONG).show()
                                navController.navigate("dashboard") { popUpTo(0) }
                            }
                        }
                    },
                    modifier = Modifier.weight(1f),
                    enabled = importableRowCount > 0
                ) { Text("Import $importableRowCount Rows") }
            }
        }
    }
}

@Composable
fun EditableRowItem(row: ReviewableRow, onEditClick: () -> Unit, onDeleteClick: () -> Unit) {
    val backgroundColor = when (row.status) {
        CsvRowStatus.VALID -> MaterialTheme.colorScheme.surfaceVariant
        CsvRowStatus.NEEDS_ACCOUNT_CREATION, CsvRowStatus.NEEDS_CATEGORY_CREATION, CsvRowStatus.NEEDS_BOTH_CREATION -> MaterialTheme.colorScheme.tertiaryContainer
        else -> MaterialTheme.colorScheme.errorContainer
    }
    val icon = when (row.status) {
        CsvRowStatus.VALID -> Icons.Default.CheckCircle
        CsvRowStatus.NEEDS_ACCOUNT_CREATION, CsvRowStatus.NEEDS_CATEGORY_CREATION, CsvRowStatus.NEEDS_BOTH_CREATION -> Icons.Default.AddCircle
        else -> Icons.Default.Warning
    }

    Card(modifier = Modifier.fillMaxWidth()) {
        Row(modifier = Modifier.padding(start = 16.dp), verticalAlignment = Alignment.CenterVertically) {
            Icon(imageVector = icon, contentDescription = "Status", modifier = Modifier.padding(end = 12.dp))
            Column(
                modifier = Modifier
                    .weight(1f)
                    .clickable(onClick = onEditClick)
                    .padding(vertical = 16.dp)
            ) {
                Text("Line ${row.lineNumber}: ${row.rowData.getOrNull(1) ?: "N/A"}", fontWeight = FontWeight.Bold)
                Spacer(Modifier.height(4.dp))
                Text(row.statusMessage, style = MaterialTheme.typography.bodySmall, maxLines = 2, overflow = TextOverflow.Ellipsis)
            }
            IconButton(onClick = onDeleteClick) {
                Icon(Icons.Default.Delete, contentDescription = "Ignore this row")
            }
            IconButton(onClick = onEditClick) {
                Icon(Icons.Default.Edit, contentDescription = "Edit Row")
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/AddAccountScreen.kt ==================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import io.pm.finlight.AccountViewModel

@Composable
fun AddAccountScreen(
    navController: NavController,
    viewModel: AccountViewModel,
) {
    var accountName by remember { mutableStateOf("") }
    var accountType by remember { mutableStateOf("") }

    Column(
        modifier =
            Modifier
                .fillMaxSize()
                .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp),
    ) {
        OutlinedTextField(
            value = accountName,
            onValueChange = { accountName = it },
            label = { Text("Account Name (e.g., Savings, Credit Card)") },
            modifier = Modifier.fillMaxWidth(),
        )
        OutlinedTextField(
            value = accountType,
            onValueChange = { accountType = it },
            label = { Text("Account Type (e.g., Bank, Wallet)") },
            modifier = Modifier.fillMaxWidth(),
        )
        Spacer(modifier = Modifier.height(16.dp))
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(16.dp),
        ) {
            OutlinedButton(onClick = { navController.popBackStack() }, modifier = Modifier.weight(1f)) {
                Text("Cancel")
            }
            Button(
                onClick = {
                    if (accountName.isNotBlank() && accountType.isNotBlank()) {
                        viewModel.addAccount(accountName, accountType)
                        navController.popBackStack()
                    }
                },
                modifier = Modifier.weight(1f),
                enabled = accountName.isNotBlank() && accountType.isNotBlank(),
            ) {
                Text("Save Account")
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/OnboardingScreen.kt ==================
// FILE: app/src/main/java/io/pm/finlight/ui/screens/OnboardingScreen.kt

package io.pm.finlight.ui.screens

import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.pager.HorizontalPager
import androidx.compose.foundation.pager.PagerState
import androidx.compose.foundation.pager.rememberPagerState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.unit.dp
import io.pm.finlight.OnboardingViewModel
import kotlinx.coroutines.launch

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun OnboardingScreen(viewModel: OnboardingViewModel, onOnboardingFinished: () -> Unit) {
    // --- UPDATED: Page count is now 7 after removing category selection ---
    val pagerState = rememberPagerState { 7 }
    val scope = rememberCoroutineScope()

    val onNextClicked: () -> Unit = {
        scope.launch {
            pagerState.animateScrollToPage(pagerState.currentPage + 1)
        }
    }

    Scaffold(
        bottomBar = {
            OnboardingBottomBar(
                pagerState = pagerState,
                viewModel = viewModel,
                onNextClicked = onNextClicked,
                onFinishClicked = {
                    viewModel.finishOnboarding()
                    onOnboardingFinished()
                }
            )
        }
    ) { innerPadding ->
        HorizontalPager(
            state = pagerState,
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding),
            userScrollEnabled = false
        ) { page ->
            // --- UPDATED: Removed CategorySetupPage and shifted indices ---
            when (page) {
                0 -> WelcomePage()
                1 -> UserNamePage(viewModel)
                2 -> BudgetSetupPage(viewModel)
                3 -> SmsPermissionPage(onPermissionResult = onNextClicked)
                4 -> SmsScanningInfoPage()
                5 -> NotificationPermissionPage(onPermissionResult = onNextClicked)
                6 -> CompletionPage()
            }
        }
    }
}

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun OnboardingBottomBar(
    pagerState: PagerState,
    viewModel: OnboardingViewModel,
    onNextClicked: () -> Unit,
    onFinishClicked: () -> Unit
) {
    val userName by viewModel.userName.collectAsState()

    Surface(shadowElevation = 8.dp) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp, vertical = 12.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            PageIndicator(pageCount = pagerState.pageCount, currentPage = pagerState.currentPage)

            // --- UPDATED: Page indices for hiding the "Next" button adjusted ---
            val isNextButtonVisible = pagerState.currentPage < pagerState.pageCount - 1 &&
                    pagerState.currentPage != 3 && // Hide on SMS Permission Page
                    pagerState.currentPage != 5    // Hide on Notification Permission Page

            val isNextEnabled = if (pagerState.currentPage == 1) {
                userName.isNotBlank()
            } else {
                true
            }

            if (isNextButtonVisible) {
                Button(
                    onClick = onNextClicked,
                    enabled = isNextEnabled
                ) {
                    Text("Next")
                    Icon(Icons.AutoMirrored.Filled.ArrowForward, contentDescription = "Next Page")
                }
            } else if (pagerState.currentPage == pagerState.pageCount - 1) {
                Button(onClick = onFinishClicked) {
                    Text("Finish Setup")
                }
            } else {
                Spacer(modifier = Modifier.width(0.dp))
            }
        }
    }
}

@Composable
fun PageIndicator(pageCount: Int, currentPage: Int) {
    Row(
        horizontalArrangement = Arrangement.spacedBy(8.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        repeat(pageCount) { iteration ->
            val color = if (currentPage == iteration) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f)
            Box(
                modifier = Modifier
                    .size(10.dp)
                    .clip(CircleShape)
                    .background(color)
            )
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/ProfileScreen.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ui/screens/ProfileScreen.kt
// REASON: Simplified the screen by removing direct editing functionality. The main
// profile card is now clickable, navigating the user to a dedicated
// "Edit Profile" screen.
// =================================================================================
package io.pm.finlight.ui.screens

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import coil.compose.AsyncImage
import io.pm.finlight.ProfileViewModel
import io.pm.finlight.R

@Composable
fun ProfileScreen(
    navController: NavController,
    viewModel: ProfileViewModel = viewModel()
) {
    val userName by viewModel.userName.collectAsState()
    val savedProfilePictureUri by viewModel.profilePictureUri.collectAsState()

    Column(modifier = Modifier.padding(16.dp)) {
        // --- UPDATED: The entire card is now clickable ---
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .clickable { navController.navigate("edit_profile") },
            elevation = CardDefaults.cardElevation(4.dp)
        ) {
            Box(modifier = Modifier.padding(16.dp)) {
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    AsyncImage(
                        model = savedProfilePictureUri,
                        contentDescription = "User Profile Picture",
                        placeholder = painterResource(id = R.drawable.ic_launcher_foreground),
                        error = painterResource(id = R.drawable.ic_launcher_foreground),
                        contentScale = ContentScale.Crop,
                        modifier = Modifier
                            .size(64.dp)
                            .clip(CircleShape)
                            .background(MaterialTheme.colorScheme.surfaceVariant)
                            .border(2.dp, MaterialTheme.colorScheme.primary, CircleShape)
                    )

                    Spacer(modifier = Modifier.width(16.dp))
                    Column(modifier = Modifier.weight(1f)) {
                        Text(userName, style = MaterialTheme.typography.titleLarge)
                        Text("user.email@pm.com", style = MaterialTheme.typography.bodyMedium)
                    }
                    Icon(
                        imageVector = Icons.Default.Edit,
                        contentDescription = "Edit Profile",
                        tint = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }
        }

        Spacer(modifier = Modifier.height(24.dp))

        ListItem(
            headlineContent = { Text("App Settings") },
            leadingContent = { Icon(Icons.Default.Settings, contentDescription = "Settings") },
            trailingContent = {
                Icon(
                    painter = painterResource(id = R.drawable.ic_chevron_right),
                    contentDescription = null
                )
            },
            modifier = Modifier.clickable {
                navController.navigate("settings_screen")
            }
        )
        HorizontalDivider()
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/screens/ReportsScreen.kt ==================
package io.pm.finlight.ui.screens

import android.graphics.Color
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import io.pm.finlight.ReportsViewModel
import io.pm.finlight.ui.components.ChartLegend
import io.pm.finlight.ui.components.GroupedBarChart
import com.github.mikephil.charting.charts.PieChart

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ReportsScreen(
    navController: NavController,
    viewModel: ReportsViewModel = viewModel(),
) {
    val pieData by viewModel.spendingByCategoryPieData.collectAsState(initial = null)
    val trendDataPair by viewModel.monthlyTrendData.collectAsState(initial = null)


    LazyColumn(
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // --- Pie Chart Card ---
        item {
            Card(modifier = Modifier.fillMaxWidth(), elevation = CardDefaults.cardElevation(4.dp)) {
                Column(modifier = Modifier.padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally) {
                    Text("Spending by Category for ${viewModel.monthYear}", style = MaterialTheme.typography.titleLarge)
                    Spacer(modifier = Modifier.height(16.dp))
                    if (pieData == null || pieData?.entryCount == 0) {
                        Box(modifier = Modifier.fillMaxWidth().height(300.dp), contentAlignment = Alignment.Center) {
                            Text("No expense data for this month.")
                        }
                    } else {
                        AndroidView(
                            factory = { context ->
                                PieChart(context).apply {
                                    description.isEnabled = false
                                    isDrawHoleEnabled = true
                                    setHoleColor(
                                        Color.TRANSPARENT,
                                    )
                                    setEntryLabelColor(Color.BLACK)
                                    setEntryLabelTextSize(12f)
                                    legend.isEnabled = false
                                }
                            },
                            update = { chart ->
                                chart.data = pieData
                                // --- BUG FIX: Explicitly notify the chart that the data has changed ---
                                // This forces a full redraw, ensuring that all properties of the
                                // new dataset, including the custom colors, are applied correctly.
                                chart.notifyDataSetChanged()
                                chart.invalidate()
                            },
                            modifier = Modifier.fillMaxWidth().height(300.dp),
                        )
                        Spacer(modifier = Modifier.height(16.dp))
                        pieData?.let { ChartLegend(it) }
                    }
                }
            }
        }

        // --- Bar Chart Card ---
        item {
            Card(modifier = Modifier.fillMaxWidth().padding(top = 16.dp), elevation = CardDefaults.cardElevation(4.dp)) {
                Column(modifier = Modifier.padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally) {
                    Text("Income vs. Expense Trend", style = MaterialTheme.typography.titleLarge)
                    Spacer(modifier = Modifier.height(16.dp))
                    if (trendDataPair != null && trendDataPair!!.first.entryCount > 0) {
                        GroupedBarChart(trendDataPair!!)
                    } else {
                        Box(modifier = Modifier.fillMaxWidth().height(250.dp), contentAlignment = Alignment.Center) {
                            Text("Not enough data for trend analysis.")
                        }
                    }
                }
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/components/UtilityComponents.kt ==================
package io.pm.finlight.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import com.github.mikephil.charting.charts.BarChart
import com.github.mikephil.charting.components.XAxis
import com.github.mikephil.charting.data.BarData
import com.github.mikephil.charting.data.PieData
import com.github.mikephil.charting.data.PieDataSet
import com.github.mikephil.charting.formatter.IndexAxisValueFormatter

@Composable
fun TimePickerDialog(
    title: String = "Select Time",
    onDismissRequest: () -> Unit,
    onConfirm: () -> Unit,
    content: @Composable () -> Unit,
) {
    AlertDialog(
        onDismissRequest = onDismissRequest,
        title = { Text(title) },
        text = {
            Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                content()
            }
        },
        confirmButton = {
            TextButton(onClick = onConfirm) {
                Text("OK")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismissRequest) {
                Text("Cancel")
            }
        },
    )
}

@Composable
fun ChartLegend(pieData: PieData?) {
    // Safely get the dataset from the PieData object.
    val dataSet = pieData?.dataSet as? PieDataSet ?: return

    // Use a classic for loop for maximum compatibility with the Java library.
    // This explicitly gets each entry and its corresponding color by index.
    Column {
        for (i in 0 until dataSet.entryCount) {
            val entry = dataSet.getEntryForIndex(i)
            val color = dataSet.getColor(i)

            Row(
                verticalAlignment = Alignment.CenterVertically,
                modifier = Modifier.padding(vertical = 4.dp),
            ) {
                Box(
                    modifier =
                        Modifier
                            .size(12.dp)
                            .clip(CircleShape)
                            .background(Color(color)), // Convert the Android integer color to a Compose Color
                )
                Spacer(modifier = Modifier.width(8.dp))
                // The 'label' property of PieEntry holds the category name.
                Text(text = "${entry.label} - ${"%.2f".format(entry.value)}")
            }
        }
    }
}

@Composable
fun GroupedBarChart(trendDataPair: Pair<BarData, List<String>>) {
    val (barData, labels) = trendDataPair

    AndroidView(
        factory = { context ->
            // FACTORY: For one-time, data-independent setup
            BarChart(context).apply {
                description.isEnabled = false
                legend.isEnabled = true
                setDrawGridBackground(false)

                xAxis.position = XAxis.XAxisPosition.BOTTOM
                xAxis.setDrawGridLines(false)
                xAxis.granularity = 1f // Essential for labels to align with bars

                axisLeft.axisMinimum = 0f
                axisLeft.setDrawGridLines(true)

                axisRight.isEnabled = false
            }
        },
        update = { chart ->
            // UPDATE: For applying data and data-dependent properties

            // 1. Define the widths and spacing for the grouped bars
            val barWidth = 0.25f
            val barSpace = 0.05f
            val groupSpace = 0.4f
            barData.barWidth = barWidth

            // 2. Apply the data to the chart
            chart.data = barData

            // 3. Set the labels for the X-Axis
            chart.xAxis.valueFormatter = IndexAxisValueFormatter(labels)

            // 4. Set the visible range of the x-axis
            // This is crucial for groupBars to work correctly
            chart.xAxis.axisMinimum = 0f
            chart.xAxis.axisMaximum = labels.size.toFloat()

            // 5. Center the labels under the groups
            chart.xAxis.setCenterAxisLabels(true)

            // 6. Group the bars. The 'fromX' (first param) should be the starting point.
            chart.groupBars(0f, groupSpace, barSpace)

            // 7. Refresh the chart to apply all changes
            chart.invalidate()
        },
        modifier =
            Modifier
                .fillMaxWidth()
                .height(250.dp),
    )
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/components/DashboardComponents.kt ==================
package io.pm.finlight.ui.components

import androidx.compose.animation.core.LinearEasing
import androidx.compose.animation.core.animateFloat
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.infiniteRepeatable
import androidx.compose.animation.core.rememberInfiniteTransition
import androidx.compose.animation.core.tween
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.AccountBalanceWallet
import androidx.compose.material.icons.filled.Assessment
import androidx.compose.material.icons.filled.Category
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.LinearProgressIndicator
import androidx.compose.material3.ListItem
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.drawscope.clipPath
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import androidx.navigation.NavGraph.Companion.findStartDestination
import io.pm.finlight.AccountWithBalance
import io.pm.finlight.BottomNavItem
import io.pm.finlight.Budget
import io.pm.finlight.BudgetViewModel
import io.pm.finlight.BudgetWithSpending
import io.pm.finlight.CategoryIconHelper
import io.pm.finlight.TransactionDetails
import kotlinx.coroutines.flow.map
import kotlin.math.sin

private fun formatAmountCompact(amount: Float): String {
    return when {
        amount >= 1_000_000 -> "${"%.1f".format(amount / 1_000_000)}M"
        amount >= 1_000 -> "${"%.1f".format(amount / 1_000)}k"
        else -> "${"%.0f".format(amount)}"
    }
}

@Composable
fun StatCard(
    label: String,
    amount: Float,
    modifier: Modifier = Modifier,
    isPerDay: Boolean = false,
    onClick: () -> Unit = {}
) {
    Card(
        modifier = modifier.clickable(onClick = onClick),
        elevation = CardDefaults.cardElevation(2.dp)
    ) {
        Column(
            modifier = Modifier.padding(12.dp).fillMaxWidth(),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            Text(
                text = label,
                style = MaterialTheme.typography.labelMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                textAlign = TextAlign.Center
            )
            Spacer(modifier = Modifier.height(4.dp))
            Text(
                text = "${formatAmountCompact(amount)}${if (isPerDay) "/day" else ""}",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold,
                textAlign = TextAlign.Center
            )
        }
    }
}

@Composable
fun OverallBudgetCard(
    totalBudget: Float,
    amountSpent: Float,
    navController: NavController
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { navController.navigate("budget_screen") },
        elevation = CardDefaults.cardElevation(4.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Monthly Budget", style = MaterialTheme.typography.titleLarge)
                if (totalBudget > 0) {
                    TextButton(onClick = { navController.navigate("budget_screen") }) {
                        Text("Edit")
                    }
                }
            }
            Spacer(modifier = Modifier.height(16.dp))

            if (totalBudget <= 0) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text(
                        "You haven't set a budget for this month yet.",
                        style = MaterialTheme.typography.bodyLarge,
                        textAlign = TextAlign.Center
                    )
                    Spacer(modifier = Modifier.height(12.dp))
                    Button(onClick = { navController.navigate("budget_screen") }) {
                        Text("Set Budget")
                    }
                }
            } else {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.SpaceAround
                ) {
                    LiquidTumbler(
                        progress = (amountSpent / totalBudget),
                        modifier = Modifier.size(120.dp)
                    )
                    Column {
                        Text("Spent", style = MaterialTheme.typography.labelLarge)
                        Text(
                            text = "${"%.2f".format(amountSpent)}",
                            style = MaterialTheme.typography.headlineSmall,
                            fontWeight = FontWeight.Bold,
                            color = MaterialTheme.colorScheme.error
                        )
                        Spacer(modifier = Modifier.height(16.dp))
                        Text("Remaining", style = MaterialTheme.typography.labelLarge)
                        Text(
                            text = "${"%.2f".format(totalBudget - amountSpent)}",
                            style = MaterialTheme.typography.headlineSmall,
                            fontWeight = FontWeight.Bold,
                            color = MaterialTheme.colorScheme.primary
                        )
                    }
                }
            }
        }
    }
}


@Composable
fun LiquidTumbler(progress: Float, modifier: Modifier = Modifier) {
    val clampedProgress = progress.coerceIn(0f, 1f)

    val animatedProgress by animateFloatAsState(
        targetValue = clampedProgress,
        animationSpec = tween(durationMillis = 1000, easing = LinearEasing),
        label = "LiquidFillAnimation"
    )

    val infiniteTransition = rememberInfiniteTransition(label = "WaveAnimation")
    val waveOffset by infiniteTransition.animateFloat(
        initialValue = 0f,
        targetValue = 2f,
        animationSpec = infiniteRepeatable(
            animation = tween(durationMillis = 1500, easing = LinearEasing)
        ), label = "WaveOffset"
    )

    val waterColor = when {
        clampedProgress >= 1f -> MaterialTheme.colorScheme.error
        clampedProgress > 0.8f -> Color(0xFFFBC02D) // Amber
        else -> MaterialTheme.colorScheme.primary
    }
    val glassColor = MaterialTheme.colorScheme.onSurfaceVariant
    val strokeWidthPx = with(LocalDensity.current) { 4.dp.toPx() }


    Box(
        contentAlignment = Alignment.Center,
        modifier = modifier
    ) {
        Canvas(modifier = Modifier.fillMaxSize()) {
            val width = size.width
            val height = size.height

            val glassPath = Path().apply {
                moveTo(width * 0.1f, height * 0.05f)
                lineTo(width * 0.2f, height * 0.95f)
                quadraticBezierTo(width * 0.5f, height * 1.05f, width * 0.8f, height * 0.95f)
                lineTo(width * 0.9f, height * 0.05f)
                close()
            }

            drawPath(
                path = glassPath,
                color = glassColor,
                style = Stroke(width = strokeWidthPx)
            )

            clipPath(glassPath) {
                drawRect(
                    brush = Brush.verticalGradient(
                        colors = listOf(waterColor.copy(alpha = 0.5f), waterColor),
                        startY = height * (1 - animatedProgress),
                        endY = height
                    ),
                    topLeft = Offset(0f, height * (1 - animatedProgress)),
                    size = size
                )

                val wavePath = Path().apply {
                    moveTo(-width, height * (1 - animatedProgress))
                    for (i in 0..width.toInt() * 2) {
                        lineTo(
                            i.toFloat(),
                            height * (1 - animatedProgress) + sin((i * 0.03f) + (waveOffset * Math.PI.toFloat())) * 5f
                        )
                    }
                    lineTo(width * 2, height)
                    lineTo(-width, height)
                    close()
                }
                drawPath(path = wavePath, color = waterColor)
            }
        }
        Text(
            text = "${(clampedProgress * 100).toInt()}%",
            color = MaterialTheme.colorScheme.onSurface,
            fontSize = 24.sp,
            fontWeight = FontWeight.Bold
        )
    }
}


@Composable
fun NetWorthCard(netWorth: Double) {
    Card(elevation = CardDefaults.cardElevation(4.dp), modifier = Modifier.fillMaxWidth()) {
        Column(modifier = Modifier.padding(16.dp)) {
            Text("Net Worth", style = MaterialTheme.typography.titleMedium)
            Text(
                text = "${"%.2f".format(netWorth)}",
                style = MaterialTheme.typography.displaySmall,
                fontWeight = FontWeight.Bold
            )
        }
    }
}

@Composable
fun AccountSummaryCard(accounts: List<AccountWithBalance>, navController: NavController) {
    Card(
        elevation = CardDefaults.cardElevation(4.dp),
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(
                    "Your Accounts",
                    style = MaterialTheme.typography.titleMedium,
                    modifier = Modifier.weight(1f)
                )
                TextButton(
                    onClick = {
                        navController.navigate("account_list")
                    }
                ) { Text("View All") }
            }
            Spacer(modifier = Modifier.height(8.dp))
            if (accounts.isEmpty()) {
                Text("No accounts found. Add one from the Settings.", modifier = Modifier.padding(vertical = 16.dp))
            } else {
                Column {
                    accounts.forEachIndexed { index, accountWithBalance ->
                        if (index > 0) HorizontalDivider()
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .clickable { navController.navigate("account_detail/${accountWithBalance.account.id}") }
                                .padding(vertical = 12.dp),
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.SpaceBetween
                        ) {
                            Column(modifier = Modifier.weight(1f)) {
                                Text(
                                    text = accountWithBalance.account.name,
                                    style = MaterialTheme.typography.bodyLarge,
                                    fontWeight = FontWeight.SemiBold
                                )
                                Text(
                                    text = accountWithBalance.account.type,
                                    style = MaterialTheme.typography.bodySmall,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }
                            Text(
                                text = "${"%.2f".format(accountWithBalance.balance)}",
                                style = MaterialTheme.typography.bodyLarge,
                                fontWeight = FontWeight.SemiBold,
                                color = if (accountWithBalance.balance < 0) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.onSurface
                            )
                        }
                    }
                }
            }
        }
    }
}

@Composable
fun RecentActivityCard(transactions: List<TransactionDetails>, navController: NavController) {
    Card(elevation = CardDefaults.cardElevation(4.dp), modifier = Modifier.fillMaxWidth()) {
        Column(modifier = Modifier.padding(16.dp)) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Text("Recent Transactions", style = MaterialTheme.typography.titleMedium, modifier = Modifier.weight(1f))
                TextButton(
                    onClick = {
                        navController.navigate(BottomNavItem.Transactions.route) {
                            popUpTo(navController.graph.findStartDestination().id) { saveState = true }
                            launchSingleTop = true
                            restoreState = true
                        }
                    }
                ) { Text("View All") }
            }
            Spacer(modifier = Modifier.height(8.dp))
            if(transactions.isEmpty()){
                Text("No transactions yet.", modifier = Modifier.padding(vertical = 16.dp))
            } else {
                transactions.forEach { details ->
                    TransactionItem(
                        transactionDetails = details,
                        // --- UPDATED: Navigate to the new detail screen ---
                        onClick = {
                            navController.navigate("transaction_detail/${details.transaction.id}")
                        }
                    )
                }
            }
        }
    }
}

@Composable
fun BudgetWatchCard(
    budgetStatus: List<BudgetWithSpending>,
    viewModel: BudgetViewModel,
    navController: NavController
) {
    Card(elevation = CardDefaults.cardElevation(4.dp), modifier = Modifier.fillMaxWidth()) {
        Column(modifier = Modifier.padding(16.dp)) {
            Row(modifier = Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.SpaceBetween) {
                Text("Budget Watch", style = MaterialTheme.typography.titleMedium)
                TextButton(onClick = { navController.navigate("add_budget") }) { Text("+ Add Category Budget") }
            }
            Spacer(modifier = Modifier.height(8.dp))
            if (budgetStatus.isEmpty()) {
                Text("No category-specific budgets set for this month.", style = MaterialTheme.typography.bodyMedium, modifier = Modifier.padding(vertical = 16.dp))
            } else {
                budgetStatus.forEach { budgetWithSpendingItem ->
                    BudgetItem(budgetWithSpending = budgetWithSpendingItem)
                }
            }
        }
    }
}


@Composable
fun BudgetItem(budgetWithSpending: BudgetWithSpending) {
    val budget = budgetWithSpending.budget
    val actualSpending = budgetWithSpending.spent
    val progress = if (budget.amount > 0) (actualSpending / budget.amount).toFloat() else 0f
    val amountRemaining = budget.amount - actualSpending
    val progressColor = when {
        progress > 1f -> MaterialTheme.colorScheme.error
        progress > 0.8f -> Color(0xFFFBC02D) // Amber
        else -> MaterialTheme.colorScheme.primary
    }

    Column(modifier = Modifier.padding(vertical = 8.dp)) {
        Row(modifier = Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
            Box(
                modifier = Modifier
                    .size(40.dp)
                    .clip(CircleShape)
                    .background(
                        CategoryIconHelper.getIconBackgroundColor(
                            budgetWithSpending.colorKey ?: "gray_light"
                        )
                    ),
                contentAlignment = Alignment.Center
            ) {
                if (budgetWithSpending.iconKey == "letter_default") {
                    Text(
                        text = budgetWithSpending.budget.categoryName.firstOrNull()?.uppercase() ?: "?",
                        fontWeight = FontWeight.Bold,
                        fontSize = 18.sp,
                        color = Color.Black
                    )
                } else {
                    Icon(
                        imageVector = CategoryIconHelper.getIcon(budgetWithSpending.iconKey ?: "category"),
                        contentDescription = budgetWithSpending.budget.categoryName,
                        tint = Color.Black,
                        modifier = Modifier.size(22.dp)
                    )
                }
            }
            Spacer(modifier = Modifier.width(16.dp))
            Text(text = budget.categoryName, style = MaterialTheme.typography.titleMedium, modifier = Modifier.weight(1f))
            Text(text = "${"%.0f".format(budget.amount)}", style = MaterialTheme.typography.bodyMedium, color = MaterialTheme.colorScheme.secondary)
        }
        Spacer(modifier = Modifier.height(8.dp))
        LinearProgressIndicator(progress = { progress }, modifier = Modifier.fillMaxWidth().height(8.dp), color = progressColor)
        Spacer(modifier = Modifier.height(8.dp))
        Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
            Text(text = "Spent: ${"%.2f".format(actualSpending)}", style = MaterialTheme.typography.bodySmall)
            Text(text = "Remaining: ${"%.2f".format(amountRemaining)}", style = MaterialTheme.typography.bodySmall, color = if (amountRemaining < 0) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.onSurface)
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/components/TransactionItem.kt ==================
package io.pm.finlight.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.NorthEast
import androidx.compose.material.icons.filled.SouthWest
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontStyle
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import io.pm.finlight.CategoryIconHelper
import io.pm.finlight.TransactionDetails
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun TransactionItem(
    transactionDetails: TransactionDetails,
    onClick: () -> Unit,
) {
    Card(
        modifier =
            Modifier
                .fillMaxWidth()
                .padding(vertical = 4.dp),
        onClick = onClick,
    ) {
        Row(modifier = Modifier.padding(16.dp), verticalAlignment = Alignment.CenterVertically) {
            Box(
                modifier = Modifier
                    .size(40.dp)
                    .clip(CircleShape)
                    .background(CategoryIconHelper.getIconBackgroundColor(transactionDetails.categoryColorKey ?: "gray_light")),
                contentAlignment = Alignment.Center
            ) {
                if (transactionDetails.categoryIconKey == "letter_default") {
                    Text(
                        text = transactionDetails.categoryName?.firstOrNull()?.uppercase() ?: "?",
                        fontWeight = FontWeight.Bold,
                        fontSize = 18.sp,
                        color = Color.Black
                    )
                } else {
                    Icon(
                        imageVector = CategoryIconHelper.getIcon(transactionDetails.categoryIconKey ?: "category"),
                        contentDescription = transactionDetails.categoryName,
                        tint = Color.Black,
                        modifier = Modifier.size(22.dp)
                    )
                }
            }
            Spacer(modifier = Modifier.width(16.dp))
            Column(modifier = Modifier.weight(1f)) {
                Text(text = transactionDetails.transaction.description, style = MaterialTheme.typography.bodyLarge, fontWeight = FontWeight.Bold)
                if (!transactionDetails.transaction.notes.isNullOrBlank()) {
                    Text(text = transactionDetails.transaction.notes!!, style = MaterialTheme.typography.bodyMedium, fontStyle = FontStyle.Italic, color = MaterialTheme.colorScheme.onSurfaceVariant)
                }
                Text(text = "${transactionDetails.categoryName ?: "Uncategorized"}  ${transactionDetails.accountName ?: "Unknown"}", style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.secondary)
                Text(text = SimpleDateFormat("dd MMM yy, h:mm a", Locale.getDefault()).format(Date(transactionDetails.transaction.date)), style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant)
            }

            val isIncome = transactionDetails.transaction.transactionType == "income"
            val amountColor = if (isIncome) Color(0xFF4CAF50) else Color(0xFFF44336)
            val icon = if (isIncome) Icons.Default.SouthWest else Icons.Default.NorthEast

            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(text = "${"%.2f".format(transactionDetails.transaction.amount)}", style = MaterialTheme.typography.bodyLarge, fontWeight = FontWeight.SemiBold, color = amountColor)
                Spacer(modifier = Modifier.width(4.dp))
                Icon(imageVector = icon, contentDescription = transactionDetails.transaction.transactionType, tint = amountColor, modifier = Modifier.size(20.dp))
            }
        }
    }
}

@Composable
fun AccountTransactionItem(transactionDetails: TransactionDetails) {
    Row(
        modifier =
            Modifier
                .fillMaxWidth()
                .padding(vertical = 12.dp),
        verticalAlignment = Alignment.CenterVertically,
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Text(text = transactionDetails.transaction.description, style = MaterialTheme.typography.bodyLarge)
            Text(
                text = SimpleDateFormat("dd MMM yy", Locale.getDefault()).format(Date(transactionDetails.transaction.date)),
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
            )
        }
        val isIncome = transactionDetails.transaction.transactionType == "income"
        val amountColor = if (isIncome) Color(0xFF4CAF50) else Color(0xFFF44336)

        Text(
            text = "${"%.2f".format(transactionDetails.transaction.amount)}",
            style = MaterialTheme.typography.bodyLarge,
            color = amountColor,
        )
    }
}

@Composable
fun TransactionList(
    transactions: List<TransactionDetails>,
    navController: NavController,
) {
    if (transactions.isEmpty()) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(16.dp),
            contentAlignment = Alignment.Center,
        ) {
            Text("No transactions yet. Add one!")
        }
    } else {
        LazyColumn(
            modifier = Modifier.fillMaxSize(),
            contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp),
        ) {
            items(transactions, key = { it.transaction.id }) { details ->
                TransactionItem(
                    transactionDetails = details,
                    onClick = {
                        // --- FIX: Ensure navigation is to the detail screen ---
                        navController.navigate("transaction_detail/${details.transaction.id}")
                    }
                )
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/components/CategoryDialogs.kt ==================
package io.pm.finlight.ui.components

import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import io.pm.finlight.Category

@Composable
fun EditCategoryDialog(
    category: Category,
    onDismiss: () -> Unit,
    onConfirm: (Category) -> Unit,
) {
    var updatedName by remember { mutableStateOf(category.name) }

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Edit Category") },
        text = {
            OutlinedTextField(
                value = updatedName,
                onValueChange = { updatedName = it },
                label = { Text("Category Name") },
            )
        },
        confirmButton = {
            Button(
                onClick = {
                    if (updatedName.isNotBlank()) {
                        onConfirm(category.copy(name = updatedName))
                    }
                },
                enabled = updatedName.isNotBlank(),
            ) {
                Text("Update")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        },
    )
}

@Composable
fun DeleteCategoryDialog(
    category: Category,
    onDismiss: () -> Unit,
    onConfirm: () -> Unit,
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Delete Category") },
        text = { Text("Are you sure you want to delete the category '${category.name}'? This cannot be undone.") },
        confirmButton = {
            Button(
                onClick = onConfirm,
                colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error),
            ) {
                Text("Delete")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        },
    )
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/theme/Color.kt ==================
package io.pm.finlight.ui.theme

import androidx.compose.ui.graphics.Color

// Default Material colors (can be removed if not used)
val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)

// --- ADDED: Custom colors for our new theme ---
val FinanceGreen = Color(0xFF006A60) // A deep, professional green for primary elements
val FinanceGreenLight = Color(0xFF50D9C8) // A lighter version for dark theme primary
val GoldAccent = Color(0xFF815600) // A rich gold/amber for secondary elements
val GoldAccentLight = Color(0xFFFFBA3F) // A lighter version for dark theme secondary
val Charcoal = Color(0xFF333333) // A dark gray for text and tertiary elements
val OffWhite = Color(0xFFF8F9FA) // A very light gray for backgrounds
val DarkSurface = Color(0xFF1E1E1E) // A slightly lighter-than-black for dark theme surfaces
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/theme/Theme.kt ==================
package io.pm.finlight.ui.theme

import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext

// --- UPDATED: Dark theme color scheme using our new custom colors ---
private val DarkColorScheme =
    darkColorScheme(
        primary = FinanceGreenLight,
        secondary = GoldAccentLight,
        tertiary = Charcoal,
        background = Color(0xFF121212),
        surface = DarkSurface,
        onPrimary = Color.Black,
        onSecondary = Color.Black,
        onBackground = Color.White,
        onSurface = Color.White,
        onError = Color.Red,
    )

// --- UPDATED: Light theme color scheme using our new custom colors ---
private val LightColorScheme =
    lightColorScheme(
        primary = FinanceGreen,
        secondary = GoldAccent,
        tertiary = Charcoal,
        background = OffWhite,
        surface = Color.White,
        onPrimary = Color.White,
        onSecondary = Color.White,
        onBackground = Color(0xFF1C1B1F),
        onSurface = Color(0xFF1C1B1F),
        error = Color(0xFFB00020),
    )

@Composable
fun PersonalFinanceAppTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    dynamicColor: Boolean = true, // Set to false to always use your custom theme
    content: @Composable () -> Unit,
) {
    val colorScheme =
        when {
            dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
                val context = LocalContext.current
                if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
            }
            darkTheme -> DarkColorScheme
            else -> LightColorScheme
        }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content,
    )
}
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/ui/theme/Type.kt ==================
// FILE: app/src/main/java/io/pm/finlight/ui/theme/Type.kt

package io.pm.finlight.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.Font
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp
import io.pm.finlight.R

/**
 * NEW: Defines the custom FontFamily using the font files
 * located in the res/font directory.
 */
val Inter = FontFamily(
    Font(R.font.inter_regular, FontWeight.Normal),
    Font(R.font.inter_medium, FontWeight.Medium),
    Font(R.font.inter_bold, FontWeight.Bold)
)

/**
 * UPDATED: The Material 3 Typography object is now configured to use
 * the custom "Inter" font for all text styles, ensuring a consistent
 * and professional look across the entire application.
 */
val Typography = Typography(
    displayLarge = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Bold,
        fontSize = 57.sp,
        lineHeight = 64.sp,
        letterSpacing = (-0.25).sp,
    ),
    displayMedium = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Bold,
        fontSize = 45.sp,
        lineHeight = 52.sp,
        letterSpacing = 0.sp,
    ),
    displaySmall = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Bold,
        fontSize = 36.sp,
        lineHeight = 44.sp,
        letterSpacing = 0.sp,
    ),
    headlineLarge = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Bold,
        fontSize = 32.sp,
        lineHeight = 40.sp,
        letterSpacing = 0.sp,
    ),
    headlineMedium = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Bold,
        fontSize = 28.sp,
        lineHeight = 36.sp,
        letterSpacing = 0.sp,
    ),
    headlineSmall = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Bold,
        fontSize = 24.sp,
        lineHeight = 32.sp,
        letterSpacing = 0.sp,
    ),
    titleLarge = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Medium,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp,
    ),
    titleMedium = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Medium,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.15.sp,
    ),
    titleSmall = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Medium,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.1.sp,
    ),
    bodyLarge = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp,
    ),
    bodyMedium = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Normal,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.25.sp,
    ),
    bodySmall = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Normal,
        fontSize = 12.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.4.sp,
    ),
    labelLarge = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Medium,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.1.sp,
    ),
    labelMedium = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Medium,
        fontSize = 12.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp,
    ),
    labelSmall = TextStyle(
        fontFamily = Inter,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp,
    ),
)
-e 


================== FILE: ./app/src/main/java/io/pm/finlight/MainActivity.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/MainActivity.kt
// REASON: Implemented a splash/routing screen to handle deep links seamlessly.
// This prevents the main dashboard from "flashing" before navigating to the
// deep-linked content, improving the user experience.
// =================================================================================
package io.pm.finlight

import android.Manifest
import android.app.Activity
import android.app.Application
import android.content.pm.PackageManager
import android.os.Bundle
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.biometric.BiometricPrompt
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.unit.dp
import androidx.core.content.ContextCompat
import androidx.fragment.app.FragmentActivity
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import androidx.navigation.NavDeepLinkRequest
import androidx.navigation.NavDestination
import androidx.navigation.NavDestination.Companion.hierarchy
import androidx.navigation.NavGraph.Companion.findStartDestination
import androidx.navigation.NavHostController
import androidx.navigation.NavType
import androidx.navigation.compose.*
import androidx.navigation.navArgument
import androidx.navigation.navDeepLink
import androidx.navigation.navOptions
import coil.compose.AsyncImage
import com.google.gson.Gson
import io.pm.finlight.ui.screens.*
import io.pm.finlight.ui.theme.PersonalFinanceAppTheme
import java.net.URLDecoder
import java.util.concurrent.Executor

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()

        val settingsRepository = SettingsRepository(this)
        val hasSeenOnboarding = settingsRepository.hasSeenOnboarding()

        setContent {
            PersonalFinanceAppTheme {
                var showOnboarding by remember { mutableStateOf(!hasSeenOnboarding) }

                if (showOnboarding) {
                    val onboardingViewModel: OnboardingViewModel = viewModel(factory = OnboardingViewModelFactory(application))
                    OnboardingScreen(
                        viewModel = onboardingViewModel,
                        onOnboardingFinished = {
                            settingsRepository.setHasSeenOnboarding(true)
                            showOnboarding = false
                        }
                    )
                } else {
                    FinanceAppWithLockScreen(isInitiallyLocked = settingsRepository.isAppLockEnabledBlocking())
                }
            }
        }
    }
}

@Composable
fun FinanceAppWithLockScreen(isInitiallyLocked: Boolean) {
    val context = LocalContext.current
    val settingsRepository = remember { SettingsRepository(context) }

    var isLocked by remember { mutableStateOf(isInitiallyLocked) }
    val appLockEnabled by settingsRepository.getAppLockEnabled().collectAsState(initial = isInitiallyLocked)

    val permissionsToRequest = arrayOf(
        Manifest.permission.READ_SMS,
        Manifest.permission.RECEIVE_SMS,
        Manifest.permission.POST_NOTIFICATIONS
    )
    val permissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestMultiplePermissions()
    ) { perms ->
        val allPermissionsGranted = perms.all { it.value }
        if (!allPermissionsGranted) {
            Toast.makeText(context, "Some permissions were denied. The app may not function fully.", Toast.LENGTH_LONG).show()
        }
    }

    LaunchedEffect(key1 = true) {
        val areAllPermissionsGranted = permissionsToRequest.all {
            ContextCompat.checkSelfPermission(context, it) == PackageManager.PERMISSION_GRANTED
        }
        if (!areAllPermissionsGranted) {
            permissionLauncher.launch(permissionsToRequest)
        }
    }

    LaunchedEffect(appLockEnabled) {
        if (!appLockEnabled) {
            isLocked = false
        }
    }

    if (isLocked) {
        LockScreen(onUnlock = { isLocked = false })
    } else {
        MainAppScreen()
    }
}


@Composable
fun LockScreen(onUnlock: () -> Unit) {
    val context = LocalContext.current
    val activity = LocalContext.current as FragmentActivity
    val executor: Executor = remember { ContextCompat.getMainExecutor(context) }

    val promptInfo = remember {
        BiometricPrompt.PromptInfo.Builder()
            .setTitle("App Locked")
            .setSubtitle("Authenticate to access your finances")
            .setNegativeButtonText("Cancel")
            .build()
    }

    val biometricPrompt = remember {
        BiometricPrompt(activity, executor,
            object : BiometricPrompt.AuthenticationCallback() {
                override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {
                    super.onAuthenticationSucceeded(result)
                    onUnlock()
                }

                override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {
                    super.onAuthenticationError(errorCode, errString)
                    if (errorCode != BiometricPrompt.ERROR_NEGATIVE_BUTTON && errorCode != BiometricPrompt.ERROR_USER_CANCELED) {
                        Toast.makeText(context, "Authentication error: $errString", Toast.LENGTH_SHORT).show()
                    }
                }

                override fun onAuthenticationFailed() {
                    super.onAuthenticationFailed()
                    Toast.makeText(context, "Authentication failed", Toast.LENGTH_SHORT).show()
                }
            })
    }

    LaunchedEffect(Unit) {
        biometricPrompt.authenticate(promptInfo)
    }

    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Button(onClick = { biometricPrompt.authenticate(promptInfo) }) {
            Icon(Icons.Default.Fingerprint, contentDescription = null, modifier = Modifier.size(24.dp))
            Spacer(Modifier.width(8.dp))
            Text("Unlock App")
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainAppScreen() {
    val navController = rememberNavController()
    val dashboardViewModel: DashboardViewModel = viewModel(factory = DashboardViewModelFactory(LocalContext.current.applicationContext as Application))
    val userName by dashboardViewModel.userName.collectAsState()
    val profilePictureUri by dashboardViewModel.profilePictureUri.collectAsState()

    val bottomNavItems = listOf(
        BottomNavItem.Dashboard,
        BottomNavItem.Transactions,
        BottomNavItem.Reports,
        BottomNavItem.Profile
    )

    val navBackStackEntry by navController.currentBackStackEntryAsState()
    val currentDestination = navBackStackEntry?.destination
    val currentRoute = currentDestination?.route
    val baseCurrentRoute = currentRoute?.split("?")?.firstOrNull()?.split("/")?.firstOrNull()


    val currentTitle = if (baseCurrentRoute == BottomNavItem.Dashboard.route) {
        "Hi, $userName!"
    } else {
        screenTitles[currentRoute] ?: screenTitles[baseCurrentRoute] ?: "Finance App"
    }

    val showBottomBar = bottomNavItems.any { it.route == baseCurrentRoute }

    val fabRoutes = setOf(
        BottomNavItem.Dashboard.route,
        BottomNavItem.Transactions.route,
        "account_list",
        "recurring_transactions"
    )
    val showFab = baseCurrentRoute in fabRoutes

    val showMainTopBar = baseCurrentRoute != "transaction_detail" && baseCurrentRoute != "transaction_list" && baseCurrentRoute != "splash_screen"

    val activity = LocalContext.current as AppCompatActivity

    Scaffold(
        topBar = {
            if (showMainTopBar) {
                TopAppBar(
                    title = { Text(currentTitle) },
                    navigationIcon = {
                        if (baseCurrentRoute == BottomNavItem.Dashboard.route) {
                            AsyncImage(
                                model = profilePictureUri,
                                contentDescription = "User Profile Picture",
                                placeholder = painterResource(id = R.drawable.ic_launcher_foreground),
                                error = painterResource(id = R.drawable.ic_launcher_foreground),
                                contentScale = ContentScale.Crop,
                                modifier = Modifier
                                    .padding(start = 16.dp)
                                    .size(36.dp)
                                    .clip(CircleShape)
                                    .background(MaterialTheme.colorScheme.surfaceVariant)
                                    .clickable { navController.navigate(BottomNavItem.Profile.route) }
                            )
                        } else if (!showBottomBar) {
                            IconButton(onClick = { navController.popBackStack() }) {
                                Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                            }
                        }
                    },
                    actions = {
                        if (currentRoute == BottomNavItem.Dashboard.route) {
                            IconButton(onClick = { navController.navigate("search_screen") }) {
                                Icon(Icons.Default.Search, contentDescription = "Search")
                            }
                        }
                    }
                )
            }
        },
        bottomBar = {
            if (showBottomBar) {
                NavigationBar {
                    bottomNavItems.forEach { screen ->
                        val isSelected = currentDestination?.hierarchy?.any { it.route == screen.route } == true
                        NavigationBarItem(
                            icon = { Icon(screen.icon, contentDescription = screen.label) },
                            label = { Text(screen.label) },
                            selected = isSelected,
                            onClick = {
                                navController.navigate(screen.route) {
                                    popUpTo(navController.graph.findStartDestination().id) { saveState = true }
                                    launchSingleTop = true
                                    restoreState = true
                                }
                            }
                        )
                    }
                }
            }
        },
        floatingActionButton = {
            if (showFab) {
                FloatingActionButton(onClick = {
                    when (baseCurrentRoute) {
                        BottomNavItem.Dashboard.route, BottomNavItem.Transactions.route -> {
                            navController.navigate("add_transaction")
                        }
                        "account_list" -> {
                            navController.navigate("add_account")
                        }
                        "recurring_transactions" -> {
                            navController.navigate("add_recurring_transaction")
                        }
                    }
                }) {
                    Icon(Icons.Filled.Add, contentDescription = "Add")
                }
            }
        }
    ) { innerPadding ->
        AppNavHost(
            navController = navController,
            modifier = Modifier.padding(innerPadding),
            dashboardViewModel = dashboardViewModel,
            activity = activity
        )
    }
}


@Composable
fun AppNavHost(
    navController: NavHostController,
    modifier: Modifier = Modifier,
    dashboardViewModel: DashboardViewModel,
    activity: AppCompatActivity
) {
    val settingsViewModel: SettingsViewModel = viewModel()
    val transactionViewModel: TransactionViewModel = viewModel()
    val accountViewModel: AccountViewModel = viewModel()
    val categoryViewModel: CategoryViewModel = viewModel()
    val budgetViewModel: BudgetViewModel = viewModel()
    val profileViewModel: ProfileViewModel = viewModel()

    NavHost(
        navController = navController,
        startDestination = "splash_screen",
        modifier = modifier
    ) {
        composable("splash_screen") {
            SplashScreen(navController = navController, activity = activity)
        }

        composable(BottomNavItem.Dashboard.route) {
            DashboardScreen(navController, dashboardViewModel, budgetViewModel)
        }
        composable(
            route = BottomNavItem.Transactions.route
        ) {
            TransactionListScreen(
                navController = navController,
                viewModel = transactionViewModel
            )
        }
        composable(BottomNavItem.Reports.route) { ReportsScreen(navController, viewModel()) }
        composable(BottomNavItem.Profile.route) { ProfileScreen(navController, profileViewModel) }
        composable("edit_profile") { EditProfileScreen(navController, profileViewModel) }
        composable("settings_screen") { SettingsScreen(navController, settingsViewModel) }
        composable("csv_validation_screen") { CsvValidationScreen(navController, settingsViewModel) }
        composable("search_screen") { SearchScreen(navController) }
        composable(
            route = "review_sms_screen",
            deepLinks = listOf(navDeepLink { uriPattern = "app://finlight.pm.io/review_sms" })
        ) { ReviewSmsScreen(navController, settingsViewModel) }

        composable(
            route = "approve_transaction_screen?potentialTxnJson={potentialTxnJson}",
            arguments = listOf(
                navArgument("potentialTxnJson") { type = NavType.StringType }
            ),
            deepLinks = listOf(navDeepLink { uriPattern = "app://finlight.pm.io/approve_sms?potentialTxnJson={potentialTxnJson}" })
        ) { backStackEntry ->
            val json = backStackEntry.arguments?.getString("potentialTxnJson")
            val potentialTxn = Gson().fromJson(URLDecoder.decode(json, "UTF-8"), PotentialTransaction::class.java)

            ApproveTransactionScreen(
                navController = navController,
                transactionViewModel = transactionViewModel,
                settingsViewModel = settingsViewModel,
                potentialTxn = potentialTxn
            )
        }

        // --- UPDATED: Route now accepts optional arguments for editing a CSV row ---
        composable(
            "add_transaction?isCsvEdit={isCsvEdit}&csvLineNumber={csvLineNumber}&initialDataJson={initialDataJson}",
            arguments = listOf(
                navArgument("isCsvEdit") {
                    type = NavType.BoolType
                    defaultValue = false
                },
                navArgument("csvLineNumber") {
                    type = NavType.IntType
                    defaultValue = -1
                },
                navArgument("initialDataJson") {
                    type = NavType.StringType
                    nullable = true
                    defaultValue = null
                }
            )
        ) { backStackEntry ->
            val arguments = requireNotNull(backStackEntry.arguments)
            val isCsvEdit = arguments.getBoolean("isCsvEdit")
            val csvLineNumber = arguments.getInt("csvLineNumber")
            val initialDataJson = arguments.getString("initialDataJson")

            AddTransactionScreen(
                navController = navController,
                viewModel = transactionViewModel,
                isCsvEdit = isCsvEdit,
                csvLineNumber = csvLineNumber,
                initialDataJson = initialDataJson?.let { URLDecoder.decode(it, "UTF-8") }
            )
        }

        composable(
            route = "transaction_detail/{transactionId}",
            arguments = listOf(navArgument("transactionId") { type = NavType.IntType }),
            deepLinks = listOf(navDeepLink { uriPattern = "app://finlight.pm.io/transaction_detail/{transactionId}" })
        ) { backStackEntry ->
            val transactionId = backStackEntry.arguments!!.getInt("transactionId")
            TransactionDetailScreen(navController, transactionId, transactionViewModel)
        }

        composable("account_list") { AccountListScreen(navController, accountViewModel) }
        composable("add_account") { AddAccountScreen(navController, accountViewModel) }
        composable("edit_account/{accountId}", arguments = listOf(navArgument("accountId") { type = NavType.IntType })) { backStackEntry ->
            EditAccountScreen(navController, accountViewModel, backStackEntry.arguments!!.getInt("accountId"))
        }
        composable("account_detail/{accountId}", arguments = listOf(navArgument("accountId") { type = NavType.IntType })) { backStackEntry ->
            AccountDetailScreen(navController, accountViewModel, backStackEntry.arguments!!.getInt("accountId"))
        }
        composable("budget_screen") { BudgetScreen(navController, budgetViewModel) }
        composable("add_budget") { AddEditBudgetScreen(navController, budgetViewModel, null) }
        composable(
            "edit_budget/{budgetId}",
            arguments = listOf(navArgument("budgetId") { type = NavType.IntType })
        ) { backStackEntry ->
            AddEditBudgetScreen(navController, budgetViewModel, backStackEntry.arguments?.getInt("budgetId"))
        }
        composable("category_list") { CategoryListScreen(navController, categoryViewModel) }
        composable("tag_management") { TagManagementScreen() }
        composable("recurring_transactions") { RecurringTransactionScreen(navController) }
        composable("add_recurring_transaction") { AddRecurringTransactionScreen(navController) }
    }
}

/**
 * A new composable that acts as a routing screen. It checks the intent
 * for a deep link and navigates accordingly, preventing the dashboard from
 * flashing on screen during a deep link launch.
 */
@Composable
fun SplashScreen(navController: NavHostController, activity: Activity) {
    LaunchedEffect(key1 = Unit) {
        val deepLinkUri = activity.intent?.data
        if (deepLinkUri != null) {
            // --- BUG FIX: Manually build the back stack for a seamless experience ---
            // First, navigate to the main screen of the app.
            navController.navigate(BottomNavItem.Dashboard.route) {
                // Pop the splash screen off the stack to prevent going back to it.
                popUpTo("splash_screen") { inclusive = true }
            }
            // Then, navigate to the specific deep-linked content.
            // This places the dashboard on the back stack before the detail screen.
            navController.navigate(deepLinkUri)
            // Clear the intent data so it's not reused on process recreation.
            activity.intent.data = null
        } else {
            // It's a normal launch, go to the dashboard
            navController.navigate(BottomNavItem.Dashboard.route) {
                popUpTo("splash_screen") { inclusive = true }
            }
        }
    }

    // Show a loading indicator while the navigation logic runs
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        CircularProgressIndicator()
    }
}
-e 


================== FILE: ./app/src/main/java/RecurringTransactionRepository.kt ==================
package io.pm.finlight

import kotlinx.coroutines.flow.Flow

class RecurringTransactionRepository(private val recurringTransactionDao: RecurringTransactionDao) {
    fun getAll(): Flow<List<RecurringTransaction>> {
        return recurringTransactionDao.getAll()
    }

    suspend fun insert(recurringTransaction: RecurringTransaction) {
        recurringTransactionDao.insert(recurringTransaction)
    }
}
-e 


================== FILE: ./app/src/main/java/OnboardingViewModelFactory.kt ==================
// FILE: app/src/main/java/io/pm/finlight/OnboardingViewModelFactory.kt

package io.pm.finlight

import android.app.Application
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider

/**
 * Factory for creating an OnboardingViewModel.
 */
class OnboardingViewModelFactory(private val application: Application) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(OnboardingViewModel::class.java)) {
            val db = AppDatabase.getInstance(application)
            // --- UPDATED: AccountRepository is no longer needed for onboarding ---
            val categoryRepository = CategoryRepository(db.categoryDao())
            val settingsRepository = SettingsRepository(application)

            @Suppress("UNCHECKED_CAST")
            // --- UPDATED: Pass only the required dependencies ---
            return OnboardingViewModel(categoryRepository, settingsRepository) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
-e 


================== FILE: ./app/src/main/java/TagRepository.kt ==================
package io.pm.finlight

import kotlinx.coroutines.flow.Flow

/**
 * Repository that abstracts access to the tag data source.
 * Now includes update and delete logic.
 */
class TagRepository(
    private val tagDao: TagDao,
    private val transactionDao: TransactionDao
) {

    val allTags: Flow<List<Tag>> = tagDao.getAllTags()

    // --- FIX: Modified to return the new row's ID from the DAO ---
    suspend fun insert(tag: Tag): Long {
        return tagDao.insert(tag)
    }

    suspend fun update(tag: Tag) {
        tagDao.update(tag)
    }

    suspend fun delete(tag: Tag) {
        tagDao.delete(tag)
    }

    suspend fun isTagInUse(tagId: Int): Boolean {
        return transactionDao.countTransactionsForTag(tagId) > 0
    }
}
-e 


================== FILE: ./app/src/main/java/MonthlySummary.kt ==================
package io.pm.finlight

/**
 * A data class to hold the results of a GROUP BY query for monthly summaries.
 */
data class MonthlySummary(
    val year: Int,
    val month: Int,
    val totalAmount: Double,
)
-e 


================== FILE: ./app/src/main/java/CategoryRepository.kt ==================
package io.pm.finlight

import kotlinx.coroutines.flow.Flow

/**
 * Repository that abstracts access to the category data source.
 */
class CategoryRepository(private val categoryDao: CategoryDao) {
    /**
     * Retrieves all categories from the category table, ordered by name.
     */
    val allCategories: Flow<List<Category>> = categoryDao.getAllCategories()

    /**
     * Inserts a category in a non-blocking way.
     */
    suspend fun insert(category: Category) {
        categoryDao.insert(category)
    }

    /**
     * Inserts a list of categories in a non-blocking way.
     */
    suspend fun insertAll(categories: List<Category>) {
        categoryDao.insertAll(categories)
    }

    /**
     * Updates a category in a non-blocking way.
     */
    suspend fun update(category: Category) {
        categoryDao.update(category)
    }

    /**
     * Deletes a category in a non-blocking way.
     */
    suspend fun delete(category: Category) {
        categoryDao.delete(category)
    }
}
-e 


================== FILE: ./app/src/main/java/MerchantMappingDao.kt ==================
package io.pm.finlight

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import kotlinx.coroutines.flow.Flow

@Dao
interface MerchantMappingDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(mapping: MerchantMapping)

    // --- NEW: Function to insert a list of mappings during import ---
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(mappings: List<MerchantMapping>)

    // --- NEW: Function to clear the table during import ---
    @Query("DELETE FROM merchant_mappings")
    suspend fun deleteAll()

    @Query("SELECT * FROM merchant_mappings")
    fun getAllMappings(): Flow<List<MerchantMapping>>

    @Query("SELECT * FROM merchant_mappings WHERE smsSender = :sender")
    suspend fun getMappingForSender(sender: String): MerchantMapping?
}
-e 


================== FILE: ./app/src/main/java/MerchantMappingRepository.kt ==================
package io.pm.finlight

import kotlinx.coroutines.flow.Flow

/**
 * Repository that abstracts access to the MerchantMapping data source.
 */
class MerchantMappingRepository(private val merchantMappingDao: MerchantMappingDao) {
    /**
     * Retrieves all user-defined merchant mappings from the database.
     */
    val allMappings: Flow<List<MerchantMapping>> = merchantMappingDao.getAllMappings()

    /**
     * Inserts a new or updated mapping into the database.
     */
    suspend fun insert(mapping: MerchantMapping) {
        merchantMappingDao.insert(mapping)
    }

    /**
     * Gets a specific mapping for a given SMS sender address.
     */
    suspend fun getMappingForSender(sender: String): MerchantMapping? {
        return merchantMappingDao.getMappingForSender(sender)
    }
}
-e 


================== FILE: ./app/src/main/java/ProfileViewModel.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/ProfileViewModel.kt
// REASON: Added a function to handle updating the user's name in SharedPreferences.
// =================================================================================
package io.pm.finlight

import android.app.Application
import android.net.Uri
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream

class ProfileViewModel(application: Application) : AndroidViewModel(application) {

    private val settingsRepository = SettingsRepository(application)
    private val context = application

    val userName: StateFlow<String> = settingsRepository.getUserName()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = "User"
        )

    val profilePictureUri: StateFlow<String?> = settingsRepository.getProfilePictureUri()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = null
        )

    /**
     * Saves the cropped image from the source URI to internal storage and persists its path.
     */
    fun saveProfilePictureUri(sourceUri: Uri?) {
        viewModelScope.launch {
            if (sourceUri == null) {
                settingsRepository.saveProfilePictureUri(null)
                return@launch
            }
            // Copy the file to internal storage and get the new path
            val localPath = saveImageToInternalStorage(sourceUri)
            // Save the path to our new local file
            settingsRepository.saveProfilePictureUri(localPath)
        }
    }

    // --- NEW: Function to save the updated user name ---
    fun updateUserName(name: String) {
        viewModelScope.launch {
            if (name.isNotBlank()) {
                settingsRepository.saveUserName(name)
            }
        }
    }

    /**
     * Copies a file from a given content URI to the app's private internal storage.
     * @param sourceUri The temporary URI of the file to copy (e.g., from the image cropper).
     * @return The absolute path to the newly created file, or null if an error occurred.
     */
    private suspend fun saveImageToInternalStorage(sourceUri: Uri): String? {
        return withContext(Dispatchers.IO) {
            try {
                // Open an input stream from the source URI provided by the cropper
                val inputStream = context.contentResolver.openInputStream(sourceUri)

                // Create a destination file in the app's private 'files' directory
                val fileName = "profile_${System.currentTimeMillis()}.jpg"
                val file = File(context.filesDir, fileName)

                // Open an output stream to the destination file
                val outputStream = FileOutputStream(file)

                // Copy the bytes from the input stream to the output stream
                inputStream?.use { input ->
                    outputStream.use { output ->
                        input.copyTo(output)
                    }
                }

                // Return the path of the file we just created
                file.absolutePath
            } catch (e: Exception) {
                Log.e("ProfileViewModel", "Error saving image to internal storage", e)
                null
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/LoginRequest.kt ==================
package io.pm.finlight

data class LoginRequest(
    val email: String,
    val password: String,
)
-e 


================== FILE: ./app/src/main/java/OnboardingViewModel.kt ==================
package io.pm.finlight

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

class OnboardingViewModel(
    private val categoryRepository: CategoryRepository,
    private val settingsRepository: SettingsRepository
) : ViewModel() {

    private val _userName = MutableStateFlow("")
    val userName = _userName.asStateFlow()

    private val _monthlyBudget = MutableStateFlow("")
    val monthlyBudget = _monthlyBudget.asStateFlow()

    fun onNameChanged(newName: String) {
        _userName.value = newName
    }

    fun onBudgetChanged(newBudget: String) {
        if (newBudget.all { it.isDigit() }) {
            _monthlyBudget.value = newBudget
        }
    }

    fun finishOnboarding() {
        viewModelScope.launch {
            if (_userName.value.isNotBlank()) {
                settingsRepository.saveUserName(_userName.value)
            }

            // --- BUG FIX: Ensure the full list of predefined categories is inserted ---
            // This replaces any faulty logic that was creating a few default categories.
            // It guarantees all users start with the complete, visually-rich category set.
            categoryRepository.insertAll(CategoryIconHelper.predefinedCategories)

            val budgetFloat = _monthlyBudget.value.toFloatOrNull() ?: 0f
            if (budgetFloat > 0) {
                settingsRepository.saveOverallBudgetForCurrentMonth(budgetFloat)
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/SmsRepository.kt ==================
package io.pm.finlight

import android.content.Context
import android.provider.Telephony
import android.util.Log

/**
 * A repository class dedicated to handling data operations related to SMS messages.
 * This abstracts the logic of querying the Android ContentResolver away from ViewModels or Workers.
 */
class SmsRepository(private val context: Context) {
    /**
     * Fetches all SMS messages from the device's inbox.
     * @return A list of SmsMessage objects.
     */
    fun fetchAllSms(startDate: Long?): List<SmsMessage> {
        val smsList = mutableListOf<SmsMessage>()
        // Define the columns we want to retrieve
        val projection =
            arrayOf(
                Telephony.Sms._ID,
                Telephony.Sms.ADDRESS,
                Telephony.Sms.BODY,
                Telephony.Sms.DATE,
            )
        val selection: String?
        val selectionArgs: Array<String>?

        if (startDate != null) {
            selection = "${Telephony.Sms.DATE} >= ?"
            selectionArgs = arrayOf(startDate.toString())
            Log.d("SmsRepository", "Querying SMS with start date: $startDate")
        } else {
            selection = null
            selectionArgs = null
            Log.d("SmsRepository", "Querying all SMS messages.")
        }

        // Query the SMS inbox, sorting by date in descending order
        // --- BUG FIX: Pass the selection and selectionArgs to the query ---
        val cursor =
            context.contentResolver.query(
                Telephony.Sms.Inbox.CONTENT_URI,
                projection,
                selection, // Correctly pass the selection string
                selectionArgs, // Correctly pass the selection arguments
                "date DESC",
            )

        cursor?.use {
            // Get column indices once for efficiency
            val idIndex = it.getColumnIndexOrThrow(Telephony.Sms._ID)
            val addressIndex = it.getColumnIndexOrThrow(Telephony.Sms.ADDRESS)
            val bodyIndex = it.getColumnIndexOrThrow(Telephony.Sms.BODY)
            val dateIndex = it.getColumnIndexOrThrow(Telephony.Sms.DATE)

            while (it.moveToNext()) {
                smsList.add(
                    SmsMessage(
                        id = it.getLong(idIndex),
                        sender = it.getString(addressIndex) ?: "Unknown",
                        body = it.getString(bodyIndex) ?: "",
                        date = it.getLong(dateIndex),
                    ),
                )
            }
        }
        return smsList
    }
}
-e 


================== FILE: ./app/src/main/java/BudgetViewModel.kt ==================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

class BudgetViewModel(application: Application) : AndroidViewModel(application) {
    private val budgetRepository: BudgetRepository
    private val settingsRepository: SettingsRepository
    private val categoryRepository: CategoryRepository

    private val calendar: Calendar = Calendar.getInstance()
    private val currentMonth: Int
    private val currentYear: Int

    val budgetsForCurrentMonth: StateFlow<List<BudgetWithSpending>>
    val overallBudget: StateFlow<Float>
    val allCategories: Flow<List<Category>>
    val availableCategoriesForNewBudget: Flow<List<Category>>
    val totalSpending: StateFlow<Double>

    init {
        val db = AppDatabase.getInstance(application)
        budgetRepository = BudgetRepository(db.budgetDao())
        settingsRepository = SettingsRepository(application)
        categoryRepository = CategoryRepository(db.categoryDao())

        currentMonth = calendar.get(Calendar.MONTH) + 1
        currentYear = calendar.get(Calendar.YEAR)

        val yearMonthString = SimpleDateFormat("yyyy-MM", Locale.getDefault()).format(calendar.time)

        // --- FIX: Corrected the method name from getBudgetsWithSpendingForMonth to getBudgetsForMonthWithSpending ---
        // This resolves the compilation error.
        budgetsForCurrentMonth = budgetRepository.getBudgetsForMonthWithSpending(yearMonthString, currentMonth, currentYear)
            .stateIn(
                scope = viewModelScope,
                started = SharingStarted.WhileSubscribed(5000),
                initialValue = emptyList()
            )

        allCategories = categoryRepository.allCategories

        overallBudget =
            settingsRepository.getOverallBudgetForMonth(currentYear, currentMonth)
                .stateIn(
                    scope = viewModelScope,
                    started = SharingStarted.WhileSubscribed(5000),
                    initialValue = 0f,
                )

        availableCategoriesForNewBudget =
            combine(allCategories, budgetsForCurrentMonth) { categories, budgets ->
                val budgetedCategoryNames = budgets.map { it.budget.categoryName }.toSet()
                categories.filter { category -> category.name !in budgetedCategoryNames }
            }

        totalSpending = budgetsForCurrentMonth.flatMapLatest { budgets ->
            if (budgets.isEmpty()) {
                flowOf(0.0)
            } else {
                val spendingFlows = budgets.map {
                    getActualSpending(it.budget.categoryName)
                }
                combine(spendingFlows) { amounts ->
                    amounts.sum()
                }
            }
        }.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = 0.0
        )
    }

    fun getActualSpending(categoryName: String): Flow<Double> {
        return budgetRepository.getActualSpendingForCategory(categoryName, currentMonth, currentYear)
            .map { spending -> spending ?: 0.0 }
    }

    fun addCategoryBudget(
        categoryName: String,
        amountStr: String,
    ) {
        val amount = amountStr.toDoubleOrNull() ?: return
        if (amount <= 0 || categoryName.isBlank()) {
            return
        }
        val newBudget =
            Budget(
                categoryName = categoryName,
                amount = amount,
                month = currentMonth,
                year = currentYear,
            )
        viewModelScope.launch {
            budgetRepository.insert(newBudget)
        }
    }

    fun saveOverallBudget(budgetStr: String) {
        val budgetFloat = budgetStr.toFloatOrNull() ?: 0f
        settingsRepository.saveOverallBudgetForCurrentMonth(budgetFloat)
    }

    fun getBudgetById(id: Int): Flow<Budget?> {
        return budgetRepository.getBudgetById(id)
    }

    fun updateBudget(budget: Budget) =
        viewModelScope.launch {
            budgetRepository.update(budget)
        }

    fun deleteBudget(budget: Budget) =
        viewModelScope.launch {
            budgetRepository.delete(budget)
        }

    fun getCurrentMonthYearString(): String {
        return SimpleDateFormat("MMMM yyyy", Locale.getDefault()).format(calendar.time)
    }
}
-e 


================== FILE: ./app/src/main/java/AppDatabase.kt ==================
package io.pm.finlight

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import java.util.Calendar

@Database(
    entities = [
        Transaction::class,
        Account::class,
        Category::class,
        Budget::class,
        MerchantMapping::class,
        RecurringTransaction::class,
        Tag::class,
        TransactionTagCrossRef::class,
        TransactionImage::class
    ],
    version = 11,
    exportSchema = true,
)
abstract class AppDatabase : RoomDatabase() {
    abstract fun transactionDao(): TransactionDao
    abstract fun accountDao(): AccountDao
    abstract fun categoryDao(): CategoryDao
    abstract fun budgetDao(): BudgetDao
    abstract fun merchantMappingDao(): MerchantMappingDao
    abstract fun recurringTransactionDao(): RecurringTransactionDao
    abstract fun tagDao(): TagDao

    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null

        val MIGRATION_1_2 = object : Migration(1, 2) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE transactions ADD COLUMN transactionType TEXT NOT NULL DEFAULT 'expense'")
                db.execSQL("UPDATE transactions SET transactionType = 'income' WHERE amount > 0")
                db.execSQL("UPDATE transactions SET amount = ABS(amount)")
            }
        }
        val MIGRATION_2_3 = object : Migration(2, 3) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("CREATE TABLE IF NOT EXISTS `merchant_mappings` (`smsSender` TEXT NOT NULL, `merchantName` TEXT NOT NULL, PRIMARY KEY(`smsSender`))")
            }
        }
        val MIGRATION_3_4 = object : Migration(3, 4) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE transactions ADD COLUMN sourceSmsId INTEGER")
            }
        }
        val MIGRATION_4_5 = object : Migration(4, 5) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("CREATE TABLE IF NOT EXISTS `recurring_transactions` (`id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, `description` TEXT NOT NULL, `amount` REAL NOT NULL, `transactionType` TEXT NOT NULL, `recurrenceInterval` TEXT NOT NULL, `startDate` INTEGER NOT NULL, `accountId` INTEGER NOT NULL, `categoryId` INTEGER, FOREIGN KEY(`accountId`) REFERENCES `accounts`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE, FOREIGN KEY(`categoryId`) REFERENCES `categories`(`id`) ON UPDATE NO ACTION ON DELETE SET NULL)")
                db.execSQL("CREATE INDEX IF NOT EXISTS `index_recurring_transactions_accountId` ON `recurring_transactions` (`accountId`)")
                db.execSQL("CREATE INDEX IF NOT EXISTS `index_recurring_transactions_categoryId` ON `recurring_transactions` (`categoryId`)")
            }
        }
        val MIGRATION_5_6 = object : Migration(5, 6) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("CREATE TABLE IF NOT EXISTS `tags` (`id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, `name` TEXT NOT NULL)")
                db.execSQL("CREATE UNIQUE INDEX IF NOT EXISTS `index_tags_name` ON `tags` (`name`)")
                db.execSQL("CREATE TABLE IF NOT EXISTS `transaction_tag_cross_ref` (`transactionId` INTEGER NOT NULL, `tagId` INTEGER NOT NULL, PRIMARY KEY(`transactionId`, `tagId`), FOREIGN KEY(`transactionId`) REFERENCES `transactions`(`id`) ON DELETE CASCADE, FOREIGN KEY(`tagId`) REFERENCES `tags`(`id`) ON DELETE CASCADE)")
            }
        }
        val MIGRATION_6_7 = object : Migration(6, 7) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE transactions ADD COLUMN sourceSmsHash TEXT")
            }
        }
        val MIGRATION_7_8 = object : Migration(7, 8) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE transactions ADD COLUMN source TEXT NOT NULL DEFAULT 'Manual Entry'")
                db.execSQL("UPDATE transactions SET source = 'Reviewed Import' WHERE sourceSmsId IS NOT NULL")
            }
        }
        val MIGRATION_8_9 = object : Migration(8, 9) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE categories ADD COLUMN iconKey TEXT NOT NULL DEFAULT 'category'")
            }
        }
        val MIGRATION_9_10 = object : Migration(9, 10) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("ALTER TABLE categories ADD COLUMN colorKey TEXT NOT NULL DEFAULT 'gray_light'")
            }
        }
        val MIGRATION_10_11 = object : Migration(10, 11) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("""
                    CREATE TABLE IF NOT EXISTS `transaction_images` (
                        `id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                        `transactionId` INTEGER NOT NULL,
                        `imageUri` TEXT NOT NULL,
                        FOREIGN KEY(`transactionId`) REFERENCES `transactions`(`id`) ON DELETE CASCADE
                    )
                """)
                db.execSQL("CREATE INDEX IF NOT EXISTS `index_transaction_images_transactionId` ON `transaction_images` (`transactionId`)")
            }
        }

        fun getInstance(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance =
                    Room.databaseBuilder(context.applicationContext, AppDatabase::class.java, "finance_database")
                        .addMigrations(MIGRATION_1_2, MIGRATION_2_3, MIGRATION_3_4, MIGRATION_4_5, MIGRATION_5_6, MIGRATION_6_7, MIGRATION_7_8, MIGRATION_8_9, MIGRATION_9_10, MIGRATION_10_11)
                        .addCallback(DatabaseCallback(context))
                        .build()
                INSTANCE = instance
                instance
            }
        }

        private class DatabaseCallback(private val context: Context) : RoomDatabase.Callback() {
            override fun onCreate(db: SupportSQLiteDatabase) {
                super.onCreate(db)
                CoroutineScope(Dispatchers.IO).launch {
                    populateDatabase(getInstance(context))
                }
            }

            override fun onOpen(db: SupportSQLiteDatabase) {
                super.onOpen(db)
                // This remains as a good failsafe check
                CoroutineScope(Dispatchers.IO).launch {
                    val database = getInstance(context)
                    val categoryDao = database.categoryDao()
                    val categories = categoryDao.getAllCategories().first()
                    if (categories.isEmpty()) {
                        categoryDao.insertAll(CategoryIconHelper.predefinedCategories)
                    }
                }
            }

            // --- BUG FIX: Corrected the logic to populate the database in the right order ---
            suspend fun populateDatabase(db: AppDatabase) {
                val accountDao = db.accountDao()
                val categoryDao = db.categoryDao()
                val transactionDao = db.transactionDao()
                val budgetDao = db.budgetDao()

                // 1. Clear all existing data
                transactionDao.deleteAll()
                budgetDao.deleteAll()
                categoryDao.deleteAll()
                accountDao.deleteAll()

                // 2. Populate with defaults in the correct order
                // FIRST, insert categories so they can be referenced by transactions/budgets.
                categoryDao.insertAll(CategoryIconHelper.predefinedCategories)

                // SECOND, insert accounts.
                accountDao.insertAll(
                    listOf(
                        Account(id = 1, name = "SBI", type = "Savings"),
                        Account(id = 2, name = "HDFC", type = "Credit Card"),
                        Account(id = 3, name = "ICICI", type = "Savings"),
                    ),
                )

                // THIRD, insert sample data that references the defaults.
                val calendar = Calendar.getInstance()
                calendar.set(Calendar.DAY_OF_MONTH, 5)
                val incomeDate = calendar.timeInMillis
                calendar.set(Calendar.DAY_OF_MONTH, 10)
                val expenseDate1 = calendar.timeInMillis
                calendar.set(Calendar.DAY_OF_MONTH, 15)
                val expenseDate2 = calendar.timeInMillis

                transactionDao.insertAll(
                    listOf(
                        Transaction(
                            description = "Monthly Salary",
                            categoryId = 12, // "Salary"
                            amount = 75000.0,
                            date = incomeDate,
                            accountId = 1,
                            notes = "Paycheck",
                            transactionType = "income",
                        ),
                        Transaction(
                            description = "Grocery Shopping",
                            categoryId = 6, // "Groceries"
                            amount = 4500.0,
                            date = expenseDate1,
                            accountId = 2,
                            notes = "Weekly groceries",
                            transactionType = "expense",
                        ),
                        Transaction(
                            description = "Dinner with friends",
                            categoryId = 4, // "Food & Drinks"
                            amount = 1200.0,
                            date = expenseDate2,
                            accountId = 2,
                            notes = null,
                            transactionType = "expense",
                        )
                    )
                )

                val month = calendar.get(Calendar.MONTH) + 1
                val year = calendar.get(Calendar.YEAR)

                budgetDao.insertAll(
                    listOf(
                        Budget(categoryName = "Groceries", amount = 10000.0, month = month, year = year),
                        Budget(categoryName = "Food & Drinks", amount = 5000.0, month = month, year = year),
                        Budget(categoryName = "Bills", amount = 2000.0, month = month, year = year),
                    ),
                )
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/SmsParser.kt ==================
package io.pm.finlight

// Removed android.util.Log import as it's not needed and causes test failures.

data class PotentialAccount(
    val formattedName: String, // e.g., "SBI - xx3201"
    val accountType: String,   // e.g., "Credit Card"
)

object SmsParser {
    // private const val TAG = "SmsParser" // No longer needed
    private val AMOUNT_REGEX = "(?:rs|inr|rs\\.?)\\s*([\\d,]+\\.?\\d*)".toRegex(RegexOption.IGNORE_CASE)
    private val EXPENSE_KEYWORDS_REGEX = "\\b(spent|debited|paid|charged|payment of|purchase of)\\b".toRegex(RegexOption.IGNORE_CASE)
    private val INCOME_KEYWORDS_REGEX = "\\b(credited|received|deposited|refund of)\\b".toRegex(RegexOption.IGNORE_CASE)

    // --- FIX: Added "has been credited to" to ignore informational NEFT messages ---
    private val NEGATIVE_KEYWORDS_REGEX = "\\b(invoice of|payment of.*is successful|has been credited to)\\b".toRegex(RegexOption.IGNORE_CASE)


    // --- REFINED: Reordered patterns and made them more specific ---
    private val ACCOUNT_PATTERNS =
        listOf(
            // --- FIX: Added new, more specific patterns for ICICI and HDFC ---
            "(ICICI Bank) Account XX(\\d{3,4}) credited".toRegex(RegexOption.IGNORE_CASE),
            "(HDFC Bank) : NEFT money transfer".toRegex(RegexOption.IGNORE_CASE),
            "spent from (Pluxee)\\s*(Meal Card wallet), card no\\.\\s*xx(\\d{4})".toRegex(RegexOption.IGNORE_CASE),
            "on your (SBI) (Credit Card) ending with (\\d{4})".toRegex(RegexOption.IGNORE_CASE),
            "On (HDFC Bank) (Card) (\\d{4})".toRegex(RegexOption.IGNORE_CASE),
            "(ICICI Bank) Acct XX(\\d{3,4}) debited".toRegex(RegexOption.IGNORE_CASE),
            "Acct XX(\\d{3,4}) is credited.*-(ICICI Bank)".toRegex(RegexOption.IGNORE_CASE)
        )

    private val MERCHANT_REGEX_PATTERNS =
        listOf(
            "(?:credited|received).*from\\s+([A-Za-z0-9\\s.&'-]+?)(?:\\.|$)".toRegex(RegexOption.IGNORE_CASE),
            "at\\s*\\.\\.\\s*([A-Za-z0-9_\\s]+)\\s*on".toRegex(RegexOption.IGNORE_CASE),
            ";\\s*([A-Za-z0-9\\s.&'-]+?)\\s*credited".toRegex(RegexOption.IGNORE_CASE),
            "UPI.*(?:to|\\bat\\b)\\s+([A-Za-z0-9\\s.&'()]+?)(?:\\s+on|\\s+Ref|$)".toRegex(RegexOption.IGNORE_CASE),
            "to\\s+([a-zA-Z0-9.\\-_]+@[a-zA-Z0-9]+)".toRegex(RegexOption.IGNORE_CASE),
            "(?:\\bat\\b|to\\s+)([A-Za-z0-9\\s.&'-]+?)(?:\\s+on\\s+|\\s+for\\s+|\\.|$|\\s+was\\s+)".toRegex(RegexOption.IGNORE_CASE),
            // --- FIX: Made the colon optional and the capture non-greedy to correctly parse NEFT info ---
            "Info:?\\s*([A-Za-z0-9\\s.&'-]+?)(?:\\.|$)".toRegex(RegexOption.IGNORE_CASE)
        )

    private fun parseAccount(smsBody: String, sender: String): PotentialAccount? {
        for (pattern in ACCOUNT_PATTERNS) {
            val match = pattern.find(smsBody)
            if (match != null) {
                val pString = pattern.pattern
                // --- REFINED: Use pattern string to determine logic, which is more robust ---
                return when {
                    // --- FIX: Handle new ICICI credit pattern ---
                    pString.startsWith("(ICICI Bank) Account") -> {
                        val bank = match.groupValues[1].trim()
                        val number = match.groupValues[2].trim()
                        PotentialAccount(formattedName = "$bank - xx$number", accountType = "Bank Account")
                    }
                    // --- FIX: Handle new HDFC NEFT pattern ---
                    pString.startsWith("(HDFC Bank) : NEFT") -> {
                        val bank = match.groupValues[1].trim()
                        PotentialAccount(formattedName = bank, accountType = "Bank Account")
                    }
                    pString.startsWith("spent from") -> {
                        val group1 = match.groupValues[1].trim() // Brand (Pluxee)
                        val group2 = match.groupValues[2].trim() // Type (Meal Card wallet)
                        val number = match.groupValues[3].trim() // Number
                        PotentialAccount(formattedName = "$group1 - xx$number", accountType = group2)
                    }
                    // Handles SBI, HDFC
                    pString.startsWith("on your") || pString.startsWith("On") -> {
                        val group1 = match.groupValues[1].trim() // Bank or brand
                        val group2 = match.groupValues[2].trim() // Type
                        val number = match.groupValues[3].trim() // Number
                        PotentialAccount(formattedName = "$group1 - xx$number", accountType = group2)
                    }
                    // Handles ICICI Debit
                    pString.contains("debited") -> {
                        val bank = match.groupValues[1].trim()
                        val number = match.groupValues[2].trim()
                        PotentialAccount(formattedName = "$bank - xx$number", accountType = "Savings Account")
                    }
                    // Handles ICICI Credit
                    pString.contains("is credited") -> {
                        val number = match.groupValues[1].trim()
                        val bank = match.groupValues[2].trim()
                        PotentialAccount(formattedName = "$bank - xx$number", accountType = "Savings Account")
                    }
                    else -> null
                }
            }
        }
        return null
    }

    fun parse(
        sms: SmsMessage,
        mappings: Map<String, String>,
    ): PotentialTransaction? {
        val messageBody = sms.body

        // --- FIX: Check for negative keywords first to reject non-transactional messages ---
        if (NEGATIVE_KEYWORDS_REGEX.containsMatchIn(messageBody)) {
            return null
        }

        val amountMatch = AMOUNT_REGEX.find(messageBody)
        val amount =
            amountMatch?.groups?.get(1)?.value?.replace(",", "")?.toDoubleOrNull()
                ?: return null

        val transactionType =
            when {
                EXPENSE_KEYWORDS_REGEX.containsMatchIn(messageBody) -> "expense"
                INCOME_KEYWORDS_REGEX.containsMatchIn(messageBody) -> "income"
                else -> return null
            }

        var merchantName = mappings[sms.sender]

        if (merchantName == null) {
            for (pattern in MERCHANT_REGEX_PATTERNS) {
                val match = pattern.find(messageBody)
                if (match != null) {
                    val potentialName = match.groups[1]?.value?.replace("_", " ")?.replace(Regex("\\s+"), " ")?.trim()
                    // --- FIX: Allow NEFT references to pass the digit filter ---
                    if (!potentialName.isNullOrBlank() && !potentialName.contains("call", ignoreCase = true)) {
                        // If the name starts with NEFT, it's a valid transaction reference.
                        // Otherwise, apply the digit check to filter out phone numbers.
                        if (potentialName.startsWith("NEFT", ignoreCase = true) || !potentialName.matches(Regex(".*\\d{6,}.*"))) {
                            merchantName = potentialName
                            break
                        }
                    }
                }
            }
        }

        val potentialAccount = parseAccount(messageBody, sms.sender)

        val normalizedSender = sms.sender.filter { it.isDigit() }.takeLast(10)
        val normalizedBody = sms.body.trim().replace(Regex("\\s+"), " ")
        val smsHash = (normalizedSender + normalizedBody).hashCode().toString()

        return PotentialTransaction(
            sourceSmsId = sms.id,
            smsSender = sms.sender,
            amount = amount,
            transactionType = transactionType,
            merchantName = merchantName,
            originalMessage = messageBody,
            potentialAccount = potentialAccount,
            sourceSmsHash = smsHash
        )
    }
}
-e 


================== FILE: ./app/src/main/java/AppDataBackup.kt ==================
package io.pm.finlight

import kotlinx.serialization.Serializable

/**
 * A top-level container for all application data to be exported.
 * This class is designed to be easily converted to a single JSON object.
 */
@Serializable
data class AppDataBackup(
    val transactions: List<Transaction>,
    val accounts: List<Account>,
    val categories: List<Category>,
    val budgets: List<Budget>,
    val merchantMappings: List<MerchantMapping>,
)
-e 


================== FILE: ./app/src/main/java/SettingsRepository.kt ==================
package io.pm.finlight

import android.content.Context
import android.content.SharedPreferences
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import java.util.Calendar

class SettingsRepository(context: Context) {

    private val prefs: SharedPreferences =
        context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE)

    companion object {
        private const val PREF_NAME = "finance_app_settings"
        private const val KEY_USER_NAME = "user_name"
        private const val KEY_PROFILE_PICTURE_URI = "profile_picture_uri"
        private const val KEY_BUDGET_PREFIX = "overall_budget_"
        private const val KEY_APP_LOCK_ENABLED = "app_lock_enabled"
        private const val KEY_WEEKLY_SUMMARY_ENABLED = "weekly_summary_enabled"
        private const val KEY_UNKNOWN_TRANSACTION_POPUP_ENABLED = "unknown_transaction_popup_enabled"
        private const val KEY_DAILY_REPORT_ENABLED = "daily_report_enabled"
        private const val KEY_SMS_SCAN_START_DATE = "sms_scan_start_date"
        private const val KEY_HAS_SEEN_ONBOARDING = "has_seen_onboarding"
        // --- NEW: Key for storing the backup preference ---
        private const val KEY_BACKUP_ENABLED = "google_drive_backup_enabled"
    }

    // --- NEW: Function to save the backup preference ---
    fun saveBackupEnabled(isEnabled: Boolean) {
        prefs.edit().putBoolean(KEY_BACKUP_ENABLED, isEnabled).apply()
    }

    // --- NEW: Flow to read the backup preference ---
    fun getBackupEnabled(): Flow<Boolean> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sharedPreferences, changedKey ->
                if (changedKey == KEY_BACKUP_ENABLED) {
                    trySend(sharedPreferences.getBoolean(KEY_BACKUP_ENABLED, true))
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            // Default to true, as backup is enabled by default in the manifest
            trySend(prefs.getBoolean(KEY_BACKUP_ENABLED, true))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }


    fun saveUserName(name: String) {
        prefs.edit().putString(KEY_USER_NAME, name).apply()
    }

    fun getUserName(): Flow<String> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sharedPreferences, changedKey ->
                if (changedKey == KEY_USER_NAME) {
                    trySend(sharedPreferences.getString(KEY_USER_NAME, "User") ?: "User")
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(prefs.getString(KEY_USER_NAME, "User") ?: "User")
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }

    fun saveProfilePictureUri(uriString: String?) {
        prefs.edit().putString(KEY_PROFILE_PICTURE_URI, uriString).apply()
    }

    fun getProfilePictureUri(): Flow<String?> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sharedPreferences, changedKey ->
                if (changedKey == KEY_PROFILE_PICTURE_URI) {
                    trySend(sharedPreferences.getString(KEY_PROFILE_PICTURE_URI, null))
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(prefs.getString(KEY_PROFILE_PICTURE_URI, null))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }

    fun hasSeenOnboarding(): Boolean {
        return prefs.getBoolean(KEY_HAS_SEEN_ONBOARDING, false)
    }

    fun setHasSeenOnboarding(hasSeen: Boolean) {
        prefs.edit().putBoolean(KEY_HAS_SEEN_ONBOARDING, hasSeen).apply()
    }

    private fun getBudgetKey(year: Int, month: Int): String {
        return String.format("%s%d_%02d", KEY_BUDGET_PREFIX, year, month)
    }

    fun saveOverallBudgetForCurrentMonth(amount: Float) {
        val calendar = Calendar.getInstance()
        val year = calendar.get(Calendar.YEAR)
        val month = calendar.get(Calendar.MONTH) + 1
        val key = getBudgetKey(year, month)
        prefs.edit().putFloat(key, amount).apply()
    }

    fun saveSmsScanStartDate(date: Long) {
        prefs.edit().putLong(KEY_SMS_SCAN_START_DATE, date).apply()
    }

    fun getSmsScanStartDate(): Flow<Long> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sharedPreferences, changedKey ->
                if (changedKey == KEY_SMS_SCAN_START_DATE) {
                    trySend(sharedPreferences.getLong(KEY_SMS_SCAN_START_DATE, 0L))
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            val thirtyDaysAgo = Calendar.getInstance().apply { add(Calendar.DAY_OF_YEAR, -30) }.timeInMillis
            trySend(prefs.getLong(KEY_SMS_SCAN_START_DATE, thirtyDaysAgo))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }

    fun saveAppLockEnabled(isEnabled: Boolean) {
        prefs.edit().putBoolean(KEY_APP_LOCK_ENABLED, isEnabled).apply()
    }
    fun saveDailyReportEnabled(isEnabled: Boolean) {
        prefs.edit().putBoolean(KEY_DAILY_REPORT_ENABLED, isEnabled).apply()
    }
    fun getDailyReportEnabled(): Flow<Boolean> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { _, key ->
                if (key == KEY_DAILY_REPORT_ENABLED) {
                    trySend(prefs.getBoolean(key, false)) // Default to false
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(prefs.getBoolean(KEY_DAILY_REPORT_ENABLED, false))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }

    fun getAppLockEnabled(): Flow<Boolean> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sharedPreferences, changedKey ->
                if (changedKey == KEY_APP_LOCK_ENABLED) {
                    trySend(sharedPreferences.getBoolean(KEY_APP_LOCK_ENABLED, false))
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(prefs.getBoolean(KEY_APP_LOCK_ENABLED, false))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }
    fun isAppLockEnabledBlocking(): Boolean {
        return prefs.getBoolean(KEY_APP_LOCK_ENABLED, false)
    }

    fun getOverallBudgetForMonth(year: Int, month: Int): Flow<Float> {
        val key = getBudgetKey(year, month)
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { sharedPreferences, changedKey ->
                if (changedKey == key) {
                    trySend(sharedPreferences.getFloat(key, 0f))
                }
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(prefs.getFloat(key, 0f))
            awaitClose {
                prefs.unregisterOnSharedPreferenceChangeListener(listener)
            }
        }
    }

    fun saveWeeklySummaryEnabled(isEnabled: Boolean) {
        prefs.edit().putBoolean(KEY_WEEKLY_SUMMARY_ENABLED, isEnabled).apply()
    }
    fun getWeeklySummaryEnabled(): Flow<Boolean> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { _, key ->
                if (key == KEY_WEEKLY_SUMMARY_ENABLED) { trySend(prefs.getBoolean(key, true)) } // Default to true
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(prefs.getBoolean(KEY_WEEKLY_SUMMARY_ENABLED, true))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }

    fun saveUnknownTransactionPopupEnabled(isEnabled: Boolean) {
        prefs.edit().putBoolean(KEY_UNKNOWN_TRANSACTION_POPUP_ENABLED, isEnabled).apply()
    }
    fun getUnknownTransactionPopupEnabled(): Flow<Boolean> {
        return callbackFlow {
            val listener = SharedPreferences.OnSharedPreferenceChangeListener { _, key ->
                if (key == KEY_UNKNOWN_TRANSACTION_POPUP_ENABLED) { trySend(prefs.getBoolean(key, true)) } // Default to true
            }
            prefs.registerOnSharedPreferenceChangeListener(listener)
            trySend(prefs.getBoolean(KEY_UNKNOWN_TRANSACTION_POPUP_ENABLED, true))
            awaitClose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/SearchViewModelFactory.kt ==================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider

class SearchViewModelFactory(private val application: Application) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(SearchViewModel::class.java)) {
            val database = AppDatabase.getInstance(application)
            @Suppress("UNCHECKED_CAST")
            return SearchViewModel(
                transactionDao = database.transactionDao(),
                accountDao = database.accountDao(),
                categoryDao = database.categoryDao(),
            ) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
-e 


================== FILE: ./app/src/main/java/ReportsViewModel.kt ==================
package io.pm.finlight

import android.app.Application
import androidx.compose.ui.graphics.toArgb
import androidx.lifecycle.AndroidViewModel
import com.github.mikephil.charting.data.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Date
import java.util.Locale

class ReportsViewModel(application: Application) : AndroidViewModel(application) {
    private val transactionRepository: TransactionRepository
    val spendingByCategoryPieData: Flow<PieData>
    val monthYear: String
    val monthlyTrendData: Flow<Pair<BarData, List<String>>>

    init {
        val db = AppDatabase.getInstance(application)
        transactionRepository = TransactionRepository(db.transactionDao())

        val calendar = Calendar.getInstance()
        monthYear = SimpleDateFormat("MMMM yyyy", Locale.getDefault()).format(calendar.time)

        val monthStart = Calendar.getInstance().apply { set(Calendar.DAY_OF_MONTH, 1); set(Calendar.HOUR_OF_DAY, 0) }.timeInMillis
        val monthEnd = Calendar.getInstance().apply { add(Calendar.MONTH, 1); set(Calendar.DAY_OF_MONTH, 1); add(Calendar.DAY_OF_MONTH, -1); set(Calendar.HOUR_OF_DAY, 23) }.timeInMillis

        spendingByCategoryPieData =
            transactionRepository.getSpendingByCategoryForMonth(monthStart, monthEnd)
                .map { spendingList ->
                    val entries = spendingList.map { PieEntry(it.totalAmount.toFloat(), it.categoryName) }
                    val colors = spendingList.map {
                        (CategoryIconHelper.getIconBackgroundColor(it.colorKey ?: "gray_light")).toArgb()
                    }
                    val dataSet =
                        PieDataSet(entries, "Spending by Category").apply {
                            this.colors = colors
                            valueTextSize = 12f
                        }
                    PieData(dataSet)
                }

        val sixMonthsAgo = Calendar.getInstance().apply { add(Calendar.MONTH, -6) }.timeInMillis
        monthlyTrendData =
            transactionRepository.getMonthlyTrends(sixMonthsAgo)
                .map { trends ->
                    val incomeEntries = ArrayList<BarEntry>()
                    val expenseEntries = ArrayList<BarEntry>()
                    val labels = ArrayList<String>()

                    trends.forEachIndexed { index, trend ->
                        incomeEntries.add(BarEntry(index.toFloat(), trend.totalIncome.toFloat()))
                        expenseEntries.add(BarEntry(index.toFloat(), trend.totalExpenses.toFloat()))
                        val date = SimpleDateFormat("yyyy-MM", Locale.getDefault()).parse(trend.monthYear)
                        labels.add(SimpleDateFormat("MMM", Locale.getDefault()).format(date ?: Date()))
                    }

                    val incomeDataSet = BarDataSet(incomeEntries, "Income").apply { color = android.graphics.Color.rgb(102, 187, 106) }
                    val expenseDataSet = BarDataSet(expenseEntries, "Expense").apply { color = android.graphics.Color.rgb(239, 83, 80) }

                    val barData = BarData(incomeDataSet, expenseDataSet)
                    Pair(barData, labels)
                }
    }
}
-e 


================== FILE: ./app/src/main/java/TagViewModel.kt ==================
// =================================================================================
// FILE: ./app/src/main/java/io/pm/finlight/TagViewModel.kt
// REASON: Corrected the addTag function. This ViewModel is for the "Manage Tags"
// screen, so it only needs to insert the tag. The UI will be updated
// automatically by the Flow from the database.
// =================================================================================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.receiveAsFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

class TagViewModel(application: Application) : AndroidViewModel(application) {
    private val tagRepository: TagRepository
    private val _uiEvent = Channel<String>()
    val uiEvent = _uiEvent.receiveAsFlow()

    val allTags: StateFlow<List<Tag>>

    init {
        val database = AppDatabase.getInstance(application)
        val tagDao = database.tagDao()
        val transactionDao = database.transactionDao()
        tagRepository = TagRepository(tagDao, transactionDao)

        allTags = tagRepository.allTags.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )
    }

    /**
     * Called from the 'Manage Tags' screen. Inserts a new tag into the database.
     */
    fun addTag(tagName: String) {
        if (tagName.isNotBlank()) {
            viewModelScope.launch {
                tagRepository.insert(Tag(name = tagName))
            }
        }
    }

    fun updateTag(tag: Tag) {
        if (tag.name.isNotBlank()) {
            viewModelScope.launch {
                tagRepository.update(tag)
            }
        }
    }

    fun deleteTag(tag: Tag) {
        viewModelScope.launch {
            if (tagRepository.isTagInUse(tag.id)) {
                _uiEvent.send("Cannot delete '${tag.name}'. It is attached to one or more transactions.")
            } else {
                tagRepository.delete(tag)
                _uiEvent.send("Tag '${tag.name}' deleted.")
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/SettingsViewModel.kt ==================
package io.pm.finlight

import android.Manifest
import android.app.Application
import android.app.backup.BackupManager
import android.content.pm.PackageManager
import android.net.Uri
import android.util.Log
import androidx.core.content.ContextCompat
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.text.SimpleDateFormat
import java.util.*

sealed class ScanResult {
    data class Success(val count: Int) : ScanResult()
    object Error : ScanResult()
}


class SettingsViewModel(application: Application) : AndroidViewModel(application) {
    private val settingsRepository = SettingsRepository(application)
    private val db = AppDatabase.getInstance(application)
    private val transactionRepository = TransactionRepository(db.transactionDao())
    private val merchantMappingRepository = MerchantMappingRepository(db.merchantMappingDao())
    private val context = application
    private val accountRepository = AccountRepository(db.accountDao())
    private val categoryRepository = CategoryRepository(db.categoryDao())
    val smsScanStartDate: StateFlow<Long>

    private val _scanEvent = Channel<ScanResult>()
    val scanEvent = _scanEvent.receiveAsFlow()

    private val _csvValidationReport = MutableStateFlow<CsvValidationReport?>(null)
    val csvValidationReport: StateFlow<CsvValidationReport?> = _csvValidationReport.asStateFlow()

    val overallBudget: StateFlow<Float>

    val dailyReportEnabled: StateFlow<Boolean> =
        settingsRepository.getDailyReportEnabled().stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = false,
        )

    val weeklySummaryEnabled: StateFlow<Boolean> =
        settingsRepository.getWeeklySummaryEnabled().stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = true,
        )

    val appLockEnabled: StateFlow<Boolean> =
        settingsRepository.getAppLockEnabled().stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = false,
        )

    val unknownTransactionPopupEnabled: StateFlow<Boolean> =
        settingsRepository.getUnknownTransactionPopupEnabled().stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = true,
        )

    val backupEnabled: StateFlow<Boolean> =
        settingsRepository.getBackupEnabled().stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = true,
        )

    private val _potentialTransactions = MutableStateFlow<List<PotentialTransaction>>(emptyList())
    val potentialTransactions: StateFlow<List<PotentialTransaction>> = _potentialTransactions.asStateFlow()

    private val _isScanning = MutableStateFlow(false)
    val isScanning: StateFlow<Boolean> = _isScanning.asStateFlow()

    init {
        smsScanStartDate =
            settingsRepository.getSmsScanStartDate()
                .stateIn(
                    scope = viewModelScope,
                    started = SharingStarted.WhileSubscribed(5000),
                    initialValue = 0L,
                )

        val calendar = Calendar.getInstance()
        val currentYear = calendar.get(Calendar.YEAR)
        val currentMonth = calendar.get(Calendar.MONTH) + 1

        // --- FIX: Use the correct repository method with parameters ---
        overallBudget =
            settingsRepository.getOverallBudgetForMonth(currentYear, currentMonth).stateIn(
                scope = viewModelScope,
                started = SharingStarted.WhileSubscribed(5000),
                initialValue = 0f,
            )
    }

    fun setBackupEnabled(enabled: Boolean) {
        settingsRepository.saveBackupEnabled(enabled)
        val backupManager = BackupManager(context)
        backupManager.dataChanged()
    }

    fun rescanSmsForReview(startDate: Long?) {
        if (ContextCompat.checkSelfPermission(context, Manifest.permission.READ_SMS) != PackageManager.PERMISSION_GRANTED) {
            return
        }

        viewModelScope.launch {
            _isScanning.value = true
            try {
                val rawMessages = withContext(Dispatchers.IO) {
                    SmsRepository(context).fetchAllSms(startDate)
                }

                val existingMappings = withContext(Dispatchers.IO) {
                    merchantMappingRepository.allMappings.first().associateBy({ it.smsSender }, { it.merchantName })
                }

                val existingSmsHashes = withContext(Dispatchers.IO) {
                    transactionRepository.getAllSmsHashes().first().toSet()
                }

                val parsedList = withContext(Dispatchers.Default) {
                    rawMessages.mapNotNull { sms ->
                        SmsParser.parse(sms, existingMappings)
                    }
                }

                val newPotentialTransactions = parsedList.filter { potential ->
                    !existingSmsHashes.contains(potential.sourceSmsHash)
                }

                _potentialTransactions.value = newPotentialTransactions
                _scanEvent.send(ScanResult.Success(newPotentialTransactions.size))
            } catch (e: Exception) {
                Log.e("SettingsViewModel", "Error during SMS scan for review", e)
                _scanEvent.send(ScanResult.Error)
            } finally {
                _isScanning.value = false
            }
        }
    }

    fun dismissPotentialTransaction(transaction: PotentialTransaction) {
        _potentialTransactions.value = _potentialTransactions.value.filter { it != transaction }
    }

    fun onTransactionApproved(smsId: Long) {
        _potentialTransactions.update { currentList ->
            currentList.filterNot { it.sourceSmsId == smsId }
        }
    }

    fun saveMerchantMapping(
        sender: String,
        merchantName: String,
    ) {
        viewModelScope.launch {
            merchantMappingRepository.insert(MerchantMapping(smsSender = sender, merchantName = merchantName))
        }
    }

    fun saveSmsScanStartDate(date: Long) {
        viewModelScope.launch {
            settingsRepository.saveSmsScanStartDate(date)
        }
    }

    fun saveOverallBudget(budget: String) {
        val budgetFloat = budget.toFloatOrNull() ?: 0f
        settingsRepository.saveOverallBudgetForCurrentMonth(budgetFloat)
    }

    fun setDailyReportEnabled(enabled: Boolean) {
        settingsRepository.saveDailyReportEnabled(enabled)
        if (enabled) ReminderManager.scheduleDailyReport(context) else ReminderManager.cancelDailyReport(context)
    }

    fun setWeeklySummaryEnabled(enabled: Boolean) {
        settingsRepository.saveWeeklySummaryEnabled(enabled)
        if (enabled) ReminderManager.scheduleWeeklySummary(context) else ReminderManager.cancelWeeklySummary(context)
    }

    fun setAppLockEnabled(enabled: Boolean) {
        settingsRepository.saveAppLockEnabled(enabled)
    }

    fun setUnknownTransactionPopupEnabled(enabled: Boolean) {
        viewModelScope.launch {
            settingsRepository.saveUnknownTransactionPopupEnabled(enabled)
        }
    }

    fun validateCsvFile(uri: Uri) {
        viewModelScope.launch {
            _csvValidationReport.value = null
            withContext(Dispatchers.IO) {
                try {
                    val report = generateValidationReport(uri)
                    _csvValidationReport.value = report
                } catch (e: Exception) {
                    Log.e("SettingsViewModel", "CSV validation failed", e)
                }
            }
        }
    }

    private suspend fun generateValidationReport(
        uri: Uri,
        initialData: List<ReviewableRow>? = null,
    ): CsvValidationReport {
        val accountsMap = db.accountDao().getAllAccounts().first().associateBy { it.name }
        val categoriesMap = db.categoryDao().getAllCategories().first().associateBy { it.name }

        if (initialData != null) {
            val revalidatedRows =
                initialData.map {
                    createReviewableRow(it.lineNumber, it.rowData, accountsMap, categoriesMap)
                }
            return CsvValidationReport(revalidatedRows, revalidatedRows.size)
        }

        val reviewableRows = mutableListOf<ReviewableRow>()
        var lineNumber = 1

        getApplication<Application>().contentResolver.openInputStream(uri)?.bufferedReader()?.useLines { lines ->
            lines.drop(1).forEach { line ->
                lineNumber++
                val tokens = line.split(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)".toRegex()).map { it.trim().removeSurrounding("\"") }
                reviewableRows.add(createReviewableRow(lineNumber, tokens, accountsMap, categoriesMap))
            }
        }
        return CsvValidationReport(reviewableRows, lineNumber - 1)
    }

    private fun createReviewableRow(
        lineNumber: Int,
        tokens: List<String>,
        accounts: Map<String, Account>,
        categories: Map<String, Category>,
    ): ReviewableRow {
        if (tokens.size < 6) return ReviewableRow(lineNumber, tokens, CsvRowStatus.INVALID_COLUMN_COUNT, "Invalid column count.")

        val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
        try {
            dateFormat.parse(tokens[0])
        } catch (
            e: Exception,
        ) {
            return ReviewableRow(lineNumber, tokens, CsvRowStatus.INVALID_DATE, "Invalid date format.")
        }

        val amount = tokens[2].toDoubleOrNull()
        if (amount == null || amount <= 0) return ReviewableRow(lineNumber, tokens, CsvRowStatus.INVALID_AMOUNT, "Invalid amount.")

        val categoryName = tokens[4]
        val accountName = tokens[5]

        val categoryExists = categories.containsKey(categoryName)
        val accountExists = accounts.containsKey(accountName)

        val status =
            when {
                !accountExists && !categoryExists -> CsvRowStatus.NEEDS_BOTH_CREATION
                !accountExists -> CsvRowStatus.NEEDS_ACCOUNT_CREATION
                !categoryExists -> CsvRowStatus.NEEDS_CATEGORY_CREATION
                else -> CsvRowStatus.VALID
            }
        val message =
            when (status) {
                CsvRowStatus.VALID -> "Ready to import."
                CsvRowStatus.NEEDS_BOTH_CREATION -> "New Account & Category will be created."
                CsvRowStatus.NEEDS_ACCOUNT_CREATION -> "New Account '$accountName' will be created."
                CsvRowStatus.NEEDS_CATEGORY_CREATION -> "New Category '$categoryName' will be created."
                else -> "This row has errors and will be skipped."
            }
        return ReviewableRow(lineNumber, tokens, status, message)
    }

    fun removeRowFromReport(rowToRemove: ReviewableRow) {
        _csvValidationReport.value?.let { currentReport ->
            val updatedRows = currentReport.reviewableRows.filter { it.lineNumber != rowToRemove.lineNumber }
            _csvValidationReport.value = currentReport.copy(reviewableRows = updatedRows)
        }
    }

    fun updateAndRevalidateRow(
        lineNumber: Int,
        correctedData: List<String>,
    ) {
        viewModelScope.launch {
            _csvValidationReport.value?.let { currentReport ->
                val currentRows = currentReport.reviewableRows.toMutableList()
                val indexToUpdate = currentRows.indexOfFirst { it.lineNumber == lineNumber }

                if (indexToUpdate != -1) {
                    val revalidatedRow =
                        withContext(Dispatchers.IO) {
                            val accountsMap = db.accountDao().getAllAccounts().first().associateBy { it.name }
                            val categoriesMap = db.categoryDao().getAllCategories().first().associateBy { it.name }
                            createReviewableRow(lineNumber, correctedData, accountsMap, categoriesMap)
                        }
                    currentRows[indexToUpdate] = revalidatedRow
                    _csvValidationReport.value = currentReport.copy(reviewableRows = currentRows)
                }
            }
        }
    }

    fun commitCsvImport(rowsToImport: List<ReviewableRow>) {
        viewModelScope.launch(Dispatchers.IO) {
            Log.d("CsvImportDebug", "ViewModel: commitCsvImport called with ${rowsToImport.size} rows.")

            val allAccounts = accountRepository.allAccounts.first()
            val allCategories = categoryRepository.allCategories.first()
            val accountMap = allAccounts.associateBy { it.name.lowercase() }.toMutableMap()
            val categoryMap = allCategories.associateBy { it.name.lowercase() }.toMutableMap()

            val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())

            for (row in rowsToImport) {
                try {
                    val columns = row.rowData
                    val date = dateFormat.parse(columns[0]) ?: Date()
                    val description = columns[1]
                    val amount = columns[2].toDouble()
                    val type = columns[3].lowercase(Locale.getDefault())
                    val categoryName = columns[4]
                    val accountName = columns[5]
                    val notes = columns.getOrNull(6)

                    var category = categoryMap[categoryName.lowercase()]
                    if (category == null) {
                        val newCategory = Category(name = categoryName)
                        categoryRepository.insert(newCategory)
                        val updatedCategories = categoryRepository.allCategories.first()
                        category = updatedCategories.find { it.name.equals(categoryName, ignoreCase = true) }
                        if (category != null) {
                            categoryMap[categoryName.lowercase()] = category
                            Log.d("CsvImportDebug", "ViewModel: Created and found new category '$categoryName' with ID ${category.id}")
                        } else {
                            Log.e("CsvImportDebug", "ViewModel: FAILED to create and re-find new category '$categoryName'")
                            continue
                        }
                    }

                    var account = accountMap[accountName.lowercase()]
                    if (account == null) {
                        val newAccount = Account(name = accountName, type = "Imported")
                        accountRepository.insert(newAccount)
                        val updatedAccounts = accountRepository.allAccounts.first()
                        account = updatedAccounts.find { it.name.equals(accountName, ignoreCase = true) }
                        if (account != null) {
                            accountMap[accountName.lowercase()] = account
                            Log.d("CsvImportDebug", "ViewModel: Created and found new account '$accountName' with ID ${account.id}")
                        } else {
                            Log.e("CsvImportDebug", "ViewModel: FAILED to create and re-find new account '$accountName'")
                            continue
                        }
                    }

                    if (account == null || category == null) {
                        Log.e("CsvImportDebug", "ViewModel: Could not find or create account/category for row ${row.lineNumber}. Skipping.")
                        continue
                    }

                    val transaction =
                        Transaction(
                            date = date.time,
                            amount = amount,
                            description = description,
                            notes = notes,
                            transactionType = type,
                            accountId = account.id,
                            categoryId = category.id,
                        )
                    transactionRepository.insert(transaction)
                    Log.d("CsvImportDebug", "ViewModel: Inserted transaction for row ${row.lineNumber}: '${transaction.description}'")
                } catch (e: Exception) {
                    Log.e("CsvImportDebug", "ViewModel: Failed to parse or insert row ${row.lineNumber}. Data: ${row.rowData}", e)
                }
            }
            Log.d("CsvImportDebug", "ViewModel: Finished commitCsvImport.")
        }
    }

    fun clearCsvValidationReport() {
        _csvValidationReport.value = null
    }
}
-e 


================== FILE: ./app/src/main/java/AccountViewModel.kt ==================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch

class AccountViewModel(application: Application) : AndroidViewModel(application) {
    private val repository: AccountRepository
    private val transactionRepository: TransactionRepository

    // This is the data your UI will observe. It now comes directly from the repository.
    val accountsWithBalance: Flow<List<AccountWithBalance>>

    init {
        val db = AppDatabase.getInstance(application)
        repository = AccountRepository(db.accountDao())
        transactionRepository = TransactionRepository(db.transactionDao())

        // --- CORRECTED: Directly use the powerful query from the DAO via the repository ---
        // This is much more efficient than using 'combine' and calculating in the ViewModel.
        accountsWithBalance = repository.accountsWithBalance
    }

    fun getAccountById(accountId: Int): Flow<Account?> = repository.getAccountById(accountId)

    // --- CORRECTED: The balance calculation now correctly uses the transactionType ---
    // Helper function to calculate a single account's balance for the detail view
    fun getAccountBalance(accountId: Int): Flow<Double> {
        // This leverages the existing getTransactionsForAccount and then sums the amounts correctly.
        return transactionRepository.getTransactionsForAccount(accountId).map { transactions ->
            transactions.sumOf { if (it.transactionType == "income") it.amount else -it.amount }
        }
    }

    // Pass through for the detail screen to get full transaction details
    fun getTransactionsForAccount(accountId: Int): Flow<List<TransactionDetails>> {
        // NOTE: You'll need to add getTransactionsForAccountDetails to your TransactionRepository
        // that calls the corresponding DAO method.
        return transactionRepository.getTransactionsForAccountDetails(accountId)
    }

    // --- CORRECTED: The Account object no longer has a 'balance' parameter in its constructor ---
    fun addAccount(
        name: String,
        type: String,
    ) = viewModelScope.launch {
        if (name.isNotBlank() && type.isNotBlank()) {
            // Create the Account object without a balance.
            repository.insert(Account(name = name, type = type))
        }
    }

    fun updateAccount(account: Account) =
        viewModelScope.launch {
            repository.update(account)
        }

    fun deleteAccount(account: Account) =
        viewModelScope.launch {
            repository.delete(account)
        }
}
-e 


================== FILE: ./app/src/main/java/TransactionTagCrossRef.kt ==================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.ForeignKey

/**
 * This is a "join table" to create a many-to-many relationship
 * between the 'transactions' table and the 'tags' table.
 */
@Entity(
    tableName = "transaction_tag_cross_ref",
    primaryKeys = ["transactionId", "tagId"],
    foreignKeys = [
        ForeignKey(
            entity = Transaction::class,
            parentColumns = ["id"],
            childColumns = ["transactionId"],
            onDelete = ForeignKey.CASCADE // If a transaction is deleted, remove its tag links
        ),
        ForeignKey(
            entity = Tag::class,
            parentColumns = ["id"],
            childColumns = ["tagId"],
            onDelete = ForeignKey.CASCADE // If a tag is deleted, remove its links from transactions
        )
    ]
)
data class TransactionTagCrossRef(
    val transactionId: Int,
    val tagId: Int
)-e 


================== FILE: ./app/src/main/java/PotentialTransaction.kt ==================
package io.pm.finlight

/**
 * A data class to hold the structured information extracted from an SMS message.
 * This is a temporary object, created before a full 'Transaction' is saved to the database.
 *
 * @param amount The monetary value of the transaction.
 * @param transactionType The type of transaction, either 'expense' or 'income'.
 * @param merchantName The name of the merchant, if it can be determined.
 * @param originalMessage The original SMS body, for reference and debugging.
 * @param potentialAccount Holds the parsed account name and type, if found.
 */
data class PotentialTransaction(
    val sourceSmsId: Long,
    val smsSender: String,
    val amount: Double,
    val transactionType: String,
    val merchantName: String?,
    val originalMessage: String,
    // --- NEW: Add a field for the automatically parsed account details ---
    val potentialAccount: PotentialAccount? = null,
    // --- BUG FIX: Add a stable hash to uniquely identify an SMS for de-duplication ---
    val sourceSmsHash: String? = null,
)
-e 


================== FILE: ./app/src/main/java/TransactionImage.kt ==================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "transaction_images",
    foreignKeys = [
        ForeignKey(
            entity = Transaction::class,
            parentColumns = ["id"],
            childColumns = ["transactionId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    // --- FIX: Explicitly declare the index that Room creates for the foreign key ---
    indices = [Index(value = ["transactionId"])]
)
data class TransactionImage(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val transactionId: Int,
    val imageUri: String // Stores the URI of the image in the app's internal storage
)
-e 


================== FILE: ./app/src/main/java/TransactionDao.kt ==================
package io.pm.finlight

import androidx.room.*
import kotlinx.coroutines.flow.Flow

@Dao
interface TransactionDao {

    // --- NEW: Query to get aggregated spending by merchant for a specific date range ---
    @Query("""
        SELECT
            description as merchantName,
            SUM(amount) as totalAmount,
            COUNT(id) as transactionCount
        FROM transactions
        WHERE transactionType = 'expense' AND date BETWEEN :startDate AND :endDate
        GROUP BY description
        ORDER BY totalAmount DESC
    """)
    fun getSpendingByMerchantForMonth(startDate: Long, endDate: Long): Flow<List<MerchantSpendingSummary>>


    // --- Methods for image attachments ---
    @Insert
    suspend fun insertImage(transactionImage: TransactionImage)

    @Delete
    suspend fun deleteImage(transactionImage: TransactionImage)

    @Query("SELECT * FROM transaction_images WHERE transactionId = :transactionId")
    fun getImagesForTransaction(transactionId: Int): Flow<List<TransactionImage>>


    @Query("UPDATE transactions SET description = :description WHERE id = :id")
    suspend fun updateDescription(id: Int, description: String)

    @Query("UPDATE transactions SET amount = :amount WHERE id = :id")
    suspend fun updateAmount(id: Int, amount: Double)

    @Query("UPDATE transactions SET notes = :notes WHERE id = :id")
    suspend fun updateNotes(id: Int, notes: String?)

    @Query("UPDATE transactions SET categoryId = :categoryId WHERE id = :id")
    suspend fun updateCategoryId(id: Int, categoryId: Int?)

    @Query("UPDATE transactions SET accountId = :accountId WHERE id = :id")
    suspend fun updateAccountId(id: Int, accountId: Int)

    @Query("UPDATE transactions SET date = :date WHERE id = :id")
    suspend fun updateDate(id: Int, date: Long)


    @Query("""
        SELECT
            T.*,
            A.name as accountName,
            C.name as categoryName,
            C.iconKey as categoryIconKey,
            C.colorKey as categoryColorKey
        FROM
            transactions AS T
        LEFT JOIN
            accounts AS A ON T.accountId = A.id
        LEFT JOIN
            categories AS C ON T.categoryId = C.id
        WHERE T.id = :id
    """)
    fun getTransactionDetailsById(id: Int): Flow<TransactionDetails?>


    @Query(
        """
        SELECT
            T.*,
            A.name as accountName,
            C.name as categoryName,
            C.iconKey as categoryIconKey,
            C.colorKey as categoryColorKey
        FROM
            transactions AS T
        LEFT JOIN
            accounts AS A ON T.accountId = A.id
        LEFT JOIN
            categories AS C ON T.categoryId = C.id
        ORDER BY
            T.date DESC
        LIMIT 5
    """
    )
    fun getRecentTransactionDetails(): Flow<List<TransactionDetails>>

    @Query(
        """
        SELECT
            T.*,
            A.name as accountName,
            C.name as categoryName,
            C.iconKey as categoryIconKey,
            C.colorKey as categoryColorKey
        FROM
            transactions AS T
        LEFT JOIN
            accounts AS A ON T.accountId = A.id
        LEFT JOIN
            categories AS C ON T.categoryId = C.id
        ORDER BY
            T.date DESC
    """
    )
    fun getAllTransactions(): Flow<List<TransactionDetails>>

    @Query("SELECT sourceSmsHash FROM transactions WHERE sourceSmsHash IS NOT NULL")
    fun getAllSmsHashes(): Flow<List<String>>

    @Query(
        """
        SELECT
            T.*,
            A.name as accountName,
            C.name as categoryName,
            C.iconKey as categoryIconKey,
            C.colorKey as categoryColorKey
        FROM
            transactions AS T
        LEFT JOIN
            accounts AS A ON T.accountId = A.id
        LEFT JOIN
            categories AS C ON T.categoryId = C.id
        WHERE T.date BETWEEN :startDate AND :endDate
        ORDER BY
            T.date DESC
    """
    )
    fun getTransactionDetailsForRange(
        startDate: Long,
        endDate: Long,
    ): Flow<List<TransactionDetails>>

    @Query(
        """
        SELECT T.*,
               A.name as accountName,
               C.name as categoryName,
               C.iconKey as categoryIconKey,
               C.colorKey as categoryColorKey
        FROM transactions AS T
        LEFT JOIN accounts AS A ON T.accountId = A.id
        LEFT JOIN categories AS C ON T.categoryId = C.id
        WHERE T.accountId = :accountId
        ORDER BY T.date DESC
    """
    )
    fun getTransactionsForAccountDetails(accountId: Int): Flow<List<TransactionDetails>>

    @Query("SELECT * FROM transactions")
    fun getAllTransactionsSimple(): Flow<List<Transaction>>

    @Query("SELECT * FROM transactions WHERE date BETWEEN :startDate AND :endDate ORDER BY date DESC")
    fun getAllTransactionsForRange(
        startDate: Long,
        endDate: Long,
    ): Flow<List<Transaction>>

    @Query("SELECT * FROM transactions WHERE id = :id")
    fun getTransactionById(id: Int): Flow<Transaction?>

    @Query("SELECT * FROM transactions WHERE accountId = :accountId ORDER BY date DESC")
    fun getTransactionsForAccount(accountId: Int): Flow<List<Transaction>>

    @Query(
        """
        SELECT SUM(T.amount) FROM transactions AS T
        INNER JOIN categories AS C ON T.categoryId = C.id
        WHERE C.name = :categoryName AND T.date BETWEEN :startDate AND :endDate AND T.transactionType = 'expense'
    """
    )
    fun getSpendingForCategory(
        categoryName: String,
        startDate: Long,
        endDate: Long,
    ): Flow<Double?>

    @Query(
        """
        SELECT 
            C.name as categoryName, 
            SUM(T.amount) as totalAmount,
            C.iconKey as iconKey,
            C.colorKey as colorKey
        FROM transactions AS T
        INNER JOIN categories AS C ON T.categoryId = C.id
        WHERE T.transactionType = 'expense' AND T.date BETWEEN :startDate AND :endDate
        GROUP BY C.name
        ORDER BY totalAmount ASC
    """
    )
    fun getSpendingByCategoryForMonth(
        startDate: Long,
        endDate: Long,
    ): Flow<List<CategorySpending>>

    @Query(
        """
        SELECT
            strftime('%Y-%m', date / 1000, 'unixepoch') as monthYear,
            SUM(CASE WHEN transactionType = 'income' THEN amount ELSE 0 END) as totalIncome,
            SUM(CASE WHEN transactionType = 'expense' THEN amount ELSE 0 END) as totalExpenses
        FROM transactions
        WHERE date >= :startDate
        GROUP BY monthYear
        ORDER BY monthYear ASC
    """
    )
    fun getMonthlyTrends(startDate: Long): Flow<List<MonthlyTrend>>

    @Query(
        """
        SELECT t.*, a.name as accountName, c.name as categoryName, c.iconKey as categoryIconKey, c.colorKey as categoryColorKey
        FROM transactions t
        LEFT JOIN accounts a ON t.accountId = a.id
        LEFT JOIN categories c ON t.categoryId = c.id
        WHERE
            (:keyword = '' OR t.description LIKE '%' || :keyword || '%' OR t.notes LIKE '%' || :keyword || '%') AND
            (:accountId IS NULL OR t.accountId = :accountId) AND
            (:categoryId IS NULL OR t.categoryId = :categoryId) AND
            (:transactionType IS NULL OR t.transactionType = :transactionType) AND
            (:startDate IS NULL OR t.date >= :startDate) AND
            (:endDate IS NULL OR t.date <= :endDate)
        ORDER BY t.date DESC
    """
    )
    suspend fun searchTransactions(
        keyword: String,
        accountId: Int?,
        categoryId: Int?,
        transactionType: String?,
        startDate: Long?,
        endDate: Long?,
    ): List<TransactionDetails>

    @Query("SELECT COUNT(*) FROM transactions WHERE categoryId = :categoryId")
    suspend fun countTransactionsForCategory(categoryId: Int): Int

    @Query("SELECT COUNT(*) FROM transaction_tag_cross_ref WHERE tagId = :tagId")
    suspend fun countTransactionsForTag(tagId: Int): Int


    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(transactions: List<Transaction>)

    @Query("DELETE FROM transactions")
    suspend fun deleteAll()

    @Insert
    suspend fun insert(transaction: Transaction): Long

    @Update
    suspend fun update(transaction: Transaction)

    @Delete
    suspend fun delete(transaction: Transaction)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun addTagsToTransaction(crossRefs: List<TransactionTagCrossRef>)

    @Query("DELETE FROM transaction_tag_cross_ref WHERE transactionId = :transactionId")
    suspend fun clearTagsForTransaction(transactionId: Int)

    @Query("SELECT T.* FROM tags T INNER JOIN transaction_tag_cross_ref TTCR ON T.id = TTCR.tagId WHERE TTCR.transactionId = :transactionId")
    fun getTagsForTransaction(transactionId: Int): Flow<List<Tag>>

}
-e 


================== FILE: ./app/src/main/java/RecurringTransactionViewModel.kt ==================
package io.pm.finlight

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.launch

class RecurringTransactionViewModel(application: Application) : AndroidViewModel(application) {
    private val repository: RecurringTransactionRepository
    val allRecurringTransactions: Flow<List<RecurringTransaction>>

    init {
        val recurringDao = AppDatabase.getInstance(application).recurringTransactionDao()
        repository = RecurringTransactionRepository(recurringDao)
        allRecurringTransactions = repository.getAll()
    }

    fun addRecurringTransaction(
        description: String,
        amount: Double,
        transactionType: String,
        recurrenceInterval: String,
        startDate: Long,
        accountId: Int,
        categoryId: Int?,
    ) = viewModelScope.launch {
        val newRule =
            RecurringTransaction(
                description = description,
                amount = amount,
                transactionType = transactionType,
                recurrenceInterval = recurrenceInterval,
                startDate = startDate,
                accountId = accountId,
                categoryId = categoryId,
            )
        repository.insert(newRule)
    }
}
-e 


================== FILE: ./app/src/main/java/CategoryIconHelper.kt ==================
package io.pm.finlight

import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ReceiptLong
import androidx.compose.material.icons.automirrored.filled.TrendingUp
import androidx.compose.material.icons.filled.AccountBalance
import androidx.compose.material.icons.filled.Business
import androidx.compose.material.icons.filled.CardGiftcard
import androidx.compose.material.icons.filled.Category
import androidx.compose.material.icons.filled.DirectionsCar
import androidx.compose.material.icons.filled.Fastfood
import androidx.compose.material.icons.filled.Favorite
import androidx.compose.material.icons.filled.LocalGasStation
import androidx.compose.material.icons.filled.MoreHoriz
import androidx.compose.material.icons.filled.Pets
import androidx.compose.material.icons.filled.Restaurant
import androidx.compose.material.icons.filled.School
import androidx.compose.material.icons.filled.ShoppingBag
import androidx.compose.material.icons.filled.ShoppingCart
import androidx.compose.material.icons.filled.Star
import androidx.compose.material.icons.filled.SwapHoriz
import androidx.compose.material.icons.filled.TravelExplore
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector

/**
 * A helper object to manage category icons and colors, and provide a predefined list of categories.
 */
object CategoryIconHelper {

    private val iconColors = mapOf(
        "green_light" to Color(0xFFA5D6A7),
        "blue_light" to Color(0xFF90CAF9),
        "purple_light" to Color(0xFFCE93D8),
        "orange_light" to Color(0xFFFFCC80),
        "red_light" to Color(0xFFEF9A9A),
        "teal_light" to Color(0xFF80CBC4),
        "pink_light" to Color(0xFFF48FB1),
        "brown_light" to Color(0xFFBCAAA4),
        "cyan_light" to Color(0xFF80DEEA),
        "indigo_light" to Color(0xFF9FA8DA),
        "deep_purple_light" to Color(0xFFB39DDB),
        "yellow_light" to Color(0xFFFFF59D),
        "gray_light" to Color(0xFFE0E0E0),
    )

    fun getIconBackgroundColor(colorKey: String): Color {
        return iconColors[colorKey] ?: Color.LightGray
    }

    fun getAllIconColors(): Map<String, Color> {
        return iconColors
    }

    /**
     * NEW: Finds the first available color key that is not in the provided list of used keys.
     * This ensures new categories get a unique color by default.
     */
    fun getNextAvailableColor(usedColorKeys: List<String>): String {
        // Find the first color key from our predefined list that isn't already used.
        return iconColors.keys.firstOrNull { it !in usedColorKeys }
        // If all colors are used, cycle back and return the first one.
            ?: iconColors.keys.firstOrNull()
            // As a final fallback, return a default key.
            ?: "gray_light"
    }

    // --- UPDATED: Each category now has a fixed, explicit ID ---
    val predefinedCategories = listOf(
        Category(id = 1, name = "Bills", iconKey = "receipt_long", colorKey = "green_light"),
        Category(id = 2, name = "EMI", iconKey = "trending_up", colorKey = "blue_light"),
        Category(id = 3, name = "Entertainment", iconKey = "star", colorKey = "purple_light"),
        Category(id = 4, name = "Food & Drinks", iconKey = "restaurant", colorKey = "orange_light"),
        Category(id = 5, name = "Fuel", iconKey = "local_gas_station", colorKey = "red_light"),
        Category(id = 6, name = "Groceries", iconKey = "shopping_cart", colorKey = "teal_light"),
        Category(id = 7, name = "Health", iconKey = "favorite", colorKey = "pink_light"),
        Category(id = 8, name = "Investment", iconKey = "business", colorKey = "brown_light"),
        Category(id = 9, name = "Shopping", iconKey = "shopping_bag", colorKey = "cyan_light"),
        Category(id = 10, name = "Transfer", iconKey = "swap_horiz", colorKey = "indigo_light"),
        Category(id = 11, name = "Travel", iconKey = "travel_explore", colorKey = "deep_purple_light"),
        Category(id = 12, name = "Salary", iconKey = "account_balance", colorKey = "yellow_light"),
        Category(id = 13, name = "Other", iconKey = "more_horiz", colorKey = "gray_light"),
    )

    fun getIcon(iconKey: String): ImageVector {
        return when (iconKey) {
            "receipt_long" -> Icons.AutoMirrored.Filled.ReceiptLong
            "trending_up" -> Icons.AutoMirrored.Filled.TrendingUp
            "star" -> Icons.Default.Star
            "restaurant" -> Icons.Default.Restaurant
            "local_gas_station" -> Icons.Default.LocalGasStation
            "shopping_cart" -> Icons.Default.ShoppingCart
            "favorite" -> Icons.Default.Favorite
            "business" -> Icons.Default.Business
            "shopping_bag" -> Icons.Default.ShoppingBag
            "swap_horiz" -> Icons.Default.SwapHoriz
            "travel_explore" -> Icons.Default.TravelExplore
            "account_balance" -> Icons.Default.AccountBalance
            "more_horiz" -> Icons.Default.MoreHoriz
            "card_giftcard" -> Icons.Default.CardGiftcard
            "school" -> Icons.Default.School
            "pets" -> Icons.Default.Pets
            "fastfood" -> Icons.Default.Fastfood
            "directions_car" -> Icons.Default.DirectionsCar
            else -> Icons.Default.Category
        }
    }

    fun getAllIcons(): Map<String, ImageVector> {
        return mapOf(
            "receipt_long" to Icons.AutoMirrored.Filled.ReceiptLong,
            "trending_up" to Icons.AutoMirrored.Filled.TrendingUp,
            "star" to Icons.Default.Star,
            "restaurant" to Icons.Default.Restaurant,
            "local_gas_station" to Icons.Default.LocalGasStation,
            "shopping_cart" to Icons.Default.ShoppingCart,
            "favorite" to Icons.Default.Favorite,
            "business" to Icons.Default.Business,
            "shopping_bag" to Icons.Default.ShoppingBag,
            "swap_horiz" to Icons.Default.SwapHoriz,
            "travel_explore" to Icons.Default.TravelExplore,
            "account_balance" to Icons.Default.AccountBalance,
            "more_horiz" to Icons.Default.MoreHoriz,
            "card_giftcard" to Icons.Default.CardGiftcard,
            "school" to Icons.Default.School,
            "pets" to Icons.Default.Pets,
            "fastfood" to Icons.Default.Fastfood,
            "directions_car" to Icons.Default.DirectionsCar,
            "category" to Icons.Default.Category
        )
    }
}
-e 


================== FILE: ./app/src/main/java/CategoryDao.kt ==================
package io.pm.finlight

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import kotlinx.coroutines.flow.Flow

@Dao
interface CategoryDao {

    @Query("SELECT * FROM categories ORDER BY name ASC")
    fun getAllCategories(): Flow<List<Category>>

    @Query("SELECT * FROM categories WHERE id = :categoryId")
    suspend fun getCategoryById(categoryId: Int): Category?

    // --- BUG FIX: Query the correct table ('categories') ---
    @Query("SELECT * FROM categories WHERE name = :name LIMIT 1")
    suspend fun findByName(name: String): Category?

    // --- NEW: For data seeding ---
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(categories: List<Category>)

    // --- NEW: For data seeding ---
    @Query("DELETE FROM categories")
    suspend fun deleteAll()

    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insert(category: Category)

    @Update
    suspend fun update(category: Category)

    @Delete
    suspend fun delete(category: Category)
}
-e 


================== FILE: ./app/src/main/java/BudgetDao.kt ==================
package io.pm.finlight

import androidx.room.*
import kotlinx.coroutines.flow.Flow

@Dao
interface BudgetDao {
    @Query("SELECT * FROM budgets WHERE month = :month AND year = :year")
    fun getBudgetsForMonth(
        month: Int,
        year: Int,
    ): Flow<List<Budget>>

    // --- PERFORMANCE OPTIMIZATION ---
    // This new query calculates the actual spending for each category budget directly in the database.
    // It is much more efficient than fetching all transactions and all budgets into memory and combining them in the ViewModel.
    // It joins Budgets with an aggregate sum from Transactions for a given month and year.
    // --- FIX: The @Transaction annotation was removed as it's illegal on a @Query that returns a Flow. ---
    @Query(
        """
        SELECT
            B.*,
            IFNULL(TxSums.totalSpent, 0.0) as spent,
            Cat.iconKey as iconKey,
            Cat.colorKey as colorKey
        FROM
            budgets AS B
        LEFT JOIN
            (SELECT
                C.name as categoryName,
                SUM(T.amount) as totalSpent
             FROM transactions AS T
             JOIN categories AS C ON T.categoryId = C.id
             WHERE T.transactionType = 'expense' AND strftime('%Y-%m', T.date / 1000, 'unixepoch') = :yearMonth
             GROUP BY C.name) AS TxSums
        ON B.categoryName = TxSums.categoryName
        LEFT JOIN categories AS Cat ON B.categoryName = Cat.name
        WHERE B.month = :month AND B.year = :year
    """
    )
    fun getBudgetsWithSpendingForMonth(yearMonth: String, month: Int, year: Int): Flow<List<BudgetWithSpending>>


    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(budgets: List<Budget>)

    @Query("DELETE FROM budgets")
    suspend fun deleteAll()

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(budget: Budget)

    // This query is more efficient as it performs the calculation in the database.
    @Query(
        "SELECT SUM(amount) FROM transactions WHERE categoryId = (SELECT id FROM categories WHERE name = :categoryName) AND strftime('%m', date / 1000, 'unixepoch') + 0 = :month AND strftime('%Y', date / 1000, 'unixepoch') + 0 = :year AND transactionType = 'expense'",
    )
    fun getActualSpendingForCategory(
        categoryName: String,
        month: Int,
        year: Int,
    ): Flow<Double?>

    @Query("SELECT * FROM budgets")
    fun getAllBudgets(): Flow<List<Budget>>

    @Query("SELECT * FROM budgets WHERE id = :id")
    fun getById(id: Int): Flow<Budget?>

    @Update
    suspend fun update(budget: Budget)

    @Delete
    suspend fun delete(budget: Budget)
}
-e 


================== FILE: ./app/src/main/java/DailyReportWorker.kt ==================
package io.pm.finlight

import android.content.Context
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.withContext
import java.util.Calendar

/**
 * A background worker that calculates the user's total expenses from the previous day
 * and displays it as a system notification.
 */
class DailyReportWorker(
    private val context: Context,
    workerParams: WorkerParameters,
) : CoroutineWorker(context, workerParams) {
    override suspend fun doWork(): Result {
        return withContext(Dispatchers.IO) {
            try {
                Log.d("DailyReportWorker", "Worker starting...")
                val db = AppDatabase.getInstance(context)
                val transactionDao = db.transactionDao()

                // 1. Calculate the start and end timestamps for "yesterday".
                val calendar = Calendar.getInstance()
                calendar.add(Calendar.DAY_OF_YEAR, -1) // Go back to yesterday
                calendar.set(Calendar.HOUR_OF_DAY, 23)
                calendar.set(Calendar.MINUTE, 59)
                calendar.set(Calendar.SECOND, 59)
                val endDate = calendar.timeInMillis

                calendar.set(Calendar.HOUR_OF_DAY, 0)
                calendar.set(Calendar.MINUTE, 0)
                calendar.set(Calendar.SECOND, 0)
                val startDate = calendar.timeInMillis

                // 2. Fetch transactions for yesterday.
                val transactions = transactionDao.getTransactionDetailsForRange(startDate, endDate).first()
                Log.d("DailyReportWorker", "Found ${transactions.size} transactions for yesterday.")

                // 3. Calculate total expenses.
                val totalExpenses =
                    transactions
                        .filter { it.transaction.transactionType == "expense" }
                        .sumOf { it.transaction.amount }

                // 4. Send the summary notification via the helper.
                NotificationHelper.showDailyReportNotification(context, totalExpenses)

                Log.d("DailyReportWorker", "Worker finished successfully.")
                Result.success()
            } catch (e: Exception) {
                Log.e("DailyReportWorker", "Worker failed", e)
                Result.retry() // Retry the job if it fails
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/AccountDao.kt ==================
package io.pm.finlight

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Transaction
import androidx.room.Update
import kotlinx.coroutines.flow.Flow

@Dao
interface AccountDao {
    // --- PERFORMANCE OPTIMIZATION ---
    // The original query ran a sub-query for every account, which is very inefficient (N+1 problem).
    // This new query is significantly more performant. It calculates the balances for all accounts
    // in a single pass using GROUP BY, and then LEFT JOINs the results back to the accounts table.
    // This ensures that even with thousands of transactions and many accounts, the query remains fast.
    @Transaction
    @Query(
        """
        SELECT
            A.*,
            IFNULL(TxSums.balance, 0.0) as balance
        FROM
            accounts AS A
        LEFT JOIN
            (SELECT
                accountId,
                SUM(CASE WHEN transactionType = 'income' THEN amount ELSE -amount END) as balance
             FROM transactions
             GROUP BY accountId) AS TxSums
        ON A.id = TxSums.accountId
        ORDER BY
            A.name ASC
    """
    )
    fun getAccountsWithBalance(): Flow<List<AccountWithBalance>>

    @Query("SELECT * FROM accounts ORDER BY name ASC")
    fun getAllAccounts(): Flow<List<Account>>

    @Query("SELECT * FROM accounts WHERE name = :name LIMIT 1")
    suspend fun findByName(name: String): Account?

    @Query("SELECT * FROM accounts WHERE id = :accountId")
    fun getAccountById(accountId: Int): Flow<Account?>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(accounts: List<Account>)

    @Query("DELETE FROM accounts")
    suspend fun deleteAll()

    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insert(account: Account)

    @Update
    suspend fun update(account: Account)

    @Delete
    suspend fun delete(account: Account)
}
-e 


================== FILE: ./app/src/main/java/TagDao.kt ==================
package io.pm.finlight

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import kotlinx.coroutines.flow.Flow

@Dao
interface TagDao {
    // --- FIX: Modified to return the new row's ID ---
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insert(tag: Tag): Long

    @Query("SELECT * FROM tags ORDER BY name ASC")
    fun getAllTags(): Flow<List<Tag>>

    @Update
    suspend fun update(tag: Tag)

    @Delete
    suspend fun delete(tag: Tag)
}
-e 


================== FILE: ./app/src/main/java/LoginResponse.kt ==================
package io.pm.finlight

data class LoginResponse(
    val message: String,
    // We can add a 'token' field later, e.g., val token: String
)
-e 


================== FILE: ./app/src/main/java/MerchantSpendingSummary.kt ==================
package io.pm.finlight

/**
 * A data class to hold aggregated spending data for a specific merchant.
 *
 * @param merchantName The name of the merchant (from the transaction description).
 * @param totalAmount The sum of all expenses for this merchant in a given period.
 * @param transactionCount The number of transactions (visits) for this merchant.
 */
data class MerchantSpendingSummary(
    val merchantName: String,
    val totalAmount: Double,
    val transactionCount: Int
)
-e 


================== FILE: ./app/src/main/java/BudgetWithSpending.kt ==================
package io.pm.finlight

import androidx.room.Embedded

data class BudgetWithSpending(
    @Embedded
    val budget: Budget,
    val spent: Double,
    // --- NEW: Add fields for category icon and color ---
    val iconKey: String?,
    val colorKey: String?
)
-e 


================== FILE: ./app/src/main/java/MainApplication.kt ==================
package io.pm.finlight

import android.app.Application
import android.app.NotificationChannel
import android.app.NotificationManager
import android.os.Build
import com.github.mikephil.charting.utils.Utils

class MainApplication : Application() {
    companion object {
        const val TRANSACTION_CHANNEL_ID = "transaction_channel"
        const val DAILY_REPORT_CHANNEL_ID = "daily_report_channel"
        const val SUMMARY_CHANNEL_ID = "summary_channel"
    }

    override fun onCreate() {
        super.onCreate()
        // --- FIX: Initialize the MPAndroidChart library ---
        Utils.init(this)

        createTransactionNotificationChannel()
        createDailyReportNotificationChannel()
        createSummaryNotificationChannel()
    }

    private fun createTransactionNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val name = "Transactions"
            val descriptionText = "Notifications for newly detected transactions"
            val importance = NotificationManager.IMPORTANCE_DEFAULT
            val channel =
                NotificationChannel(TRANSACTION_CHANNEL_ID, name, importance).apply {
                    description = descriptionText
                }
            val notificationManager: NotificationManager =
                getSystemService(NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
    }

    private fun createDailyReportNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val name = "Daily Reports"
            val descriptionText = "Daily summary of your spending."
            val importance = NotificationManager.IMPORTANCE_DEFAULT
            val channel =
                NotificationChannel(DAILY_REPORT_CHANNEL_ID, name, importance).apply {
                    description = descriptionText
                }
            val notificationManager: NotificationManager =
                getSystemService(NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
    }

    private fun createSummaryNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val name = "Weekly Summaries"
            val descriptionText = "A weekly summary of your financial activity."
            val importance = NotificationManager.IMPORTANCE_DEFAULT
            val channel =
                NotificationChannel(SUMMARY_CHANNEL_ID, name, importance).apply {
                    description = descriptionText
                }
            val notificationManager: NotificationManager =
                getSystemService(NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
    }
}
-e 


================== FILE: ./app/src/main/java/Budget.kt ==================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

@Serializable
@Entity(tableName = "budgets")
data class Budget(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val categoryName: String,
    val amount: Double,
    val month: Int, // e.g., 6 for June
    val year: Int, // e.g., 2024
)
-e 


================== FILE: ./app/src/main/java/Transaction.kt ==================
package io.pm.finlight

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey
import kotlinx.serialization.Serializable

@Serializable
@Entity(
    tableName = "transactions",
    indices = [
        Index(value = ["categoryId"]),
        Index(value = ["accountId"]),
    ],
    foreignKeys = [
        ForeignKey(
            entity = Category::class,
            parentColumns = ["id"],
            childColumns = ["categoryId"],
            onDelete = ForeignKey.SET_NULL,
        ),
        ForeignKey(
            entity = Account::class,
            parentColumns = ["id"],
            childColumns = ["accountId"],
            onDelete = ForeignKey.CASCADE,
        ),
    ],
)
data class Transaction(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val description: String,
    val categoryId: Int?,
    val amount: Double,
    val date: Long,
    val accountId: Int,
    val notes: String?,
    val transactionType: String = "expense",
    val sourceSmsId: Long? = null,
    val sourceSmsHash: String? = null,
    // --- NEW: Add a field to track the origin of the transaction ---
    val source: String = "Manual Entry"
)
-e 


================== FILE: ./app/src/main/java/SmsReceiver.kt ==================
package io.pm.finlight

import android.Manifest
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.provider.Telephony
import android.telephony.SmsMessage as TelephonySmsMessage
import android.util.Log
import androidx.core.app.ActivityCompat
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch

class SmsReceiver : BroadcastReceiver() {
    private val TAG = "SmsReceiver"

    override fun onReceive(
        context: Context,
        intent: Intent,
    ) {
        if (intent.action == Telephony.Sms.Intents.SMS_RECEIVED_ACTION) {
            val pendingResult = goAsync()
            CoroutineScope(Dispatchers.IO).launch {
                try {
                    val messages = Telephony.Sms.Intents.getMessagesFromIntent(intent)
                    val messagesBySender = messages.groupBy { it.originatingAddress }

                    for ((sender, parts) in messagesBySender) {
                        if (sender == null) continue

                        val fullBody = parts.joinToString("") { it.messageBody }
                        val smsId = parts.first().timestampMillis

                        val db = AppDatabase.getInstance(context)
                        val transactionDao = db.transactionDao()
                        val accountDao = db.accountDao()
                        val mappingRepository = MerchantMappingRepository(db.merchantMappingDao())

                        val existingMappings = mappingRepository.allMappings.first().associateBy({ it.smsSender }, { it.merchantName })
                        val existingSmsHashes = transactionDao.getAllSmsHashes().first().toSet()

                        val smsMessage = SmsMessage(id = smsId, sender = sender, body = fullBody, date = smsId)
                        val potentialTxn = SmsParser.parse(smsMessage, existingMappings)

                        if (potentialTxn != null && !existingSmsHashes.contains(potentialTxn.sourceSmsHash)) {
                            Log.d(TAG, "New potential transaction found: $potentialTxn. Saving automatically.")

                            val accountName = potentialTxn.potentialAccount?.formattedName ?: "Unknown Account"
                            val accountType = potentialTxn.potentialAccount?.accountType ?: "General"

                            var account = accountDao.findByName(accountName)
                            if (account == null) {
                                val newAccount = Account(name = accountName, type = accountType)
                                accountDao.insert(newAccount)
                                account = accountDao.findByName(accountName)
                            }

                            if (account != null) {
                                val newTransaction = Transaction(
                                    description = potentialTxn.merchantName ?: "Unknown Merchant",
                                    amount = potentialTxn.amount,
                                    date = System.currentTimeMillis(),
                                    accountId = account.id,
                                    categoryId = null,
                                    notes = "", // Keep notes empty for user
                                    transactionType = potentialTxn.transactionType,
                                    sourceSmsId = potentialTxn.sourceSmsId,
                                    sourceSmsHash = potentialTxn.sourceSmsHash,
                                    // --- UPDATED: Set the source for auto-imports ---
                                    source = "Auto-Imported"
                                )
                                // The insert method returns the ID of the new row
                                val newTransactionId = transactionDao.insert(newTransaction)
                                Log.d(TAG, "Transaction saved successfully with ID: $newTransactionId")

                                // --- UPDATED: Show informational notification ---
                                if (ActivityCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) == PackageManager.PERMISSION_GRANTED) {
                                    NotificationHelper.showAutoSaveConfirmationNotification(context, newTransaction.copy(id = newTransactionId.toInt()))
                                }

                            } else {
                                Log.e(TAG, "Failed to find or create an account for the transaction.")
                            }
                        }
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Error processing SMS", e)
                } finally {
                    pendingResult.finish()
                }
            }
        }
    }
}
-e 


================== FILE: ./app/src/main/java/NotificationHelper.kt ==================
package io.pm.finlight

import android.Manifest
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.app.TaskStackBuilder
import androidx.core.net.toUri
import com.google.gson.Gson
import java.net.URLEncoder

object NotificationHelper {
    private const val DEEP_LINK_URI_APPROVE = "app://finlight.pm.io/approve_sms"
    private const val DEEP_LINK_URI_EDIT = "app://finlight.pm.io/transaction_detail"

    fun showAutoSaveConfirmationNotification(
        context: Context,
        transaction: Transaction
    ) {
        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
            return
        }

        // --- BUG FIX: Correctly build the back stack to avoid double-back-press issue ---
        // This ensures a clean navigation path: Notification -> Detail Screen -> Dashboard.

        // Create the Intent for the deep link. This is the only Intent we need to provide.
        val detailIntent = Intent(
            Intent.ACTION_VIEW,
            "$DEEP_LINK_URI_EDIT/${transaction.id}".toUri(),
            context,
            MainActivity::class.java
        )

        // TaskStackBuilder will use this single intent to create the full, correct back stack
        // by looking at the parent activity defined in the manifest.
        val pendingIntent: PendingIntent? = TaskStackBuilder.create(context).run {
            // This correctly adds the parent (MainActivity) and then the detailIntent on top.
            addNextIntentWithParentStack(detailIntent)
            // Get the PendingIntent containing the entire back stack.
            getPendingIntent(transaction.id, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
        }


        val builder = NotificationCompat.Builder(context, MainApplication.TRANSACTION_CHANNEL_ID)
            .setSmallIcon(android.R.drawable.ic_dialog_info)
            .setContentTitle("Transaction Auto-Saved")
            .setContentText("Saved ${transaction.description} (${"%.2f".format(transaction.amount)}). Tap to edit or categorize.")
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .addAction(android.R.drawable.ic_menu_edit, "Edit", pendingIntent)

        with(NotificationManagerCompat.from(context)) {
            notify(transaction.id, builder.build())
        }
    }

    fun showTransactionNotification(
        context: Context,
        potentialTransaction: PotentialTransaction,
    ) {
        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
            return
        }

        val potentialTxnJson = Gson().toJson(potentialTransaction)
        val encodedJson = URLEncoder.encode(potentialTxnJson, "UTF-8")
        val approveUri = "$DEEP_LINK_URI_APPROVE?potentialTxnJson=$encodedJson".toUri()

        val intent = Intent(Intent.ACTION_VIEW, approveUri).apply {
            `package` = context.packageName
        }

        val pendingIntent = PendingIntent.getActivity(
            context,
            potentialTransaction.sourceSmsId.toInt(),
            intent,
            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT,
        )

        val notificationIcon = android.R.drawable.ic_dialog_info
        val typeText = potentialTransaction.transactionType.replaceFirstChar { it.uppercase() }
        val bigText = "$typeText of ${"%.2f".format(potentialTransaction.amount)} from ${potentialTransaction.merchantName ?: "Unknown Sender"} detected. Tap to add."

        val builder = NotificationCompat.Builder(context, MainApplication.TRANSACTION_CHANNEL_ID)
            .setSmallIcon(notificationIcon)
            .setContentTitle("New Transaction Found")
            .setContentText("Tap to review a transaction from ${potentialTransaction.merchantName ?: "Unknown Sender"}.")
            .setStyle(NotificationCompat.BigTextStyle().bigText(bigText))
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .addAction(notificationIcon, "Review & Categorize", pendingIntent)

        with(NotificationManagerCompat.from(context)) {
            notify(potentialTransaction.sourceSmsId.toInt(), builder.build())
        }
    }
    fun showDailyReportNotification(
        context: Context,
        totalExpenses: Double,
    ) {
        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
            return
        }

        val intent =
            Intent(context, MainActivity::class.java).apply {
                flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
            }

        val pendingIntent = PendingIntent.getActivity(context, 100, intent, PendingIntent.FLAG_IMMUTABLE)

        val reportText =
            if (totalExpenses > 0) {
                "You spent a total of ${"%.2f".format(totalExpenses)} yesterday."
            } else {
                "Great job! You had no expenses yesterday."
            }

        val notification =
            NotificationCompat.Builder(context, MainApplication.DAILY_REPORT_CHANNEL_ID)
                .setSmallIcon(android.R.drawable.ic_dialog_info)
                .setContentTitle("Your Daily Report")
                .setContentText(reportText)
                .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                .setContentIntent(pendingIntent)
                .setAutoCancel(true)
                .build()

        NotificationManagerCompat.from(context).notify(2, notification)
    }

    fun showWeeklySummaryNotification(
        context: Context,
        totalIncome: Double,
        totalExpenses: Double,
    ) {
        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
            return
        }

        val intent =
            Intent(context, MainActivity::class.java).apply {
                flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
            }

        val pendingIntent = PendingIntent.getActivity(context, 101, intent, PendingIntent.FLAG_IMMUTABLE)

        val summaryText = "Income: ${"%.2f".format(totalIncome)} | Expenses: ${"%.2f".format(totalExpenses)}"

        val notification =
            NotificationCompat.Builder(context, MainApplication.SUMMARY_CHANNEL_ID)
                .setSmallIcon(android.R.drawable.ic_menu_my_calendar)
                .setContentTitle("Your Weekly Financial Summary")
                .setContentText(summaryText)
                .setStyle(NotificationCompat.BigTextStyle().bigText(summaryText))
                .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                .setContentIntent(pendingIntent)
                .setAutoCancel(true)
                .build()

        NotificationManagerCompat.from(context).notify(3, notification)
    }
}
-e 


================== FILE: ./app/src/main/java/TransactionRepository.kt ==================
package io.pm.finlight

import android.net.Uri
import android.util.Log
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.onEach

class TransactionRepository(private val transactionDao: TransactionDao) {
    val allTransactions: Flow<List<TransactionDetails>> =
        transactionDao.getAllTransactions()
            .onEach { transactions ->
                Log.d(
                    "TransactionFlowDebug",
                    "Repository Flow Emitted. Count: ${transactions.size}. Newest: ${transactions.firstOrNull()?.transaction?.description}",
                )
            }

    // --- NEW: Expose the merchant spending data ---
    fun getSpendingByMerchantForMonth(startDate: Long, endDate: Long): Flow<List<MerchantSpendingSummary>> {
        return transactionDao.getSpendingByMerchantForMonth(startDate, endDate)
    }

    // --- Methods for image attachments ---
    suspend fun addImageToTransaction(transactionId: Int, imageUri: String) {
        val transactionImage = TransactionImage(transactionId = transactionId, imageUri = imageUri)
        transactionDao.insertImage(transactionImage)
    }

    suspend fun deleteImage(transactionImage: TransactionImage) {
        transactionDao.deleteImage(transactionImage)
    }

    fun getImagesForTransaction(transactionId: Int): Flow<List<TransactionImage>> {
        return transactionDao.getImagesForTransaction(transactionId)
    }

    suspend fun updateDescription(id: Int, description: String) = transactionDao.updateDescription(id, description)
    suspend fun updateAmount(id: Int, amount: Double) = transactionDao.updateAmount(id, amount)
    suspend fun updateNotes(id: Int, notes: String?) = transactionDao.updateNotes(id, notes)
    suspend fun updateCategoryId(id: Int, categoryId: Int?) = transactionDao.updateCategoryId(id, categoryId)
    suspend fun updateAccountId(id: Int, accountId: Int) = transactionDao.updateAccountId(id, accountId)
    suspend fun updateDate(id: Int, date: Long) = transactionDao.updateDate(id, date)

    fun getTransactionDetailsById(id: Int): Flow<TransactionDetails?> {
        return transactionDao.getTransactionDetailsById(id)
    }

    val recentTransactions: Flow<List<TransactionDetails>> = transactionDao.getRecentTransactionDetails()

    fun getAllSmsHashes(): Flow<List<String>> {
        return transactionDao.getAllSmsHashes()
    }

    fun getTransactionsForAccountDetails(accountId: Int): Flow<List<TransactionDetails>> {
        return transactionDao.getTransactionsForAccountDetails(accountId)
    }

    fun getTransactionDetailsForRange(
        startDate: Long,
        endDate: Long,
    ): Flow<List<TransactionDetails>> {
        return transactionDao.getTransactionDetailsForRange(startDate, endDate)
    }

    fun getAllTransactionsSimple(): Flow<List<Transaction>> {
        return transactionDao.getAllTransactionsSimple()
    }

    fun getAllTransactionsForRange(
        startDate: Long,
        endDate: Long,
    ): Flow<List<Transaction>> {
        return transactionDao.getAllTransactionsForRange(startDate, endDate)
    }

    fun getTransactionById(id: Int): Flow<Transaction?> {
        return transactionDao.getTransactionById(id)
    }

    fun getTransactionsForAccount(accountId: Int): Flow<List<Transaction>> {
        return transactionDao.getTransactionsForAccount(accountId)
    }

    fun getSpendingForCategory(
        categoryName: String,
        startDate: Long,
        endDate: Long,
    ): Flow<Double?> {
        return transactionDao.getSpendingForCategory(categoryName, startDate, endDate)
    }

    fun getSpendingByCategoryForMonth(
        startDate: Long,
        endDate: Long,
    ): Flow<List<CategorySpending>> {
        return transactionDao.getSpendingByCategoryForMonth(startDate, endDate)
    }

    fun getMonthlyTrends(startDate: Long): Flow<List<MonthlyTrend>> {
        return transactionDao.getMonthlyTrends(startDate)
    }

    suspend fun countTransactionsForCategory(categoryId: Int): Int {
        return transactionDao.countTransactionsForCategory(categoryId)
    }

    fun getTagsForTransaction(transactionId: Int): Flow<List<Tag>> {
        return transactionDao.getTagsForTransaction(transactionId)
    }

    suspend fun updateTagsForTransaction(transactionId: Int, tags: Set<Tag>) {
        transactionDao.clearTagsForTransaction(transactionId)
        if (tags.isNotEmpty()) {
            val crossRefs = tags.map { tag ->
                TransactionTagCrossRef(transactionId = transactionId, tagId = tag.id)
            }
            transactionDao.addTagsToTransaction(crossRefs)
        }
    }

    suspend fun insertTransactionWithTags(transaction: Transaction, tags: Set<Tag>) {
        val transactionId = transactionDao.insert(transaction).toInt()
        if (tags.isNotEmpty()) {
            val crossRefs = tags.map { tag ->
                TransactionTagCrossRef(transactionId = transactionId, tagId = tag.id)
            }
            transactionDao.addTagsToTransaction(crossRefs)
        }
    }

    suspend fun updateTransactionWithTags(transaction: Transaction, tags: Set<Tag>) {
        transactionDao.update(transaction)
        transactionDao.clearTagsForTransaction(transaction.id)
        if (tags.isNotEmpty()) {
            val crossRefs = tags.map { tag ->
                TransactionTagCrossRef(transactionId = transaction.id, tagId = tag.id)
            }
            transactionDao.addTagsToTransaction(crossRefs)
        }
    }

    // --- FIX: Changed parameter from List<Uri> to List<String> to accept permanent paths ---
    suspend fun insertTransactionWithTagsAndImages(
        transaction: Transaction,
        tags: Set<Tag>,
        imagePaths: List<String> // Changed from imageUris
    ): Long {
        // First, insert the main transaction to get its ID
        val newTransactionId = transactionDao.insert(transaction)

        // Then, use the new ID to associate tags
        if (tags.isNotEmpty()) {
            val crossRefs = tags.map { tag ->
                TransactionTagCrossRef(transactionId = newTransactionId.toInt(), tagId = tag.id)
            }
            transactionDao.addTagsToTransaction(crossRefs)
        }

        // Finally, use the ID to associate images with their permanent paths
        imagePaths.forEach { path ->
            val imageEntity = TransactionImage(
                transactionId = newTransactionId.toInt(),
                imageUri = path // Save the permanent file path
            )
            transactionDao.insertImage(imageEntity)
        }
        return newTransactionId
    }

    suspend fun insert(transaction: Transaction) {
        transactionDao.insert(transaction)
    }

    suspend fun update(transaction: Transaction) {
        transactionDao.update(transaction)
    }

    suspend fun delete(transaction: Transaction) {
        transactionDao.delete(transaction)
    }
}
-e 


================== FILE: ./app/src/main/java/DashboardViewModel.kt ==================
package io.pm.finlight

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Locale

class DashboardViewModel(
    private val transactionRepository: TransactionRepository,
    private val accountRepository: AccountRepository,
    private val budgetDao: BudgetDao,
    private val settingsRepository: SettingsRepository,
) : ViewModel() {
    val userName: StateFlow<String>
    val profilePictureUri: StateFlow<String?>

    val netWorth: StateFlow<Double>
    val monthlyIncome: StateFlow<Double>
    val monthlyExpenses: StateFlow<Double>
    val recentTransactions: StateFlow<List<TransactionDetails>>
    val budgetStatus: StateFlow<List<BudgetWithSpending>>
    val overallMonthlyBudget: StateFlow<Float>
    val amountRemaining: StateFlow<Float>
    val safeToSpendPerDay: StateFlow<Float>
    val accountsSummary: StateFlow<List<AccountWithBalance>>

    init {
        userName = settingsRepository.getUserName()
            .stateIn(
                scope = viewModelScope,
                started = SharingStarted.WhileSubscribed(5000),
                initialValue = "User"
            )

        profilePictureUri = settingsRepository.getProfilePictureUri()
            .stateIn(
                scope = viewModelScope,
                started = SharingStarted.WhileSubscribed(5000),
                initialValue = null
            )

        val calendar = Calendar.getInstance()
        val monthStart =
            (calendar.clone() as Calendar).apply {
                set(Calendar.DAY_OF_MONTH, 1)
                set(Calendar.HOUR_OF_DAY, 0)
                set(Calendar.MINUTE, 0)
                set(Calendar.SECOND, 0)
                set(Calendar.MILLISECOND, 0)
            }.timeInMillis
        val monthEnd =
            (calendar.clone() as Calendar).apply {
                add(Calendar.MONTH, 1)
                set(Calendar.DAY_OF_MONTH, 1)
                add(Calendar.DAY_OF_MONTH, -1)
                set(Calendar.HOUR_OF_DAY, 23)
                set(Calendar.MINUTE, 59)
                set(Calendar.SECOND, 59)
                set(Calendar.MILLISECOND, 999)
            }.timeInMillis

        val transactionsThisMonth = transactionRepository.getTransactionDetailsForRange(monthStart, monthEnd)
            .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

        monthlyIncome =
            transactionsThisMonth.map { transactions ->
                transactions
                    .filter { it.transaction.transactionType == "income" }
                    .sumOf { it.transaction.amount }
            }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0.0)

        monthlyExpenses =
            transactionsThisMonth.map { transactions ->
                transactions
                    .filter { it.transaction.transactionType == "expense" }
                    .sumOf { it.transaction.amount }
            }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0.0)

        val currentYear = calendar.get(Calendar.YEAR)
        val currentMonth = calendar.get(Calendar.MONTH) + 1

        // --- FIX: Use the correct repository method with parameters ---
        overallMonthlyBudget =
            settingsRepository.getOverallBudgetForMonth(currentYear, currentMonth)
                .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0f)

        amountRemaining =
            combine(overallMonthlyBudget, monthlyExpenses) { budget, expenses ->
                budget - expenses.toFloat()
            }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0f)

        safeToSpendPerDay =
            amountRemaining.map { remaining ->
                val today = Calendar.getInstance()
                val lastDayOfMonth = today.getActualMaximum(Calendar.DAY_OF_MONTH)
                val remainingDays = (lastDayOfMonth - today.get(Calendar.DAY_OF_MONTH) + 1).coerceAtLeast(1)

                if (remaining > 0) remaining / remainingDays else 0f
            }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0f)

        netWorth =
            accountRepository.accountsWithBalance.map { list ->
                list.sumOf { it.balance }
            }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 0.0)

        recentTransactions =
            transactionRepository.recentTransactions
                .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

        val yearMonthString = SimpleDateFormat("yyyy-MM", Locale.getDefault()).format(calendar.time)
        budgetStatus = budgetDao.getBudgetsWithSpendingForMonth(yearMonthString, currentMonth, currentYear)
            .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

        accountsSummary =
            accountRepository.accountsWithBalance
                .stateIn(
                    scope = viewModelScope,
                    started = SharingStarted.WhileSubscribed(5000),
                    initialValue = emptyList(),
                )
    }
}
-e 


---------- Instrumented Test Files (UI Tests) ----------
================== FILE: ./app/src/androidTest/java/io/pm/finlight/TransactionCrudTests.kt ==================
package io.pm.finlight

import android.Manifest
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.rule.GrantPermissionRule
import org.junit.Rule
import org.junit.Test
import org.junit.rules.RuleChain
import org.junit.runner.RunWith
import java.util.UUID

/**
 * Instrumented UI tests for the full CRUD (Create, Read, Update, Delete)
 * lifecycle of a transaction.
 */
@RunWith(AndroidJUnit4::class)
class TransactionCrudTests {
    private val composeTestRule = createAndroidComposeRule<MainActivity>()

    @get:Rule
    val ruleChain: RuleChain =
        RuleChain
            .outerRule(DisableOnboardingRule())
            .around(DisableAppLockRule())
            .around(
                GrantPermissionRule.grant(
                    Manifest.permission.READ_SMS,
                    Manifest.permission.RECEIVE_SMS,
                    Manifest.permission.POST_NOTIFICATIONS,
                ),
            )
            .around(composeTestRule)

    /**
     * A helper function to add a transaction, reducing code duplication in tests.
     * @return The unique description of the created transaction.
     */
    private fun addTransactionForTest(): String {
        val uniqueDescription = "Test Transaction ${UUID.randomUUID()}"

        composeTestRule.waitUntil(timeoutMillis = 10000) {
            composeTestRule.onAllNodesWithText("Monthly Budget").fetchSemanticsNodes().isNotEmpty()
        }
        composeTestRule.onNodeWithContentDescription("Add").performClick()

        // Wait for AddTransactionScreen to appear and fill the form
        composeTestRule.waitUntil(timeoutMillis = 5000) {
            composeTestRule.onAllNodesWithTag("description_input").fetchSemanticsNodes().isNotEmpty()
        }
        // --- FIX: Use onNodeWithTag to reliably find the text field ---
        composeTestRule.onNodeWithTag("description_input").performTextInput(uniqueDescription)
        composeTestRule.onNodeWithText("0.00").performTextInput("100.0")
        composeTestRule.onNodeWithText("Select account").performClick()
        composeTestRule.onNodeWithText("SBI").performClick()
        composeTestRule.onNodeWithText("Select category").performClick()
        composeTestRule.onNodeWithText("Food & Drinks").performClick()
        composeTestRule.onNodeWithText("Save").performClick()

        // Wait to return to the dashboard and confirm the new item is there.
        composeTestRule.waitUntil(timeoutMillis = 5000) {
            composeTestRule.onAllNodesWithText(uniqueDescription).fetchSemanticsNodes().isNotEmpty()
        }
        return uniqueDescription
    }

    /**
     * Tests that a newly created transaction appears on the dashboard.
     */
    @Test
    fun test_createTransaction_appearsOnDashboard() {
        val description = addTransactionForTest()
        composeTestRule.onNodeWithText(description, useUnmergedTree = true)
            .performScrollTo()
            .assertIsDisplayed()
    }

    /**
     * Tests that a transaction can be successfully edited and the update
     * is reflected on the dashboard.
     */
    @Test
    fun test_editTransaction_updatesSuccessfully() {
        val originalDescription = addTransactionForTest()
        val updatedDescription = "Updated UI Test Dinner"

        // 1. Find the transaction on the dashboard and click to open the detail screen.
        composeTestRule.onNodeWithText(originalDescription, useUnmergedTree = true)
            .performScrollTo()
            .performClick()

        // 2. On the detail screen, wait for it to load, then click the description to open the bottom sheet.
        composeTestRule.waitUntil(timeoutMillis = 5000) {
            composeTestRule.onAllNodesWithText(originalDescription).fetchSemanticsNodes().isNotEmpty()
        }
        composeTestRule.onNodeWithText(originalDescription).performClick()

        // 3. In the bottom sheet, edit the text field and save.
        // --- FIX: Use onNodeWithTag to reliably find the text field ---
        composeTestRule.onNodeWithTag("value_input").performTextClearance()
        composeTestRule.onNodeWithTag("value_input").performTextInput(updatedDescription)
        composeTestRule.onNodeWithText("Save").performClick()


        // 4. Verify the description is updated on the detail screen.
        composeTestRule.onNodeWithText(updatedDescription).assertIsDisplayed()

        // 5. Navigate back to the dashboard.
        composeTestRule.onNodeWithContentDescription("Back").performClick()

        // 6. Assert that the old description is gone and the new one is displayed on the dashboard.
        composeTestRule.waitUntil(timeoutMillis = 5000) {
            composeTestRule.onAllNodesWithText("Monthly Budget").fetchSemanticsNodes().isNotEmpty()
        }
        composeTestRule.onNodeWithText(originalDescription).assertDoesNotExist()
        composeTestRule.onNodeWithText(updatedDescription, useUnmergedTree = true)
            .performScrollTo()
            .assertIsDisplayed()
    }

    /**
     * Tests that a transaction can be successfully deleted from the detail screen.
     */
    @Test
    fun test_deleteTransaction_removesFromList() {
        val description = addTransactionForTest()

        // 1. Find the transaction on the dashboard and click to open the detail screen.
        composeTestRule.onNodeWithText(description, useUnmergedTree = true)
            .performScrollTo()
            .performClick()

        // 2. On the detail screen, click the 'More' menu icon.
        composeTestRule.waitUntil(timeoutMillis = 5000) {
            composeTestRule.onAllNodesWithContentDescription("More options").fetchSemanticsNodes().isNotEmpty()
        }
        composeTestRule.onNodeWithContentDescription("More options").performClick()

        // 3. Click the 'Delete' option in the dropdown menu.
        composeTestRule.onNodeWithText("Delete").performClick()

        // 4. Confirm the deletion in the dialog.
        composeTestRule.onNodeWithText("Delete Transaction?").assertIsDisplayed()
        composeTestRule.onNodeWithText("Delete").performClick()

        // 5. Wait to navigate back to the dashboard and assert the item is gone.
        composeTestRule.waitUntil(timeoutMillis = 5000) {
            composeTestRule.onAllNodesWithText("Monthly Budget").fetchSemanticsNodes().isNotEmpty()
        }
        composeTestRule.onNodeWithText(description).assertDoesNotExist()
    }
}
-e 


================== FILE: ./app/src/androidTest/java/io/pm/finlight/TestRules.kt ==================
package io.pm.finlight

import android.content.Context
import androidx.test.platform.app.InstrumentationRegistry
import org.junit.rules.TestRule
import org.junit.runner.Description
import org.junit.runners.model.Statement

/**
 * A custom JUnit Rule to disable the onboarding screen before a test runs.
 * This rule accesses the app's SharedPreferences and sets the flag to true,
 * ensuring the onboarding flow does not interfere with UI tests.
 */
class DisableOnboardingRule : TestRule {
    override fun apply(base: Statement, description: Description): Statement {
        return object : Statement() {
            override fun evaluate() {
                try {
                    val context = InstrumentationRegistry.getInstrumentation().targetContext
                    val prefs = context.getSharedPreferences("finance_app_settings", Context.MODE_PRIVATE)
                    prefs.edit().putBoolean("has_seen_onboarding", true).commit()
                    base.evaluate()
                } finally {
                    // Cleanup not needed
                }
            }
        }
    }
}

/**
 * A custom JUnit Rule to disable the app lock feature before a test runs.
 * This rule accesses the app's SharedPreferences and sets the app lock flag to false,
 * ensuring the lock screen does not interfere with UI tests.
 */
class DisableAppLockRule : TestRule {
    override fun apply(base: Statement, description: Description): Statement {
        return object : Statement() {
            override fun evaluate() {
                try {
                    val context = InstrumentationRegistry.getInstrumentation().targetContext
                    val prefs = context.getSharedPreferences("finance_app_settings", Context.MODE_PRIVATE)
                    prefs.edit().putBoolean("app_lock_enabled", false).commit()
                    base.evaluate()
                } finally {
                    // Cleanup not needed
                }
            }
        }
    }
}
-e 


================== FILE: ./app/src/androidTest/java/io/pm/finlight/AppWorkflowTests.kt ==================
package io.pm.finlight

import android.Manifest
import android.content.Context
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.rule.GrantPermissionRule
import org.junit.Rule
import org.junit.Test
import org.junit.rules.RuleChain
import org.junit.rules.TestRule
import org.junit.runner.Description
import org.junit.runner.RunWith
import org.junit.runners.model.Statement
import java.util.UUID


/**
 * Instrumented UI test for common user workflows in the application.
 *
 * NOTE: This file has been updated to include a custom TestRule to bypass the
 * onboarding screen, ensuring tests start in a consistent state.
 */
@RunWith(AndroidJUnit4::class)
class AppWorkflowTests {
    private val composeTestRule = createAndroidComposeRule<MainActivity>()

    @get:Rule
    val ruleChain: RuleChain =
        RuleChain
            // --- NEW: This rule runs first to bypass the onboarding screen ---
            .outerRule(DisableOnboardingRule())
            .around(DisableAppLockRule())
            .around(
                GrantPermissionRule.grant(
                    Manifest.permission.READ_SMS,
                    Manifest.permission.RECEIVE_SMS,
                    Manifest.permission.POST_NOTIFICATIONS,
                ),
            )
            .around(composeTestRule)

    /**
     * Tests the "happy path" workflow of adding a new transaction and verifying
     * it appears on the dashboard.
     */
    @Test
    fun test_addNewTransaction_appearsOnDashboard() {
        val uniqueDescription = "Test Coffee Purchase ${UUID.randomUUID()}"

        // 1. Wait until the dashboard is fully loaded by checking for a stable element.
        composeTestRule.waitUntil(timeoutMillis = 10000) {
            composeTestRule.onAllNodesWithText("Monthly Budget").fetchSemanticsNodes().isNotEmpty()
        }

        // 2. Click the main FAB to add a new item.
        composeTestRule.onNodeWithContentDescription("Add").performClick()

        // 3. Verify we are on the "Add Transaction" screen and fill out the form.
        composeTestRule.onNodeWithText("Add Transaction").assertIsDisplayed()
        composeTestRule.onNodeWithText("Description").performTextInput(uniqueDescription)
        composeTestRule.onNodeWithText("Amount").performTextInput("150.0")
        composeTestRule.onNodeWithText("Select Account").performClick()
        composeTestRule.onNodeWithText("SBI").performClick()
        composeTestRule.onNodeWithText("Select Category").performClick()
        composeTestRule.onNodeWithText("Food").performClick()

        // 4. Save the transaction.
        composeTestRule.onNodeWithText("Save Transaction").performClick()

        // --- Wait for navigation back to the dashboard to complete ---
        composeTestRule.waitUntil(timeoutMillis = 5000) {
            composeTestRule.onAllNodesWithText("Monthly Budget").fetchSemanticsNodes().isNotEmpty()
        }

        // 5. Verify the new transaction appears in the "Recent Transactions" list.
        val newNode = composeTestRule.onNodeWithText(uniqueDescription, useUnmergedTree = true)
        newNode.performScrollTo()
        newNode.assertIsDisplayed()
    }

    /**
     * Tests the "sad path" workflow where a user tries to save a transaction
     * with invalid input (e.g., non-numeric amount) and sees an error.
     */
    @Test
    fun test_addTransaction_failsWithInvalidAmount_showsValidationError() {
        // 1. Wait for the dashboard and navigate to the Add Transaction Screen.
        composeTestRule.waitUntil(timeoutMillis = 10000) {
            composeTestRule.onAllNodesWithText("Monthly Budget").fetchSemanticsNodes().isNotEmpty()
        }
        composeTestRule.onNodeWithContentDescription("Add").performClick()

        // 2. Fill out the form, but with an invalid (non-numeric) amount.
        composeTestRule.onNodeWithText("Add Transaction").assertIsDisplayed()
        composeTestRule.onNodeWithText("Description").performTextInput("Test Invalid Amount")
        composeTestRule.onNodeWithText("Amount").performTextInput("not-a-number")
        composeTestRule.onNodeWithText("Select Account").performClick()
        composeTestRule.onNodeWithText("SBI").performClick()
        composeTestRule.onNodeWithText("Select Category").performClick()
        composeTestRule.onNodeWithText("Food").performClick()

        // 3. Attempt to save the invalid transaction.
        composeTestRule.onNodeWithText("Save Transaction").performClick()

        // 4. Verify the validation error.
        composeTestRule.onNodeWithText("Add Transaction").assertIsDisplayed()
        val expectedError = "Please enter a valid, positive amount."
        composeTestRule.onNodeWithText(expectedError).assertIsDisplayed()
    }
}
-e 


---------- Unit Test Files ----------
================== FILE: ./app/src/test/java/io/pm/finlight/DashboardViewModelTest.kt ==================
package io.pm.finlight

import android.app.Application
import android.os.Build
import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.test.*
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.annotation.Config
import java.util.Calendar

@ExperimentalCoroutinesApi
@RunWith(AndroidJUnit4::class)
@Config(sdk = [Build.VERSION_CODES.UPSIDE_DOWN_CAKE]) // UPSIDE_DOWN_CAKE is API 34
class DashboardViewModelTest {
    @get:Rule
    var instantTaskExecutorRule = InstantTaskExecutorRule()

    private val testDispatcher = UnconfinedTestDispatcher()

    private lateinit var database: AppDatabase
    private lateinit var viewModel: DashboardViewModel
    private lateinit var settingsRepository: SettingsRepository
    private lateinit var transactionRepository: TransactionRepository
    private lateinit var accountRepository: AccountRepository
    private lateinit var budgetDao: BudgetDao

    @Before
    fun setup() {
        Dispatchers.setMain(testDispatcher)

        val context = ApplicationProvider.getApplicationContext<Application>()

        database =
            Room.inMemoryDatabaseBuilder(context, AppDatabase::class.java)
                .allowMainThreadQueries()
                .build()

        transactionRepository = TransactionRepository(database.transactionDao())
        accountRepository = AccountRepository(database.accountDao())
        settingsRepository = SettingsRepository(context)
        budgetDao = database.budgetDao()

        viewModel =
            DashboardViewModel(
                transactionRepository = transactionRepository,
                accountRepository = accountRepository,
                budgetDao = budgetDao,
                settingsRepository = settingsRepository,
            )
    }

    @After
    fun tearDown() {
        database.close()
        Dispatchers.resetMain()
    }

    @Test
    fun test_safeToSpend_calculationIsCorrect() =
        runTest {
            // --- ARRANGE ---
            // 1. Set a budget.
            val testBudget = 30000f
            settingsRepository.saveOverallBudgetForCurrentMonth(testBudget)

            // 2. Insert test data directly inside the runTest scope.
            val accountDao = database.accountDao()
            val categoryDao = database.categoryDao()
            val transactionDao = database.transactionDao()

            accountDao.insert(Account(id = 1, name = "Test Bank", type = "Savings"))
            categoryDao.insert(Category(id = 1, name = "Food"))

            val calendar = Calendar.getInstance()
            transactionDao.insert(
                Transaction(
                    description = "Groceries",
                    amount = 2500.0,
                    date = calendar.timeInMillis,
                    accountId = 1,
                    categoryId = 1,
                    transactionType = "expense",
                    notes = "",
                ),
            )

            // --- ACT ---
            advanceUntilIdle() // Ensure all initial jobs in ViewModel are complete.
            val safeToSpend = viewModel.safeToSpendPerDay.first()

            // --- ASSERT ---
            val monthlyExpenses = viewModel.monthlyExpenses.first()
            val remainingBudget = testBudget - monthlyExpenses.toFloat()

            val lastDayOfMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH)
            val currentDay = calendar.get(Calendar.DAY_OF_MONTH)
            val remainingDays = (lastDayOfMonth - currentDay + 1).coerceAtLeast(1)

            val expectedSafeToSpend = if (remainingBudget > 0) remainingBudget / remainingDays else 0f

            assertEquals("Safe to spend calculation is incorrect", expectedSafeToSpend, safeToSpend, 0.01f)
        }
}
-e 


================== FILE: ./app/src/test/java/io/pm/finlight/ExampleUnitTest.kt ==================
package io.pm.finlight

import org.junit.Assert.*
import org.junit.Test

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}
-e 


================== FILE: ./app/src/test/java/io/pm/finlight/SmsParserTest.kt ==================
package io.pm.finlight

import org.junit.Assert.*
import org.junit.Test

/**
 * Unit tests for the SmsParser utility.
 */
class SmsParserTest {
    private val emptyMappings = emptyMap<String, String>()

    @Test
    fun `test parses debit message successfully`() {
        val smsBody = "Your account with HDFC Bank has been debited for Rs. 750.50 at Amazon on 22-Jun-2025."
        val mockSms = SmsMessage(id = 1L, sender = "AM-HDFCBK", body = smsBody, date = System.currentTimeMillis())

        val result = SmsParser.parse(mockSms, emptyMappings)

        assertNotNull("Parser should return a result for a debit message", result)
        assertEquals(750.50, result?.amount)
        assertEquals("expense", result?.transactionType)
        assertEquals("Amazon", result?.merchantName)
    }

    @Test
    fun `test parses credit message successfully`() {
        val smsBody = "You have received a credit of INR 5,000.00 from Freelance Client."
        val mockSms = SmsMessage(id = 2L, sender = "DM-SOMEBK", body = smsBody, date = System.currentTimeMillis())

        val result = SmsParser.parse(mockSms, emptyMappings)

        assertNotNull("Parser should return a result for a credit message", result)
        assertEquals(5000.00, result?.amount)
        assertEquals("income", result?.transactionType)
        assertEquals("Freelance Client", result?.merchantName)
    }

    @Test
    fun `test returns null for non-financial message`() {
        val smsBody = "Hello, just checking in. Are we still on for dinner tomorrow evening?"
        val mockSms = SmsMessage(id = 3L, sender = "+1234567890", body = smsBody, date = System.currentTimeMillis())

        val result = SmsParser.parse(mockSms, emptyMappings)

        assertNull("Parser should return null for a non-financial message", result)
    }

    // --- NEW TESTS FOR THE PROVIDED EXAMPLES ---

    @Test
    fun `test parses SBI Credit Card message`() {
        val smsBody = "Rs.267.00 spent on your SBI Credit Card ending with 3201 at HALLI THOTA on 29-06-25 via UPI (Ref No. 1231230123). Trxn. Not done by you? Report at https://sbicards.com/Dispute)"
        val mockSms = SmsMessage(id = 4L, sender = "VM-SBICRD", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings)

        assertNotNull(result)
        assertEquals(267.00, result?.amount)
        assertEquals("expense", result?.transactionType)
        assertEquals("HALLI THOTA", result?.merchantName)
        assertNotNull(result?.potentialAccount)
        assertEquals("SBI - xx3201", result?.potentialAccount?.formattedName)
        assertEquals("Credit Card", result?.potentialAccount?.accountType)
    }

    @Test
    fun `test parses ICICI debit message`() {
        val smsBody = "ICICI Bank Acct XX823 debited for Rs 240.00 on 21-Jun-25; DAKSHIN CAFE credited. UPI: 552200221100. Call 18002661 for dispute."
        val mockSms = SmsMessage(id = 5L, sender = "DM-ICIBNK", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings)

        assertNotNull(result)
        assertEquals(240.00, result?.amount)
        assertEquals("expense", result?.transactionType)
        assertEquals("DAKSHIN CAFE", result?.merchantName)
        assertNotNull(result?.potentialAccount)
        assertEquals("ICICI Bank - xx823", result?.potentialAccount?.formattedName)
        assertEquals("Savings Account", result?.potentialAccount?.accountType)
    }

    @Test
    fun `test parses HDFC card message`() {
        val smsBody = "[JD-HDFCBK-S] Spent Rs.388.19 On HDFC Bank Card 9922 At ..MC DONALDS_ on2025-06-22:08:01:24.Not You> To Block+Reissue Call 18002323232/SMS BLOCK CC 9922 to 123098123"
        val mockSms = SmsMessage(id = 6L, sender = "JD-HDFCBK", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings)

        assertNotNull(result)
        assertEquals(388.19, result?.amount)
        assertEquals("expense", result?.transactionType)
        assertEquals("MC DONALDS", result?.merchantName)
        assertNotNull(result?.potentialAccount)
        assertEquals("HDFC Bank - xx9922", result?.potentialAccount?.formattedName)
        assertEquals("Card", result?.potentialAccount?.accountType)
    }

    @Test
    fun `test parses Pluxee Meal Card message`() {
        val smsBody = "Rs. 60.00 spent from Pluxee Meal Card wallet, card no.xx1345 on 30-06-2025 18:41:56 at KITCHEN AFF . Avl bal Rs.1824.65. Not you call 18002106919"
        val mockSms = SmsMessage(id = 7L, sender = "VD-PLUXEE", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings)

        assertNotNull(result)
        assertEquals(60.00, result?.amount)
        assertEquals("expense", result?.transactionType)
        assertEquals("KITCHEN AFF", result?.merchantName)
        assertNotNull(result?.potentialAccount)
        assertEquals("Pluxee - xx1345", result?.potentialAccount?.formattedName)
        assertEquals("Meal Card wallet", result?.potentialAccount?.accountType)
    }

    @Test
    fun `test parses ICICI credit message with tricky format`() {
        val smsBody = "Dear Customer, Acct XX823 is credited with Rs 6000.00 on 26-Jun-25 from GANGA MANGA. UPI:5577822323232-ICICI Bank"
        val mockSms = SmsMessage(id = 8L, sender = "QP-ICIBNK", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings)

        assertNotNull(result)
        assertEquals(6000.00, result?.amount)
        assertEquals("income", result?.transactionType)
        assertEquals("GANGA MANGA", result?.merchantName)
        assertNotNull(result?.potentialAccount)
        assertEquals("ICICI Bank - xx823", result?.potentialAccount?.formattedName)
        assertEquals("Savings Account", result?.potentialAccount?.accountType)
    }

    // --- NEW: Unit tests for the latest fixes ---

    @Test
    fun `test ignores invoice message`() {
        val smsBody = "An Invoice of Rs.330.8 for A4 Block-108 is raised. Pay at https://nbhd.co/NBHood/g/szBBpng. Ignore if paid - NoBrokerHood"
        val mockSms = SmsMessage(id = 9L, sender = "VM-NBHOOD", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings)
        assertNull("Parser should ignore invoice messages", result)
    }

    @Test
    fun `test ignores successful payment confirmation`() {
        val smsBody = "Your payment of Rs.330.80 for A4-108 against Water Charges is successful. Regards NoBrokerHood"
        val mockSms = SmsMessage(id = 10L, sender = "VM-NBHOOD", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings)
        assertNull("Parser should ignore successful payment confirmations", result)
    }

    @Test
    fun `test parses ICICI NEFT credit message`() {
        val smsBody = "ICICI Bank Account XX823 credited:Rs. 1,133.00 on 01-Jul-25. Info NEFT-HDFCN5202507024345356218-. Available Balance is Rs. 1,858.35."
        val mockSms = SmsMessage(id = 11L, sender = "VM-ICIBNK", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings)

        assertNotNull(result)
        assertEquals(1133.00, result?.amount)
        assertEquals("income", result?.transactionType)
        assertEquals("NEFT-HDFCN5202507024345356218-", result?.merchantName)
        assertNotNull(result?.potentialAccount)
        assertEquals("ICICI Bank - xx823", result?.potentialAccount?.formattedName)
        assertEquals("Bank Account", result?.potentialAccount?.accountType)
    }

    @Test
    fun `test parses HDFC NEFT credit message`() {
        val smsBody = "HDFC Bank : NEFT money transfer Txn No HDFCN520253454560344 for Rs INR 1,500.00 has been credited to Manga Penga on 01-07-2025 at 08:05:30"
        val mockSms = SmsMessage(id = 12L, sender = "VM-HDFCBK", body = smsBody, date = System.currentTimeMillis())
        val result = SmsParser.parse(mockSms, emptyMappings)
        assertNull("Parser should ignore has been credited to messages", result)
    }
}
-e 


